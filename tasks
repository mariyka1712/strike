require tasks/test;
require tasks/doc;
require tasks/semver;
require tasks/module;

require tasks/deploy;

require tasks/expand;

# tasks we want to use/test
require tasks/archive;
require tasks/todo;
require tasks/compress;
require tasks/latex;
# task-devel(7) depends upon
# task-project(7) so it is
# automatically available
require tasks/devel;

# external build tool wrappers
# used for testing purposes
require tasks/ext/build/make;
require tasks/ext/build/rake;
require tasks/ext/build/ant;
require tasks/ext/build/mvn;

require tasks/ext/npm;

# exclude these tasks from the default test runner
# this test is used to force failure
tdd.suite.exclude! "task-test";
# this test is slow and should be run manually
tdd.suite.exclude! "jsonlint";

# exclude binary files that are not tests
tdd.suite.exclude! "profile.sh";
tdd.suite.exclude! "global.sh";
tdd.suite.exclude! "custom-install.sh";

taskinfo "Run autoreconf and create a distribution tarball. Use the install sub-command to test installation in the target directory.";
tasks.dist() {
  local name="${framework}";
  local fullname="${name}-${project_version}";
  local tarball="${fullname}.tar.gz";
  local archive="${target}/${tarball}";
  executable.validate autoreconf;
	autoreconf -fi;
  if [ -f "${archive}" ]; then
    rm "${archive}";
  fi
  make dist \
    && mv "${tarball}" "${target}" \
    || console quit 1 -- "failed to create %s" "${tarball}";
  if [ $# -gt 0 ]; then
    local cmd="${1:-}"; shift;
    local commands_namespace="dist.commands";
    if ! method.exists? "${commands_namespace}.${cmd}"; then
      console quit 1 -- "unknown dist sub-command %s" "${cmd}";
    fi
    delegate "${commands_namespace}" "${cmd}" $@;
  fi
}

dist.commands.install() {
  cd "${target}" \
    && tar -xvf "${tarball}" \
    && cd "${fullname}" \
    || console quit 1 -- "failed to extract %s and change to %s" \
    "${archive}" "${target}/${fullname}";
  console info -- "pwd %s" "$( pwd )";
  local prefix="${target}/install";
  if [ -d "${prefix}" ]; then
    local opts="-rf";
    $verbose && opts+="v";
    rm $opts "${prefix}";
  fi
  mkdir -p "${prefix}";
  console info -- "./configure %s" "--prefix=${prefix}";
	./configure --prefix="${prefix}";
  make && make install && make installcheck;
}

taskinfo jsoncc "Compile json checker source";
tasks.jsoncc() {
	executable.validate gcc;
	local exename="jsoncheck";
	"${executables[gcc]}" etc/json-checker/*.c etc/json-checker/*.h \
    -o "target/$exename" \
		|| console quit 1 -- "could not compile json-checker source";
}

taskinfo boilerplate "Install the boilerplate.sh file";
tasks.boilerplate() {
  # remove the path added be bake(1)
  export PATH=${PATH#*:};
  local name="boilerplate.sh";
  local source="bin/${name}";
  local boilerplate=$( command -v "${name}" );
  if [ -n "${boilerplate}" ]; then
    console info -- "location is %s" "${boilerplate}";
    local cpopts="-f";
    $verbose && cpopts+="v";
    cp $cpopts "${source}" "${boilerplate}" \
      || console quit 1 -- "could not install %s" "${source}";
    console success "installed %s" "${boilerplate}";
  else
    console info "%s is not installed" "${name}";
    # TODO: show a select to choose the path to copy to
  fi
}
