require tasks/test;
require tasks/doc;
require tasks/semver;
require tasks/module;

require tasks/deploy;

require tasks/expand;

# tasks we want to use/test
require tasks/archive;
require tasks/todo;
require tasks/compress;
require tasks/latex;
# task-devel(7) depends upon
# task-project(7) so it is
# automatically available
require tasks/devel;

# external build tool wrappers
# used for testing purposes
require tasks/ext/build/make;
require tasks/ext/build/rake;
require tasks/ext/build/ant;
require tasks/ext/build/mvn;

require tasks/ext/npm;

# exclude these tasks from the default test runner
# this test is used to force failure
tdd.suite.exclude! "task-test";
# this test is slow and should be run manually
tdd.suite.exclude! "jsonlint";

# exclude binary files that are not tests
tdd.suite.exclude! "profile.sh";
tdd.suite.exclude! "global.sh";
tdd.suite.exclude! "custom-install.sh";

taskinfo "Create a distribution tarball";
tasks.dist() {
  executable.validate autoreconf;
	autoreconf -fi;
  make dist;
}

taskinfo auto "Run autoreconf, configure, make, make check and make install in the context of the target directory";
tasks.auto() {
  executable.validate autoreconf;
	autoreconf -fi;
	#./configure && make;
  local prefix="${target}/install";
  if [ -d "${prefix}" ]; then
    local opts="-rf";
    $verbose && opts+="v";
    rm $opts "${prefix}";
  fi
  mkdir -p "${prefix}";
	./configure --prefix="${prefix}";
  make && make check && make install;
}

taskinfo jsoncc "Compile json checker source";
tasks.jsoncc() {
	executable.validate gcc;
	local exename="jsoncheck";
	"${executables[gcc]}" etc/json-checker/*.c etc/json-checker/*.h \
    -o "target/$exename" \
		|| console quit 1 -- "could not compile json-checker source";
}

taskinfo boilerplate "Install the boilerplate.sh file";
tasks.boilerplate() {
  # remove the path added be bake(1)
  export PATH=${PATH#*:};
  local name="boilerplate.sh";
  local source="bin/${name}";
  local boilerplate=$( command -v "${name}" );
  if [ -n "${boilerplate}" ]; then
    console info -- "location is %s" "${boilerplate}";
    local cpopts="-f";
    $verbose && cpopts+="v";
    cp $cpopts "${source}" "${boilerplate}" \
      || console quit 1 -- "could not install %s" "${source}";
    console success "installed %s" "${boilerplate}";
  else
    console info "%s is not installed" "${name}";
    # TODO: show a select to choose the path to copy to
  fi
}
