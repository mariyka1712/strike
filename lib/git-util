#!/usr/bin/env bash

######################################################################
# 	git-util
#
#	Utilties for working with the git repositories.
######################################################################

GIT_REPOSITORY=".git";
GIT_IGNORE=".gitignore";

function init_git_log_file {
	#ensure we always have a log file for git commands
	if [ -z "$GIT_LOG_FILE" -a ! -z "$INSTALL_LOG_PATH" ]; then
		GIT_LOG_FILE="$INSTALL_LOG_PATH/git.log";
		if [ ! -e "$GIT_LOG_FILE" ]; then
			mkdirp "$INSTALL_LOG_PATH" > /dev/null;
			touch "$GIT_LOG_FILE";
		fi
	fi
}

function get_git_message_prefix {
	_result="[$program_name]";
}

function get_git_commit_message {
	local msg="$1";
	get_git_message_prefix;
	local prefix="$_result";
	local date=`date "+%d-%m-%Y %T"`;
	local message="$prefix [$date]";
	#add a custom message where necessary
	if [ ! -z "$msg" ]; then
		message="$message $msg";
	fi
	_result="$message";
}

function git_ignore {
	local path="$1";
	local ignores=("${@:2}");
	if [ -d "$path" -a -w "$path" ]; then
		local file="$path/$GIT_IGNORE";
		echo "" > "$file";
		info "writing %s to %s" "$GIT_IGNORE" "$path";
		local contents="";
		for i in "${ignores[@]}"
			do
				echo "$i" >> "$file";
		done
	fi
}

function git_repository {
	local path="$1";
	if [ -e "$path" ]; then
		expand_path "$path";
		if [ -d "$_result" -a -d "$_result/$GIT_REPOSITORY" ]; then
			return 0;
		fi
	fi
	return 1;
}

function git_status {
	init_git_log_file;
	local path="$1";
	expand_path "$path";
	git_repository "$_result";
	#only status if already a repo
	if [ $? -eq 0 ]; then
		info "git status %s" "$path";
		cdir "$path" > /dev/null;
		git status >> "$GIT_LOG_FILE" 2>&1;
		return $?;
	else
		warn "%s is not a git repository" "$path";
		return 1;
	fi
}

function git_init {
	init_git_log_file;
	local path="$1";
	expand_path "$path";
	git_repository "$_result";
	#only initialize if not already a repo
	if [ $? -ne 0 ]; then
		info "git init %s" "$path";
		git init "$path" >> "$GIT_LOG_FILE" 2>&1;
		return $?;
	else
		warn "%s is already initialized as a git repository" "$path";
		return 1;
	fi
}

function git_add {
	init_git_log_file;
	local path="$1";
	expand_path "$path";
	git_repository "$_result";
	#only add on valid repo
	if [ $? -eq 0 ]; then
		info "git add %s" "$path";
		cdir "$path" > /dev/null;
		git add "." >> "$GIT_LOG_FILE" 2>&1;
		return $?;
	else
		warn "%s is not a git repository" "$path";
		return 1;
	fi
}

function git_commit {
	init_git_log_file;
	local path="$1";
	local msg="$2";
	get_git_commit_message "$msg";
	msg="$_result";
	expand_path "$path";
	git_repository "$_result";
	#only commit if already a repo
	if [ $? -eq 0 ]; then
		info "git commit %s" "$msg";
		cdir "$path" > /dev/null;
		git commit -a -m "$msg" >> "$GIT_LOG_FILE" 2>&1;
		return $?;
	else
		warn "%s is not a git repository" "$path";
		return 1;
	fi
}

function git_clone {
	init_git_log_file;
	local repo="$1";
	info "cloning %s" "$repo";
	git clone --recursive "$repo" >> "$GIT_LOG_FILE" 2>&1;
	return $?;
}

function git_pull_url {
	init_git_log_file;
	local url="$1";
	info "git pull %s" "$url";
	git pull "$url" >> "$GIT_LOG_FILE" 2>&1;
	return $?;
}

function git_pull {
	init_git_log_file;
	local repo="$1";
	local remote="$2";
	local ref="$3";
	
	if [ -z "$remote" ]; then
		remote="origin";
	fi
	
	if [ -z "$ref" ]; then
		ref="master";
	fi
	
	cdir "$repo" && info "git pull %s %s" "$remote" "$ref";
	if [ $? -eq 0 ]; then
		git pull "$remote" "$ref" >> "$GIT_LOG_FILE" 2>&1;
		if [ $? -ne 0 ]; then
			warn "could not pull %s from %s at %s" "$ref" "$remote" "$repo";
		fi
	else
		warn "could not cd for pull %s from %s at %s" "$ref" "$remote" "$repo";
	fi
	return $?;
}

function git_ls_remote_tags {
	local repo="$1";
	info "git ls-remote --tags %s" "$repo";
 	_result=`git ls-remote --tags "$repo"`;
}

function git_find_tag {
	local tag="$1";
	local data="$2";
	for t in $data
		do
			if [ "$t" == "refs/tags/$tag" ]
				then
					return 0;
			fi
	done
	return 1;
}

function get_current_branch_name {
	local repo="$1";
	cdir "$repo" > /dev/null;
	local branch_name=$(git symbolic-ref -q HEAD);
	branch_name=${branch_name##refs/heads/};
	branch_name=${branch_name:-HEAD};
	_result="$branch_name";
}

function git_submodule_update {
	git submodule update;
}

function git_submodule_add {
	init_git_log_file;
	local repo="$1";
	local subrepo="$2";
	local path="$3";
	expand_path "$repo";
	git_repository "$_result";
	#only add the submodule if already a repo
	if [ $? -eq 0 ]; then
		cdir "$repo" > /dev/null;
		if [ $? -eq 0 ]; then
			info "git submodule add %s -> %s" "'$subrepo'" "'$path'";
			git submodule add "$subrepo" "$path" >> "$GIT_LOG_FILE" 2>&1;
			#aggressively add additional sub-modules when adding a sub module
			git submodule update --init --recursive >> "$GIT_LOG_FILE" 2>&1;
		fi
		return $?;
	else
		warn "%s is not a git repository" "$repo";
		return 1;
	fi
}

function git_switch_origin {
	init_git_log_file;	
	local repo="$1";
	local origin="$2";
	
	cdir "$repo" > /dev/null;
	
	#remove the old origin
	git remote rm origin >> "$GIT_LOG_FILE" 2>&1;
	
	#add the new origin
	git remote add origin "$origin" >> "$GIT_LOG_FILE" 2>&1;	
}