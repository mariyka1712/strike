######################################################################
# 	shared
#
#	Includes core modules.
######################################################################

#set -o pipefail;

__check_version__() {
	local tshell="bash";
	local required=( 4 2 );
	local major="${BASH_VERSINFO[0]}";
	local minor="${BASH_VERSINFO[1]}";
	if { test "$major" -lt "${required[0]}"; } \
		|| { test "$major" -eq "${required[0]}" && test "$minor" -lt "${required[1]}"; }; then
		local version="${BASH_VERSINFO[0]}.${BASH_VERSINFO[1]}.${BASH_VERSINFO[2]}";
		printf "$tshell >= ${required[0]}.${required[1]} is required, got %s\n" "$version";
		exit 1;
	fi
}

__initialize__() {
	__check_version__;
	
	local dir=`dirname "${BASH_SOURCE[0]}"`;

	# global variable declarations
	source "${dir}/modules/globals";
	
	# we need these modules before we include require(3)
	source "${dir}/modules/variable";
	source "${dir}/modules/string";	
	source "${dir}/modules/method";
	source "${dir}/modules/sprintf";	
	source "${dir}/modules/console";
	
	source "${dir}/modules/array";
	source "${dir}/modules/fs";
	
	#NOTE: directories must be configured prior to including require(3)
	# configure program directories
	local dir_root="$exedir";
	local pdir="$exedir";
	fs.path.expand "$pdir";
	pdir="$_result";
	process_dirs[owd]="$PWD";
	process_dirs[bin]="$pdir";
	# cater for executables located in the project root
	if [[ "$exedir" =~ /bin$ ]]; then
		dir_root=`dirname "$exedir"`;
	else
		process_dirs[bin]="${dir_root}/bin";
	fi
	process_dirs[root]="${dir_root}";
	process_dirs[lib]="${dir_root}/lib";
	process_dirs[man]="${dir_root}/man";
	process_dirs[modules]="${dir_root}/lib/modules";
	process_dirs[test]="${dir_root}/test";
	process_dirs[target]="${dir_root}/target";
	process_dirs[package]="${dir_root}/package.json";
	process_dirs[version]="${dir_root}/version";
	process_dirs[semver]="${dir_root}/semver.json";

	# configure library directories	
	fs.path.expand "$dir";
	dir="$_result";
	dir_root=`dirname "$dir"`;
	library_dirs[root]="${dir_root}";
	library_dirs[bin]="${dir_root}/bin";
	library_dirs[lib]="$dir";
	library_dirs[man]="${dir_root}/man";
	library_dirs[modules]="${dir}/modules";
	library_dirs[test]="${dir_root}/test";
	library_dirs[target]="${dir_root}/target";
	library_dirs[package]="${dir_root}/package.json";
	library_dirs[version]="${dir_root}/version";
	library_dirs[semver]="${dir_root}/semver.json";

	# main module loader and require(3) definition
	source "${dir}/modules/require";

	# manually register these modules
	__require_register "variable" "${dir}/modules/variable";
	__require_register "string" "${dir}/modules/string";
	__require_register "method" "${dir}/modules/method";
	__require_register "console" "${dir}/modules/sprintf";
	__require_register "console" "${dir}/modules/console";
	__require_register "array" "${dir}/modules/array";
	__require_register "require" "${dir}/modules/require";
	__require_register "fs" "${dir}/modules/fs";
	
	# require(3) the remaining core modules
	# the order here is *very* important
	
	# TODO: move these to `source`!
	require.once 'delegate';
	require.once 'executable';
	require.once 'system';
	require.once 'process';
	
	# add delegates for modules that were not required
	# must be done after the delegate module is available
	
	# require.delegate "variable";
	# require.delegate "method";
	# require.delegate "console";
	# require.delegate "array";

	# TODO: remove these dependencies
	# source "${dir}/constants";
	source "${dir}/messages";

	#TODO: CHECK THESE AS THE REMOVAL WILL HAVE BROKEN SOME OTHER EXTERNAL PROGRAMS
	#source "${dir}/archive-util";
}

__initialize__ "$@";