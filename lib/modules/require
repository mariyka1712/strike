: <<'ronn:markdown'
require(3) -- module loader
=============================================

## SYNOPSIS

Module loader for strike(7).

## DESCRIPTION

Loads modules by name or filesystem path and adds delegate(3) functionality to modules once loaded.

## USAGE

	require 'module';
	require './module';
	require '../path/to/module';
	require '/path/to/module';

## BUGS

**require** is written in bash and depends upon `bash` >= 4.

## COPYRIGHT

**require** is copyright (c) 2012 muji <http://xpm.io>

## SEE ALSO

delegate(3)
ronn:markdown

# TODO: add require.unload method to call method.remove on all declared methods

function require {
	force=${force:-false};
	local name="${1:-}";
	if [ ! -z "$name" ]; then
		__require_load "$name";
	fi
}

# forces a require even if the module is already loaded
function require.load {
	local force=true;
	require "$1";
}

function require.list {
	local path name;
	for path in "${!module_paths[@]}"
		do
			name="${module_paths[$path]}";
			info "[module] %s < %s" "$name" "$path";
	done
}

function require.methods {
	_result="";
	require "$1";
	local match="${2:-}";
	if [ ! -z "$2" ]; then
		_result=$( method.list | egrep "$match" );
	fi
}

function require.dirs {
	__require_dirs;
	local searchpaths=( $_result ) d;
	for d in "${searchpaths[@]}"
		do
			console.log "$d";
	done
}

# declares a delegate method
function require.delegate {
	local name="${1:-}";
	if [ ! -z "$name" ]; then
		if ! method.exists? "$name"; then
			#warn "loaded module %s does not declare a method named %s" "$name" "$name";
			if method.exists? "delegate"; then
				eval "$name(){ 
					delegate "$1" \$*;
				}";
			fi
		fi
	fi
}

# determines whether a module exists by name or path
function require.exists? {
	local module="${1:-}";
	if [ ! -z "$module" ]; then
		if [[ "$module" =~ ^(\.+)?/ ]]; then
			require.path.exists? "$module";
			return $?;
		else
			# echo "testing for module by name : $module : ${module_paths[*]}";
			require.name.exists? "$module";
			return $?;
		fi
	fi
	return 1;
}

# determines whether a module exists by name
function require.name.exists? {
	if string.contains? "${module_paths[*]}" "$1"; then
		return 0;
	fi
	return 1;
}

# determines whether a module exists by absolute path
function require.path.exists? {
	if string.contains? "${!module_paths[*]}" "$1"; then
		return 0;
	fi
	return 1;
}

# removes a module definition by name
function require.name.unload! {
	local module="${1:-}";
	if [ -n "$module" ]; then
		local paths=( "${!module_paths[@]}" );
		local path name;
		for path in ${paths[@]}
			do
				name="${module_paths["$path"]}";
				if [ "$name" == "$module" ]; then
					local methods=( ${module_methods["$path"]} );
					method.remove "${methods[@]}";
					unset module_paths["$path"];
				fi
		done
	fi
}

######################################################################
#
#	PRIVATE METHODS
#
######################################################################

function __require_register {
	local name="${1:-}";
	local path="${2:-}";
	# strip any extension
	# name=${name%%.*};
	local methods;
	local private;
	if [ ! -z "$name" ]; then
		
		# echo "registering module: $name";
		
		# get method definitions but don't quit if none are defined
		set +o errexit;
		methods=( $( method.list | egrep "^${name}" ) );
		private=( $( method.list | egrep "^__${name}" ) );
		set -o errexit;
		
		# echo "got module private methods: ${private[@]:-}";
		
		module_methods["$path"]="${methods[@]:-}";
		module_private_methods["$path"]="${private[@]:-}";
	
		if [ ! -z "$path" ]; then
			module_paths["$path"]="$name";
		fi
	fi
}

function __require_source {
	local abs="$1";
	# only require if path does not match an already loaded module
	# or if the module is being loaded forcefully
	if ! require.path.exists? "$abs" || $force; then
		source "$abs";
	else
		console.warn "skipping require on loaded module %s" "$abs";
	fi
}

# find the caller source directory
function __require_find_caller_source_dir {
	local self=`dirname $BASH_SOURCE`;
	local index=1;
	local stack=( $( caller $index ) );
	local sourcedir=`dirname "${stack[2]}"`;
	unset _result;
	while [ "$sourcedir" == "$self" ]
		do
			stack=( $( caller $index ) );
			sourcedir=`dirname "${stack[2]}"`;
			if [ "$sourcedir" != "$self" ]; then
				_result="$sourcedir";
				break;
			fi
			((index++));
	done
}

function __require_load {
	local name="${1:-}";
	
	local abspath=$(cd ${BASH_SOURCE[0]%/*} && echo $PWD);
	
	#echo "got load abs path: $abspath";
	
	local abs;
	local loaded=0;
	local declared;	
	if [ ! -z "$name" ]; then
		
		# TODO: handle ./ and ../../ paths
		
		# got a relative path, load from a relative path
		if [[ "$name" =~ ^\.+ ]]; then
			__require_find_caller_source_dir;
			sourcefile="$_result";
			sourcefile="${sourcefile}/${name}";
			fs.path.expand "$sourcefile";
			abs="$_result";
			name=`basename $abs`;
			__require_source "$abs";
			loaded=1;
			#echo "load relative require $name : $abs";
		# got an absolute path try to load from absolute path			
		elif [[ "$name" =~ ^/ ]]; then
			abs="$name";
			name=`basename $abs`;
			__require_source "$abs";
			loaded=1;
		# searching by name
		else
			__require_dirs;
			local searchpaths=( $_result );
			for f in "${searchpaths[@]}"
				do
					#fs.path.expand "$f" > /dev/null;
					#f="$_result";
					abs="${f}/${name}";
				
					if [ -f "$abs" ] && [ -r "$abs" ]; then
						#method_start_diff;
						name=`basename $abs`;
						__require_source "$abs";
						#method_end_diff;
						#declared=( "$_result[@]" );
						#echo "got declared methods : ${declared[@]}";
						loaded=1;
						break;
					fi
			done
		fi
		
		if [ $loaded -eq 0 ]; then
			quit 1 "failed to load module %s" "$name";
		fi
		
		# echo "testing for delegate method : $name";
		
		# only delegate and call constructor if the 
		# module was required
		if ! require.path.exists? "$abs" || $force; then
			require.delegate "$name";
		
			# register the module
			__require_register "$name" "$abs";
		
			local constructor="${name}.initialize";
			# invoke a contructor if present
			if method.exists? "$constructor"; then
				"$constructor";
			fi
		fi
	fi
}

function __require_dirs {
	local exemodules="${program_dirs[modules]}";
	local libmodules="${library_dirs[modules]}";
	local searchpaths=(
		"${exemodules}"
		"${libmodules}"
	);
	_result="${searchpaths[@]}";
}

#require 'couchdb';
#couchdb "auth" "https://ffsys.cloudant.com" "hosts";
#url_query_string 'include_docs=true' 'reduce=false';
#echo "got query string: $_result";
#couchdb_view "views" "users" "$_result";

#echo "got content type: $rest_header_content_type"

#for opt in ${!rest_response_*}
#	do
#		eval value="$"$opt;
#		echo "got rest response opt : $opt : $value";
#done

#couchdb "info";
#couchdb "head" "cyberfunk" && couchdb_print;
#couchdb "get" "cyberfunk-abc";
#echo "got rev: ${json_rev}";
#couchdb "put_file" "package" "/Users/cyberfunk/git/hosts/package.json";
#couchdb "put_data" "test" '{ "test": "value" }' && couchdb_print;
#module_list;