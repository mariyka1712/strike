# TODO: move to global variables?
declare -gx process_strict="";

declare -g process_debug="";

declare -g process_test="";

# TODO: add the process.use "debug"
# to force console.error to always throw
# a stack trace

# OS X signals
# No    Name         Default Action       Description
# 1     SIGHUP       terminate process    terminal line hangup
# 2     SIGINT       terminate process    interrupt program
# 3     SIGQUIT      create core image    quit program
# 4     SIGILL       create core image    illegal instruction
# 5     SIGTRAP      create core image    trace trap
# 6     SIGABRT      create core image    abort program (formerly SIGIOT)
# 7     SIGEMT       create core image    emulate instruction executed
# 8     SIGFPE       create core image    floating-point exception
# 9     SIGKILL      terminate process    kill program
# 10    SIGBUS       create core image    bus error
# 11    SIGSEGV      create core image    segmentation violation
# 12    SIGSYS       create core image    non-existent system call invoked
# 13    SIGPIPE      terminate process    write on a pipe with no reader
# 14    SIGALRM      terminate process    real-time timer expired
# 15    SIGTERM      terminate process    software termination signal
# 16    SIGURG       discard signal       urgent condition present on socket
# 17    SIGSTOP      stop process         stop (cannot be caught or ignored)
# 18    SIGTSTP      stop process         stop signal generated from keyboard
# 19    SIGCONT      discard signal       continue after stop
# 20    SIGCHLD      discard signal       child status has changed
# 21    SIGTTIN      stop process         background read attempted from control terminal
# 22    SIGTTOU      stop process         background write attempted to control terminal
# 23    SIGIO        discard signal       I/O is possible on a descriptor (see fcntl(2))
# 24    SIGXCPU      terminate process    cpu time limit exceeded (see setrlimit(2))
# 25    SIGXFSZ      terminate process    file size limit exceeded (see setrlimit(2))
# 26    SIGVTALRM    terminate process    virtual time alarm (see setitimer(2))
# 27    SIGPROF      terminate process    profiling timer alarm (see setitimer(2))
# 28    SIGWINCH     discard signal       Window size change
# 29    SIGINFO      discard signal       status request from keyboard
# 30    SIGUSR1      terminate process    User defined signal 1
# 31    SIGUSR2      terminate process    User defined signal 2

declare -ag process_signals;
process_signals=(
	hup
	int
	quit
	ill
	trap
	abrt
	emt
	fpe
	kill
	bus
	segv
	sys
	pipe
	alrm
	term
	urg
	stop
	tstp
	cont
	chld
	ttin
	ttou
	io
	xcpu
	xfsz
	vtalrm
	prof
	winch
	info
	usr1
	usr2
);

# bash specific signals
process_signals+=( debug err exit );

declare -Ag process_signal_callbacks;

declare -Ag process_time;
process_time[start]=`date +%s`;

# store a boolean of whether we are looping as a daemon
declare -g process_loop=false;

function process.initialize {
	local signal;
	for signal in ${process_signals[@]}
		do
			# initialize registry of signal
			# callback methods
			process_signal_callbacks[$signal]="";
	done
}

function process.use {
	while [ $# -gt 0 ];
		do
			local val="${1:-}";
			if [ "$val" == "strict" ]; then
				process_strict="on";
				set -o errtrace;
				set -o errexit;
				set -o nounset;
			elif [ "$val" == "debug" ]; then
				process_debug="on";
			elif [ "$val" == "test" ]; then
				process_test="on";
			fi
			shift;
	done
}

# retrieves the process uptime in seconds
function process.uptime {
	local start=${process_time[start]};
	local now=`date +%s`;
	local uptime=$(( $now - $start ));
	_result="$uptime";
}

# determine if we are running in debug mode
function process.debug? {
	test -n "$process_debug";
}

# determine if we are running in strict mode
function process.strict? {
	test -n "$process_strict";
}

# determine if we are running in test mode
function process.test? {
	test -n "$process_test";
}

# switch off debug mode
function process.debug! {
	process_debug="";
}

# switch off strict mode
function process.strict! {
	process_strict="";
	set +o errtrace;
	set +o errexit;
	set +o nounset;
}

# switch off test mode
function process.test! {
	process_test="";
}

# TODO: add PID file support
# print the process id
function process.pid {
	echo -ne "$$";
}

# add a callback method for signal(s)
function process.signal.on {
	local method="${1:-process.trap}";
	local signal;
	if ! method.exists? "$method"; then
		console.warn "$FUNCNAME cannot add non-existent callback method %s" "$method";
	else
		echo "process.signal.on : $method";
	fi
}

# remove a callback method for signal(s)
function process.signal.off {
	local method="${1:-process.trap}";	
	local signal;	
	echo "process.signal.off : $method";
}

# print callbacks for signal(s)
function process.signal.print {
	while [ $# -gt 0 ];
		do
			signal="$1";
			echo "listing signal $signal";
			shift;
	done
}

# switch on a trap
function process.on {
	local signal;
	while [ $# -gt 0 ];
		do
			signal="$1";
			trap "__process.trap $? $signal" $signal;
			shift;
	done
}

# switch off a trap
function process.off {
	local signal;
	while [ $# -gt 0 ];
		do
			signal="$1";
			trap - $signal;
			shift;
	done
}

function process.daemon.start! {
	local method="${1:-process.loop}";
	if method.exists? "$method"; then
		process_loop=true;
		__process.daemonize "$method";
	else
		console.warn "attempt to daemonize with no callback method %s" "$method";
	fi
}

function process.daemon.stop! {
	# switch the loop off
	process_loop=false;
}

# TODO: add lock file support for singleton processes

# responds to trap signals
function __process.trap {
	# exit code of last command
	local code="$1";
	
	# signal being processed
	local signal="$2";
	
	# switch off any daemon for these signals
	case "$signal" in
		exit ) process.daemon.stop! ;;
	esac
	
	# in test mode just output the signal name
	if process.test?; then
		echo -ne "$signal";
	else
		echo "$FUNCNAME got signal : $signal";
		#local lineno="$2";
		local data=( $( caller 1 ) );

		if [ ${#data[@]} -gt 0 ]; then
			echo "${data[@]}";
		fi

		echo "$FUNCNAME : $code : $1";
	fi
}

function __process.daemonize {
	local method="${1:-}";
	while $process_loop;
		do
			# invoke the daemon callback method
			if method.exists? "$method"; then
				"$method";
			# method may have been removed, stop!
			else
				process.daemon.stop!
			fi
	done
}