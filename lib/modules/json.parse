# global json document
declare -Ag json_doc;

function json.parse {
	
	# TODO: remove this?
	#set +o errexit;
	#set +o nounset;
	
	json.parse.clean;
	
	# the default delimiter for key values
	local delimiter=".";
	
	# unset json_doc;
	# declare -Agx json_doc;	
	
	#local key value;
	##local root_type;
	
	__json.start < <(__json.tokenize <&0);
	
	# while read;
	# 	do
	# 		echo "GOT LINE FROM INTERNAL PARSER ... ${#json_doc[@]}";
	# 		#break;
	# done < <( __json.tokenize <&0 >| >(__json.start) );	
	
	#echo "after loop : ${#json_doc[@]}";
	
	#declare -Agx json_data;
	#json_data[a]="b";
	
	#__json.tokenize <&0 >| >(__json.start);
	
	
	
	# run the process subsititution in this manner
	# to block until the parsing is complete
	# while read line;
	# 	do
	# 		# echo "line: $line";
	# 		
	# 		echo "GOT LINE FROM INTERNAL PARSER ... ";
	# 		
	# 		#echo "got root type: $json_root_type";
	# 		
	# 		# available outside the loop
	# 		# because it does NOT run in a subshell
	# 		local IFS="=";
	# 		while read key value
	# 			do
	# 				#strip out the double quotes from string values
	# 				#key=$( sed "s/^\([\"']\)\(.*\)\1\$/\2/g" <<< "$key" );
	# 				#value=$( sed "s/^\([\"']\)\(.*\)\1\$/\2/g" <<< "$value" );
	# 				#key=${key##json_};
	# 				
	# 				# if [ "$key" == "root_type" ]; then
	# 				# 	
	# 				# 	root_type="$value";
	# 				# 	continue;
	# 				# fi
	# 				
	# 				#echo "got root type: $root_type";
	# 				
	# 				# skip any array/object definitions
	# 				# as child elements should already by parsed
	# 				if [[ "$value" =~ ^(\[|{) ]]; then
	# 					continue;
	# 				fi
	# 				
	# 				# echo "got key: $key";
	# 				# echo "got value: $value";
	# 				
	# 				if [ ! -z "$key" ]; then
	# 					# store the value in the json_doc associative array
	# 					json_doc["$key"]="$value";
	# 				fi
	# 		done <<< "$line";
	# done < <( __json.tokenize <&0 >| >(__json.start) );
}

function json.parse.clean {
	# local key;
	# # clean any existing data
	# for key in "${!json_doc[@]}";
	# 	do
	# 		echo "unset key is: $key";
	# 		unset json_doc[$key];
	# done
	
	unset json_doc;
	declare -Ag json_doc;
}

######################################################################
#
#	PRIVATE METHODS
#
######################################################################

function __json.tokenize {
	local ESCAPE='(\\[^u[:cntrl:]]|\\u[0-9a-fA-F]{4})'
	local CHAR='[^[:cntrl:]"\\]'
	local STRING="\"$CHAR*($ESCAPE$CHAR*)*\""
	local NUMBER='-?(0|[1-9][0-9]*)([.][0-9]*)?([eE][+-]?[0-9]*)?'
	local KEYWORD='null|false|true'
	local SPACE='[[:space:]]+'
	egrep -ao "$STRING|$NUMBER|$KEYWORD|$SPACE|." --color=never | egrep -v "^$SPACE$"  # eat whitespace
}

function __json.start {
	local value token;
	read -r token;
	__json.parse.value;
	read -r token;
	case "$token" in
		'' ) ;;
		* ) __json.throw "EXPECTED EOF GOT $token" ;;
	esac
}

function __json.parse.value {

	# configure the key with a period '.' delimiter
	local key="${1:+${1}${delimiter}}";
	local jpath="${key}${2:-}";
	# strip quotes from token values
	token="${token#\"}";
	token="${token%\"}";
	#echo "k, v : ${jpath} = ${token}";
	case "$token" in
		'{' ) __json.parse.object "$jpath"; return 0; ;;
		'[' ) __json.parse.array  "$jpath"; return 0; ;;
		# At this point, the only valid single-character tokens are digits.
		#''|[^0-9]) __json.throw "EXPECTED value GOT ${token:-EOF}" ;;
		* ) value=${token} ;;
	esac

	# printf "[%s]\t%s\n" "$jpath" "$value";
	
	if [[ ! "$value" =~ /^{/ ]] && [[ ! "$value" =~ /^[/ ]]; then
		local key=${jpath};
		#local val=${value};
		#eval key=json_\$$key;
		#echo "got key: $key" >&2;
		#switch the commas for dot-style notation
		#key=${key//,/.};
		if [ "$key" != '$' ] && [ -n "$key" ]; then
			echo "using key: $key" >&2;
			echo "using value: $value" >&2;
			json_doc["$key"]="${value}";
			echo "got json data (${#json_doc[@]}) : '${!json_doc[@]}'" >&2;
		fi
	fi
}

function __json.parse.object {
	local key index=0;
	#local obj=''
	read -r token;
	case "$token" in
		'}' ) ;;
		* )
			while :
				do
					case "$token" in
						'"'*'"')
							key="$token";
							# strip quotes
							key="${key#\"}";
							key="${key%\"}";
							;;
						*) __json.throw "EXPECTED string GOT ${token:-EOF}" ;;
					esac
					read -r token;
					case "$token" in
						':') ;;
						*) __json.throw "EXPECTED : GOT ${token:-EOF}" ;;
					esac
					read -r token;
					__json.parse.value "$1" "$key"
					#obj="$obj$key:$value"
					read -r token;
					case "$token" in
						'}') break ;;
						',') : $((index++)); ;;
						*) __json.throw "EXPECTED , or } GOT ${token:-EOF}" ;;
					esac
					read -r token;
			done
		;;
	esac
	#value=`printf '{%s}' "$obj"`;
}

function __json.parse.array {
	local index=0;
	#local ary=''
	read -r token
	case "$token" in
		']' ) ;;
		* )
			while :
				do				
					__json.parse.value "$1" "$index";
					# let index=$index+1;
					#ary="$ary""$value";
					read -r token;
					case "$token" in
						']') break ;;
						',') : $((index++)); ;;
						#',') read -r token ;;
						*) __json.throw "EXPECTED , or ] GOT ${token:-EOF}" ;;
					esac
					read -r token;
					case "$token" in
						']') break ;;
					esac
			done
		;;
	esac
	#value=`printf '[%s]' "$ary"`;
}

function __json.throw {
	console.throw "$*";
	#exit 1;
}