#Black       0;30     Dark Gray     1;30
#Blue        0;34     Light Blue    1;34
#Green       0;32     Light Green   1;32
#Cyan        0;36     Light Cyan    1;36
#Red         0;31     Light Red     1;31
#Purple      0;35     Light Purple  1;35
#Brown       0;33     Yellow        1;33
#Light Gray  0;37     White         1;37

# The ANSI sequence: {ESC}[{attr};{bg};{256colors};{fg}m

# {ESC} or \033 represents the ANSI escape-sequence. {attr} represents the outputs attributes (properties such as blinking and bold text), {fg} is the # foreground color, {bg} is the background color, m means the sequence ends.

# NOTE: read -ep octal formatting example
# SEE: http://lists.gnu.org/archive/html/help-bash/2013-02/msg00007.html
# $'\001\033[1m\002ABC\001\033[0m\002'

# SEE: http://en.wikipedia.org/wiki/ANSI_escape_code
# SEE: http://misc.flogisoft.com/bash/tip_colors_and_formatting
# SEE: http://www.cplusplus.com/reference/cstdio/printf/

declare -Ag ansi;
ansi=(
	[terminator]="\033[0m"
	[start]="\033["
	[delimiter]=";"
	[end]="m"
	[bright.prefix]="bright"
	[foreground]="3"
	[background]="4"
	[colors]="black red green brown blue magenta cyan gray normal"
	[colors.black]="0"
	[colors.red]="1"
	[colors.green]="2"
	[colors.brown]="3"
	[colors.blue]="4"
	[colors.magenta]="5"
	[colors.cyan]="6"
	[colors.gray]="7"
	[colors.normal]="9"
	[attributes]="normal bright faint italic underline blink negative positive"
	[attr.normal]="0"
	[attr.bright]="1"
	[attr.faint]="2"
	[attr.italic]="3"
	[attr.underline]="4"
	[attr.blink]="5"
	[attr.negative]="7"
	[attr.strikethrough]="9"
	[attr.positive]="27"
	[octal.terminator]=$'\001\033[0m\002'
	[octal.start]=$'\001\033['
	[octal.end]=$'m\002'
	[emulators]="xterm xterm-color vt100 ansi"
	
	[block.start]="${strike_block_start:-[}"
	[block.end]="${strike_block_start:-]}"
)
readonly -A ansi;

# main sprintf entry point
sprintf() {
	# style terminator
	local terminator start end;
	# message prefix
	local prefix="";
	local suffix="";
	local messages=();
	local parsed="";
	
	if [ $# -eq 0 ]; then
		echo "sprintf: too few options" >&2;
		exit 2;
	fi
	
	# the style list
	declare -A styles;
	
	# message style names
	local color="normal";
	local background="";
	local attribute="";
	
	# variable name / declaration
	# used to assign result to a variable
	local varname="";
	local vartype="";
	
	# a command to execute to
	# modify or generate a prefix
	local prefix_command="";
	
	declare -A flags;
	flags[debug]=false;
	flags[readline]=false;
	flags[program]=false;
	flags[date]=false;
	flags[timestamp]=false;
	flags[message.prefix]=true;
	flags[ansi]=true;
	flags[color]=true;
	flags[newline]=true;
	flags[replace]=true;
	flags[replace.bold]=true;
	flags[prefix.bright]=true;
	flags[stderr]=false;
	
	local results=();
	
	# echo "sprintf got opts: $*"; 
	
	declare -A settings;
	local parameter_styles=();
	
	sprintf.options.parse "$@";
	
	# initialize styles
	sprintf.styles;
	
	if [ -n "${color}" ]; then
		sprintf.color.validate "${color}";
	fi
	if [ -n "${background}" ]; then
		sprintf.color.validate "${background}";
	fi

	# echo "after parse : $color";
	# echo "after parse : $background";
	# echo "after parse : $attribute";
	
	# main message color
	if [ -n "${color:-}" ]; then
		settings[color]="${styles[$color]}";
	else
		settings[color]="";
	fi
	
	local has_custom_message_color=false;
	if [ -n "${color}" ]; then
		if [ -n "${background}" ] || [ -n "${attribute}" ]; then
			has_custom_message_color=true;
			sprintf.color.update;
		fi
	fi
	
	if [ "${#messages[@]}" -eq 0 ]; then
		echo "sprintf: no message supplied" >&2;
		exit 2;
	fi
	
	local message="${messages[0]:-}";
	local original="${message}";
	if [ -n "${suffix}" ]; then
		message="${message} ${suffix}";
	fi
	messages[0]="${message}";
	
	local replacements=( "${messages[@]:1}" );
	
	local emulators=( ${ansi[emulators]} );
	# switch off ansi escapes for non-tty
	if ! ${flags[stderr]} && [ ! -t 1 ]; then
		sprintf.noansi;
	elif ${flags[stderr]} && [ ! -t 2 ]; then
		sprintf.noansi;
	elif ! array.contains? "$TERM" "${emulators[@]}"; then
		sprintf.noansi;
	elif ${console_no_color}; then
		sprintf.noansi;
	fi
	
	sprintf.main;
}

# wrap a parameter in the standard
# block start and end characters
sprintf.block() {
	echo "${ansi[block.start]}${1:-}${ansi[block.end]}";
}

## INTERNAL

# main 
sprintf.main() {
	if ${flags[replace]}; then
		sprintf.replace;
	fi
	sprintf.output;
}

# register a custom parameter style
sprintf.parameter.style() {
	local index=0;
	local option="$1";
	local value="$2";
	local param_type="$3";
	local regexp="([0-9])$";
	#echo "$option : $value : $param_type";
	if [[ "$option" =~ ${regexp} ]]; then
		index="${BASH_REMATCH[0]}";
		settings["${param_type}.${index}"]="$value";
		parameter_styles["${index}"]=true;
	fi
}

# updates the color to include
# attribute / background information
sprintf.color.update() {
	local key="${1:-color}";
	local fgname="${2:-$color}";
	local bgname="${3:-$background}";
	local attrname="${4:-$attribute}";
	
	# echo "UPDATE: $key : $fgname : $bgname: $attrname";
	
	local fgindex="${ansi[colors.${fgname}]:-}";
	local bgindex="${ansi[colors.${bgname}]:-}";
	
	local fgvalue="${ansi[foreground]}${fgindex}";
	local bgvalue="${ansi[background]}${bgindex}";
	local attrvalue="${ansi[attr.${attrname}]:-}";
	
	local updated="${start}";
	if [ -n "${attrname:-}" ]; then
		updated="${updated}${attrvalue}";
	fi
	
	if [ -n "${bgname:-}" ]; then
		if [ -n "${attrname:-}" ]; then
			updated="${updated}${ansi[delimiter]}";
		fi
		updated="${updated}${bgvalue}";
	fi
	if [ -n "${fgname:-}" ]; then
		if [ -n "${bgname:-}" ] || [ -n "${attrname:-}" ]; then
			updated="${updated}${ansi[delimiter]}";
		fi
		updated="${updated}${fgvalue}";
	fi
	updated="${updated}${end}";
	# echo "current : ${settings[$key]}";
	# echo "$FUNCNAME : $fgname : $bgname : $attrname : $fgindex : $bgindex : $attrvalue";
	# echo "$FUNCNAME : $updated";
	settings[$key]="${updated}";
}

# initialize the style list
sprintf.styles() {
	local style;
	
	# standard escape sequences
	if ! ${flags[readline]}; then
		terminator="${ansi[terminator]}";
		start="${ansi[start]}";
		end="${ansi[end]}";
		
		sprintf.styles.attributes;
		sprintf.styles.standard;
		sprintf.styles.standard bright;
	# handle read -ep octal formatting
	else
		terminator="${ansi[octal.terminator]}";
		start="${ansi[octal.start]}";
		end="${ansi[octal.end]}";

		sprintf.styles.attributes;
		sprintf.styles.standard;
		sprintf.styles.standard bright;
	fi
	
	if [ ${#parameter_styles[@]} -gt 0 ]; then
		# echo "GOT CUSTOM PARAMETER STYLES ... ";
		local ind key;
		for ind in "${!parameter_styles[@]}"
			do
				key="param.${ind}";
				#echo "got parameter style index: $ind : $key";
				sprintf.color.update "$key" \
					"${settings[fg.${ind}]:-}" \
					"${settings[bg.${ind}]:-}" \
					"${settings[attr.${ind}]:-}";
					
				#echo "got parsed value : ${settings[$key]}";
		done
	fi
}

# set up attribute styles
sprintf.styles.attributes() {
	local IFS=' ';
	local cnames=( ${ansi[attributes]} );
	unset IFS;
	local i length="${#cnames[@]}";
	local prefix="";
	local cname attribute;
	for((i =0;i < $length;i++))
		do
			cname="${cnames[$i]}";
			attribute="$cname";
			sprintf.styles.prefix true;
			styles[$cname]="${prefix}";
	done
}

# set up standard styles
sprintf.styles.standard() {
	local IFS=' ';	
	local cnames=( ${ansi[colors]} );
	unset IFS;	
	local i length="${#cnames[@]}";
	local attribute=${1:-normal};
	local foreground=true;
	local prefix="";
	local cprefix="";
	local cname;
	for((i =0;i < $length;i++))
		do
			cname="${cnames[$i]}";
			sprintf.styles.prefix;
			if [ "$attribute" == "${ansi[bright.prefix]}" ]; then
				cname="${ansi[bright.prefix]}-${cname}";
			fi
			if $foreground; then
				cprefix="${ansi[foreground]}${i}";
			else
				cprefix="${ansi[background]}${i}";
			fi
			prefix="${prefix}${cprefix}";
			prefix="${prefix}${end}";
			styles[$cname]="${prefix}";
	done
}

sprintf.styles.prefix() {
	local terminate="${1:-false}";
	# echo "using attribute: $attribute";	
	prefix="${start}${ansi[attr.${attribute}]}";
	if ! $terminate; then
		prefix="${prefix}${ansi[delimiter]}";
	else
		prefix="${prefix}${end}";
	fi
}

# validate a color name
sprintf.color.validate() {
	local val="$1";
	if ! array.contains? "${val}" "${!styles[@]}"; then
		echo "sprintf: invalid color ${val}";
		exit 2;
	fi
}

# switch off ANSI escape sequences completely
sprintf.noansi() {
	flags[ansi]=false;
	flags[color]=false;
	flags[replace.bold]=false;
	flags[prefix.bright]=false;
}

# print parsed result
sprintf.output() {
	local opts="-e";
	if ! ${flags[newline]}; then
		opts="${opts}n";
	fi

	# export the value as a variable
	if [ -n "${varname}" ]; then
		variable.set "${varname}" "$parsed" "${vartype}";
		return 0;
	fi
	
	if ${flags[readline]}; then
		return 0;
	fi
	
	if ${flags[debug]}; then
		opts="";
	fi
	
	# echo "send output with parsed... ${parsed}";
	
	if ! ${flags[stderr]}; then
		printf -- "${results[@]}";
		if ${flags[newline]}; then
			printf '\n';
		fi
	else
		printf -- "${results[@]}" >&2;
		if ${flags[newline]}; then
			printf '\n' >&2;
		fi
	fi
	
	# if ! ${flags[stderr]}; then
	# 	echo $opts "$parsed";
	# else
	# 	echo $opts "$parsed" >&2;
	# fi
}

# %[flags][width][.precision][length]specifier 
# 
# Where the specifier character at the end is the most significant component, since it defines the type and the interpretation of its corresponding argument:
# specifier	Output	Example
# d or i	Signed decimal integer	392
# u	Unsigned decimal integer	7235
# o	Unsigned octal	610
# x	Unsigned hexadecimal integer	7fa
# X	Unsigned hexadecimal integer (uppercase)	7FA
# f	Decimal floating point, lowercase	392.65
# F	Decimal floating point, uppercase	392.65
# e	Scientific notation (mantissa/exponent), lowercase	3.9265e+2
# E	Scientific notation (mantissa/exponent), uppercase	3.9265E+2
# g	Use the shortest representation: %e or %f	392.65
# G	Use the shortest representation: %E or %F	392.65
# a	Hexadecimal floating point, lowercase	-0xc.90fep-2
# A	Hexadecimal floating point, uppercase	-0XC.90FEP-2
# c	Character	a
# s	String of characters	sample
# p	Pointer address	b8000000
# n	Nothing printed.
# The corresponding argument must be a pointer to a signed int.
# The number of characters written so far is stored in the pointed location.	
# %	A % followed by another % character will write a single % to the stream.	%

# 
sprintf.format() {
	# echo "$FUNCNAME message: '$message'";
	if [ ${#replacements[@]} -gt 0 ]; then
		
		local formatted="${message:-}";
		local parameters=( "${replacements[@]:-}" );
		local replaced="";
		local match="";
		
		# printf: %[flags][width][.precision][length]specifier
		
		# NOTE: %p for a pointer address is not supported
		
		# 1. ([^%]+)* == possible start value before specifier
		# 2. %{1,} == match format string start
		# 3. [#0 +-]? == optional flags
		# 4. ([0-9]+|\*)? == optional width
		# 5. (\.([0-9]+|\*))? == optional precision
		# 6. (hh|h|l|ll|j|z|t|L)? == optional length
		# 7. ([%fFeEgGaAdiuoxXscpnqb]){1,0}) == required specifier
		# 8. ([^%]+)* == remaining part of the message until next match
		
		local regexp="([^%]+)*(%{1,1}[#0 +-]?([0-9]+|\*)?(\.([0-9]+|\*))?(hh|h|l|ll|j|z|t|L)?([%fFeEgGaAdiuoxXscnqb]){1,})([^%]+)*";
		local index=0;
		local format;
		local specifier;
		local start;
		local remainder;
		local whitespace="^[ 	]$";
		
		#echo "testing on '${formatted}'";
		
		# if [ "$formatted" == "%%" ]; then
		# 	output="%";
		# else
			while [[ "$formatted" =~ $regexp ]];
				do
					remainder="";
					#echo "got match count : ${#BASH_REMATCH[*]}";
					#echo "got match keys : ${!BASH_REMATCH[@]}";
					#echo "got match values : ${BASH_REMATCH[@]}";
					
					match="${BASH_REMATCH[0]}";
					start="${BASH_REMATCH[1]:-}";
					format="${BASH_REMATCH[2]}";
					specifier="${BASH_REMATCH[7]:-}";	
					remainder="${BASH_REMATCH[8]:-}";
					value="${parameters[$index]:-}";
					
					: $((count[specifiers]++));
					
					#echo "got format: ${format}";
					# echo "got specifier: $specifier";
					
					trailing[$index]="";
				
					# got a parameter for the match
					if [ -n "${value}" ]; then
						
						: $((count[matches]++));
						
						output="${output}${start}%b${format}%b";
						: $((count[injected]+=2));						
						
						if [ -n "${remainder}" ]; then
							trailing[$index]=true;
							if [ -n "$color" ]; then
								output="${output}%b${remainder}";
								: $((count[injected]+=1));
							else
								output="${output}${remainder}";
							fi
						fi
					# no parameter for the match, this could output a warning?
					else
						# echo "non-parameter match... $specifier"
						output="${output}${match}";
					fi
					
					# update the formatted string
					# to remove the matching part
					formatted="${formatted#$match}";
					
					: $((index++));					
					
					if [ $index -gt ${#replacements[@]} ]; then
						break;
					fi
			done
		
			# format string is invalid
			if [ -z "$output" ]; then
				output="${message}";
			fi
		
		# fi
	else
		output="${message:-}";
	fi
}

#
# sprintf.param.append() {
# 	local style="$1";
# 	local terminator="$2";
# 	params+=( "$style" );
# 	params+=( "$terminator" );
# }

sprintf.colour.start() {	
	if [ ${#params[@]} -gt 0 ]; then
		if [ -n "$color" ]; then
			#echo "add overall message color ... for no replacements!!!"
			message="%b${message}";
			: $((count[injected]+=1));	
			params=( "${settings[color]}" "${params[@]}" );
		fi
		results=( "${message}" "${params[@]}" );		
	else
		if [ -n "$color" ]; then
			#echo "add overall message color ... for no replacements!!!"
			message="%b${message}";
			: $((count[injected]+=1));	
			params=( "${settings[color]}" );
		fi
		results=( "${message}" );
	fi
}

# performs printf replacement
# on the primary message
sprintf.replace() {
	local params=();
	
	declare -A count;
	count[specifiers]=0;
	count[matches]=0;
	count[injected]=0;
	
	# no ANSI
	if ! ${flags[ansi]}; then
		sprintf.prefix;
		results=( "${message}" "${replacements[@]:-}" );
	else
		if ${flags[ansi]}; then
			# no replacement parameters
			if [ ${#replacements[@]} -eq 0 ]; then
				sprintf.prefix;
				sprintf.colour.start;
				results=( "${message}" "${params[@]:-}" );
				
				#echo "NO REPLACEMENT VALUES : ${#results[@]}";
			else
				
				#echo "replace with ansi paramaters";
				
				local output="";
				
				# keep track of parameters that
				# have trailing text and need the main
				# message colour to start again
				local trailing=();
				# wrap each format specification in %b
				sprintf.format;
				message="${output}";
				
				# echo "GOT FORMATTED MESSAGE: $message";
				#exit 0;
				
				# must be done after modifying
				# the message format
				sprintf.prefix;
				
				local i length val;
				length="${#replacements[@]}";
				for((i = 0;i < $length;i++))
					do
						val="${replacements[$i]}";					
						
						if ${flags[replace.bold]}; then
							params+=( "${styles[bright]}" "${val}" "${terminator}" );
						else
							params+=( "${val}" );
						fi
						
						if [ -n "${trailing[$i]:-}" ]; then
							#echo "BEFORE START COLOR AGAIN... ${settings[color]} : ${#params[@]}";
							params+=( "${settings[color]:-}" );
							#echo "AFTER START COLOR AGAIN... ${settings[color]} : ${#params[@]}";
						fi
				done
				
				# local i length val;
				# local formatted;
				# 
				# #formatted=$( sprintf.format );
				# local output="";
				# #sprintf.format;
				# # echo "got output: $output";
				# #exit 0;
				# #echo "got formatted: ${formatted}";
				# length="${#replacements[@]}";
				# local highlight_color="";
				# local style;
				# local custom_style;
				# for((i = 0;i < $length;i++))
				# 	do
				# 		val="${replacements[$i]}";
				# 		custom_style="${settings[param.${i}]:-}";
				# 		highlight_color="";
				# 		style="";
				# 		
				# 		# ensure replacements respect the overall colour
				# 		if ${flags[color]} && [ -n "$color" ]; then
				# 			highlight_color="$color";
				# 		fi
				# 		if [ -n "${highlight_color}" ]; then
				# 			# replacements[$i]="${styles[$highlight_color]}${replacements[$i]}${terminator}";
				# 			
				# 			style="${style}${styles[$highlight_color]}";
				# 		fi
				# 	
				# 		# a 0-9 index based style for this parameter
				# 		if [ -n "${custom_style}" ]; then
				# 			#replacements[$i]="${custom_style}${replacements[$i]}${terminator}";
				# 			
				# 			#sprintf.param.append "${custom_style}" "${val}" "${terminator}";
				# 			
				# 			style="${custom_style}";
				# 		else
				# 			if $has_custom_message_color; then
				# 				#replacements[$i]="${settings[color]}${replacements[$i]}${terminator}";
				# 				
				# 				# sprintf.param.append "${settings[color]}" "${val}" "${terminator}";
				# 				
				# 				style="${settings[color]}";
				# 			else
				# 				if ${flags[replace.bold]}; then
				# 					#replacements[$i]="${styles[bright]}${val}${terminator}";
				# 					
				# 					#sprintf.param.append "${styles[bright]}" "${val}" "${terminator}";
				# 					
				# 					style="${style}${styles[bright]}";
				# 				fi
				# 			fi
				# 		fi
				# 		# start the message colour again for parts in
				# 		# between replacements
				# 		if ${flags[color]} && [ -n "$color" ]; then
				# 			#TODO
				# 			#replacements[$i]="${replacements[$i]}${settings[color]}";
				# 			
				# 			sprintf.param.append "${style}" "${terminator}${settings[color]}";
				# 		else
				# 			sprintf.param.append "${style}" "${terminator}";
				# 		fi
				# done
				
				#echo "got params length: ${#params[@]}";
				#echo "got params: ${params[@]}";
				#echo "got formatted: ${formatted}";
				#parsed=$( printf -- "${output}" "${params[@]:-}" );
				
				#parsed="${parsed//%%/%}";
				
				#echo "got parsed: ${parsed}";
				#exit 0;
				
				#parsed=$( printf -- "${message}" "${replacements[@]:-}" );
				
				# start colour for the entire message
				sprintf.colour.start;
				
				results=( "${message}" "${params[@]}" );
			fi
		fi

		# handle overall message color
		# if ${flags[ansi]} && ${flags[color]} && [ -n "$color" ]; then
		# 	# echo "add overall message color ..."
		# 	parsed="${settings[color]}${parsed}";
		# fi
	fi
	
	# if ${flags[ansi]}; then
	# 	parsed="${parsed}${terminator}";
	# fi	

	if ${flags[ansi]}; then
		#local last="${results[${#results[@]}-1]}";
		#if [ "$last" != "$terminator" ]; then
			# always add final terminator
			results[0]="${results[0]}%b";
			: $((count[injected]+=1));
			results+=( "${terminator}" );			
		#fi
	fi
	
	# DEBUG

	if ${flags[debug]}; then
		echo "got original: '${original}'";
		echo "got message: '${message}'";
		echo "got specifiers (length): ${count[specifiers]}";
		echo "got injected (length): ${count[injected]}";
		echo "got replacement matches (length): ${count[matches]}";
		echo "got results (length): ${#results[@]}";
		echo "got result (length): ${results[@]}";
		echo "got first result: '${results[0]}'";
	
		# build up a test command string
		local str="printf -- '${results[0]}'";
		local j opt length="${#results[@]}";
		for((j = 1;j < $length;j++))
			do
				str="${str} '${results[$j]}'";
		done
	
		echo "$str";
	fi
}

# prepend prefix(es)
sprintf.prefix() {
	if ${flags[message.prefix]}; then
		# call a prefix command
		if [ -n "${prefix_command:-}" ]; then
			local commands=( ${prefix_command} );
			if method.exists? "${commands[0]}"; then
				${commands[0]} ${commands[@]:1};
			fi
		fi
		
		# prefix flags
		if ${flags[timestamp]}; then
			sprintf.prefix.timestamp;
		fi
		if ${flags[date]}; then
			sprintf.prefix.date;
		fi
		if ${flags[program]}; then
			sprintf.prefix.program;
		fi		
		
		# prefix before any ANSI sequences
		local plain_prefix="${prefix}";
		
		#echo "GOT PREFIX: $plain_prefix";
		
		if [ -n "${plain_prefix:-}" ]; then
			# colour the prefix
			if ${flags[ansi]}; then
				
				#echo "COLOUR PREFIX"
				
				if ${flags[prefix.bright]}; then
					# restart main colour after prefix
					if [ -n "${color}" ]; then
						message="%b%s%b%b ${message}";
						: $((count[injected]+=3));
						params=( "${styles[bright]}" "${prefix}" "${terminator}" "${settings[color]}" );
					else					
						message="%b%s%b ${message}";
						: $((count[injected]+=2));
						params=( "${styles[bright]}" "${prefix}" "${terminator}" );
					fi
				else
					message="%s ${message}";
					params=( "${prefix}" );
				fi
			else
				message="${prefix} ${message}";
			fi
		fi
	fi
}

# prepend the program name
sprintf.prefix.program() {
	local pname="${process_name:-}";
	local begin=$( sprintf.block "$pname" );
	if [ -n "${prefix:-}" ]; then
		begin="${begin} ${prefix}";
	fi
	prefix="${begin}";
}

# prepend a date
sprintf.prefix.date() {
	local date=$( date );
	local value=$( sprintf.block "$date" );
	if [ -n "${prefix:-}" ]; then
		value="${prefix} ${value}";
	fi
	prefix="${value}";
}

# prepend a timestamp
sprintf.prefix.timestamp() {
	local date=$( date +%s );
	local value=$( sprintf.block "$date" );
	if [ -n "${prefix:-}" ]; then
		value="${prefix} ${value}";
	fi
	prefix="${value}";
}

# debug parsed options
sprintf.debugger() {
	echo "$header";
	local flag;
	for flag in ${!flags[@]}
		do
			echo "flag $flag :: ${flags[$flag]}";
	done
	echo "prefix is : ${prefix}"
	echo "messages length : ${#messages[@]}";
	echo "messages are : ${messages}";
	echo "primary message: $message";
	echo "replacements length: ${#replacements[@]}";
	if [ "${#replacements[@]}" -gt 0 ]; then
		echo "replacements: ${replacements[@]}";	
	fi
	echo "$header";	
}

# parse sprintf options
sprintf.options.parse() {
	#echo "$FUNCNAME : $*";
	local optspec=":12-:";
	local optchar val opt;
	OPTIND=0;
	while getopts "$optspec" optchar; do
	    case "${optchar}" in
	        -)
	            case "${OPTARG}" in
					'')
						break;
						;;
	                prefix=*)
	                    val=${OPTARG#*=};
	                    opt=${OPTARG%=$val};
						prefix="${val}";
	                    ;;
	                suffix=*)
	                    val=${OPTARG#*=};
	                    opt=${OPTARG%=$val};
						suffix="${val}";
	                    ;;	
	                text=*)
	                    val=${OPTARG#*=};
	                    opt=${OPTARG%=$val};
						color="${val}";
	                    ;;
	                background=*)
	                    val=${OPTARG#*=};
	                    opt=${OPTARG%=$val};
						background="${val}";
	                    ;;
	                attribute=*)
	                    val=${OPTARG#*=};
	                    opt=${OPTARG%=$val};
						attribute="${val}";
	                    ;;
	                export=*)
	                    val=${OPTARG#*=};
	                    opt=${OPTARG%=$val};
						varname="${val}";
						vartype="export";
	                    ;;
	                prefix-command=*)
	                    val=${OPTARG#*=};
	                    opt=${OPTARG%=$val};
						prefix_command="${val}";
						flags[message.prefix]=true;
	                    ;;
	                text[0-9]=*)
	                    val=${OPTARG#*=};
	                    opt=${OPTARG%=$val};
						sprintf.parameter.style "$opt" "$val" "fg";
	                    ;;
	                background[0-9]=*)
	                    val=${OPTARG#*=};
	                    opt=${OPTARG%=$val};
						sprintf.parameter.style "$opt" "$val" "bg";						
	                    ;;
	                attribute[0-9]=*)
	                    val=${OPTARG#*=};
	                    opt=${OPTARG%=$val};
						sprintf.parameter.style "$opt" "$val" "attr";
	                    ;;
	                color=never)
						flags[ansi]=false;
	                    ;;
	                program)
						flags[program]=true;
	                    ;;
	                date)
						flags[date]=true;
	                    ;;
	                timestamp)
						flags[timestamp]=true;
	                    ;;
	                no-prefix)
						flags[message.prefix]=false;
	                    ;;
	                no-bright-prefix)
						flags[prefix.bright]=false;
	                    ;;
	                readline)
						flags[readline]=true;
	                    ;;
	                no-newline)
						flags[newline]=false;
	                    ;;
	                debug)
						flags[debug]=true;
	                    ;;
	                *)
	                    if [ "$OPTERR" == 1 ] && [ "${optspec:0:1}" != ":" ]; then
	                        echo "sprintf: unknown option --${OPTARG}" >&2
	                    fi
	                    ;;
	            esac;;
	        1)
				flags[stderr]=false;
	            ;;
	        2)
				flags[stderr]=true;
	            ;;
	        *)
	            if [ "$OPTERR" != 1 ] || [ "${optspec:0:1}" == ":" ]; then
	                echo "sprintf: non-option '-${OPTARG}'" >&2
	            fi
	            ;;
	    esac
	done
	
	# get remaining message and printf
	# replacement values
	local opt opts=( "$@" );
	local i length="$#";
	local stopped=false;
	for((i = 0;i < $length;i++))
		do
			opt="${opts[$i]}";
			if [ "$opt" == "--" ]; then
				stopped=true;
				continue;
			fi
			if ! $stopped && [[ "$opt" =~ ^- ]]; then
				continue;
			fi
			messages+=( "$opt" );
	done
}