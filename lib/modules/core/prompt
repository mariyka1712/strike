declare -Ag prompt_data;
declare -Ag prompt_boolean;

# callback lists
declare -g prompt_accepted;
declare -g prompt_rejected;
declare -g prompt_invalid;

declare -g prompt_current;

# current prompt command
declare -g prompt_command;
declare -ag prompt_command_options;

# main entry point
prompt() {
	if [ $# -eq 0 ]; then
		console quit 1 "too few options";
	fi
	
	local namespace="${FUNCNAME}.commands";
	local cmd="$1";
	shift;
	if ! method.exists? "${namespace}${delegate_delimiter}${cmd}"; then
		console quit 1 "invalid command %s" "$cmd";
	fi
	
	# valud entered by user
	local value;

	# configuration settings
	declare -A settings;
	settings[boolean.strict]=false;
	settings[boolean.yes]="yes";
	settings[boolean.no]="no";
	settings[boolean.accepted]="";
	settings[boolean.rejected]="";
	
	prompt.options.parse "$@";
	delegate "${namespace}" "${cmd}" "$@";
}

# COMMANDS

# show a boolean prompt
prompt.commands.boolean() {
	local accept="${settings[boolean.yes]}";
	local reject="${settings[boolean.no]}";
	
	local accept_regexp="^${accept}$";
	local reject_regexp="^${reject}$";
	
	# comparse against first character
	if ! ${settings[boolean.strict]}; then
		accept="${accept:0:1}";
		reject="${reject:0:1}";
		
		# only needs to start with for non-strict mode
		accept_regexp="^${accept}";
		reject_regexp="^${reject}";
	fi
	
	# echo "show boolean prompt: ${accept:0:1}";
	# echo "show boolean prompt: ${reject:0:1}";
	
	prompt.read;
	local compare="${value}";
	
	# compare case-insensitive when
	# not running strict
	if ! ${settings[boolean.strict]}; then
		compare="${compare,,}";
	fi
	
	# echo "after boolean prompt ... $value";
	
	if [[ "$compare" =~ $accept_regexp ]]; then
		prompt.trigger 'boolean.accepted';
	elif [[ "$compare" =~ $reject_regexp ]]; then
		prompt.trigger 'boolean.rejected';
	else
		# show the prompt again
		# on invalid input
		prompt.commands.boolean;
	fi
}

# show a string prompt accepting
# any non-empty string value
prompt.commands.string() {
	prompt.read;
	echo "after string prompt ... $value";
}

# INTERNAL

# invoke a comamnd
prompt.trigger() {
	local key="${1:-}";
	echo "trigger command with key: $key";
	if [ -n "$key" ]; then
		local cmd="${settings[$key]:-}";
		if [ -n "$key" ] && method.exists? "$cmd"; then
			"$cmd" "${value}";
		fi
	fi
}

# handle option parsing
prompt.options.parse() {
	echo "$FUNCNAME : $*";
}

# show a prompt using read
prompt.read() {
	if [ -t 0 ]; then
		prompt.before;
		if [ -n "${PS9:-}" ]; then
			read -ep "${PS9}" value;
		else		
			read -e value;
		fi
		prompt.after;
		# 
		# if [ -n "${value:-}" ]; then
		# 	__prompt.accepted "${value}";
		# else
		# 	__prompt.rejected "${value}";
		# fi
	fi
}

# executed before showing a prompt
prompt.before() {
	# save stderr in file descriptor #7
	exec 7>&2;
	# redirect stderr to stdout
	exec 2>&1;
}

# executed after showing a prompt
prompt.after() {
	# restore stderr and close file descriptor #7
	if [ -f 7 ]; then
		exec 2>&7 7>&-;
	fi
}




























# add a boolean prompt
# $1 id
# $2 true string
# $3 false string
# $4..$# message parameters ...
prompt.boolean() {
	local key="${1:-}";
	shift;
	# store newline separated
	local quoted="";
	local IFS=$'\n';
	quoted=( $@ );
	prompt_boolean["$key"]="${quoted[*]}";
}

# add a data prompt - read a non-empty string
# $1 id
# $2..$# message parameters ...
prompt.data() {
	local key="${1:-}";
	shift;
	# store newline separated
	local quoted="";
	local IFS=$'\n';
	quoted=( $@ );
	prompt_data["$key"]="${quoted[*]}";
}

# show a prompt by id
prompt.show() {
	if [ ! -t 0 ]; then
		return 0;
	fi
	
	local key="${1:-}";
	shift;
	if [ -n "${prompt_boolean["$key"]:-}" ]; then
		local IFS=$'\n';
		local values=( ${prompt_boolean["$key"]} );
		unset IFS;		
		prompt_command_options=( ${values[@]} );
		prompt_command='__prompt.show.boolean';
		__prompt.show.boolean ${values[@]};
		unset IFS;
		return $?;
	elif [ -n "${prompt_data["$key"]:-}" ]; then
		local IFS=$'\n';
		local values=( ${prompt_data["$key"]} );
		unset IFS;		
		prompt_command_options=( ${values[@]} );		
		prompt_command='__prompt.show.data';
		__prompt.show.data ${values[@]};		
		return $?;
	fi
	console warn "no prompt data for %s" "$key";
	return 1;
}

# sets accept callback method
prompt.accepts() {
	prompt_accepted="$@";
}

# sets rejects callback method
prompt.rejects() {
	prompt_rejected="$@";
}

# sets invalid callback method
prompt.invalid() {
	prompt_invalid="$@";
}

# clean prompt data
prompt.clean() {
	unset prompt_data;
	unset prompt_boolean;
	declare -Ag prompt_data;
	declare -Ag prompt_boolean;
}

######################################################################
#
#	PRIVATE METHODS
#
######################################################################

function __prompt.trigger {
	local m;
	local IFS=' ';
	local methods=( $1 );
	shift;
	unset IFS;
	for m in ${methods[@]}
		do
			if method.exists? "$m"; then
				$m "$@";
			fi
	done
}

function __prompt.accepted {
	__prompt.trigger $prompt_accepted "$@";
	return 0;
}

function __prompt.rejected {
	__prompt.trigger $prompt_rejected "$@";
	return 0;
}

function __prompt.invalid {
	if [ -n "${prompt_invalid:-}" ]; then
		__prompt.trigger $prompt_invalid;
	fi
	$prompt_command ${prompt_command_options[@]:-};
	return 0;
}

function __prompt.show.boolean {
	local value;	
	local accept="$1";
	shift;
	local reject="$1";
	shift;
	
	prompt_current=( $@ );

	if [ -t 0 ]; then
		prompt.before;
		
		# show the prompt message
		# console prompt "$@";
		
		if [ -n "${PS9:-}" ]; then
			read -ep "${PS9}" value;
		else
			read -e value;
		fi
		prompt.after;
		if [ "$value" == "$accept" ]; then
			__prompt.accepted $@;
		elif [ "$value" == "$reject" ]; then
			__prompt.rejected $@;
		else
			__prompt.invalid $@;
		fi
	fi
}

function __prompt.show.data {
	local value;
	
	prompt_current=( $@ );
	
	if [ -t 0 ]; then
		
		prompt.before;
		
		# show the prompt message
		# console prompt $@;
		
		if [ -n "${PS9:-}" ]; then
			read -ep "${PS9}" value;
		else		
			read -e value;
		fi
		prompt.after;
		if [ -n "${value:-}" ]; then
			__prompt.accepted "${value}";
		else
			__prompt.rejected "${value}";
		fi
	fi
}