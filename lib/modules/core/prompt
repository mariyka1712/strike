declare -Ag prompt_data;
declare -Ag prompt_boolean;

# callback lists
declare -g prompt_accepted;
declare -g prompt_rejected;
declare -g prompt_invalid;

declare -g prompt_current;

# current prompt command
declare -g prompt_command;
declare -ag prompt_command_options;

# main entry point
prompt() {
	if [ $# -eq 0 ]; then
		console quit 1 "too few options";
	fi
	
	local namespace="${FUNCNAME}.commands";
	local cmd="$1";
	shift;
	if ! method.exists? "${namespace}${delegate_delimiter}${cmd}"; then
		console quit 1 "invalid command %s" "$cmd";
	fi
	
	# valud entered by user
	local value;

	# configuration settings
	declare -A settings;
	
	# custom data associated with the prompt
	settings[data.id]="";
	
	# boolean settings
	settings[boolean.strict]=false;
	settings[boolean.yes]="yes";
	settings[boolean.no]="no";
	settings[boolean.accepted]="";
	settings[boolean.rejected]="";
	
	# command callbacks
	settings[commands.before]="";
	settings[commands.response]="";
	
	settings[hist.control]="erasedups:ignoredups";
	settings[hist.size]="500";
	settings[hist.filesize]="500";
	settings[hist.file]="";
	
	prompt.options.parse "$@";
	
	# try to create a history file when possible
	if [ -n "${settings[hist.file]}" ] \
		&& [ ! -f "${settings[hist.file]}" ]; then
		touch "${settings[hist.file]}" \
			|| console quit 1 "could not create %s" \
				"${settings[hist.file]}";
	fi
	
	delegate "${namespace}" "${cmd}" "$@";
}

# COMMANDS

# show a boolean prompt
prompt.commands.boolean() {
	local accept="${settings[boolean.yes]}";
	local reject="${settings[boolean.no]}";
	
	local accept_regexp="^${accept}$";
	local reject_regexp="^${reject}$";
	
	# comparse against first character
	if ! ${settings[boolean.strict]}; then
		accept="${accept:0:1}";
		reject="${reject:0:1}";
		
		# only needs to start with for non-strict mode
		accept_regexp="^${accept}";
		reject_regexp="^${reject}";
	fi
	
	prompt.read;
	local compare="${value}";
	
	# compare case-insensitive when
	# not running strict
	if ! ${settings[boolean.strict]}; then
		compare="${compare,,}";
	fi
	
	if [[ "$compare" =~ $accept_regexp ]]; then
		prompt.trigger 'commands.response' \
			true "${settings[data.id]:-}" "${value:-}";
		
		#
		prompt.trigger 'boolean.accepted' "${value:-}";
		
	elif [[ "$compare" =~ $reject_regexp ]]; then
		prompt.trigger 'commands.response' \
			false "${settings[data.id]:-}" "${value:-}";
		
		#
		prompt.trigger 'boolean.rejected' "${value:-}";
		
	else
		# show the prompt again
		# on invalid input
		prompt.commands.boolean;
	fi
}

# show a string prompt accepting
# any non-empty string value
prompt.commands.value() {
	prompt.read;
	if [ -n "${value:-}" ]; then
		prompt.trigger 'commands.response' \
			"${value:-}" "${settings[data.id]:-}";
	else
		# show the prompt again
		# on empty input
		prompt.commands.value;
	fi
}

# INTERNAL

# determine if interactivity is possible
prompt.interactive?() {
	if [ -t 0 ]; then
		return 0;
	fi
	return 1;
}

# show a prompt using read
prompt.read() {
	local hist_file="${settings[hist.file]}";
	# load history entries
	if [ -n "${hist_file:-}" ] && [ -f "${hist_file}" ]; then
		history -n "${hist_file}";
	fi
	prompt.trigger 'commands.before' "${settings[data.id]:-}";
	if prompt.interactive?; then
		prompt.before;
		if [ -n "${PS9:-}" ]; then
			while
				HISTSIZE="${settings[hist.size]}"
				HISTFILESIZE="${settings[hist.filesize]}";
				HISTFILE="${hist_file}";
				HISTCONTROL="${settings[hist.control]}";
				read -ep "${PS9}" value;
				do
					if [ -f "${HISTFILE}" ] \
						&& [ -w "${HISTFILE}" ]; then
						history -s "$value";
						history -w "$HISTFILE";
					fi
					break;
			done
		else
			while
				HISTSIZE="${settings[hist.size]}"
				HISTFILESIZE="${settings[hist.filesize]}";
				HISTFILE="${hist_file}";
				HISTCONTROL="${settings[hist.control]}";
				read -e value;
				do
					if [ -f "${HISTFILE}" ] \
						&& [ -w "${HISTFILE}" ]; then
						history -s "$value";
						history -w "$HISTFILE";
					fi
					break;
			done
		fi
		prompt.after;
	fi
}

# executed before showing a prompt
prompt.before() {
	# save stderr in file descriptor #7
	exec 7>&2;
	# redirect stderr to stdout
	exec 2>&1;
}

# executed after showing a prompt
prompt.after() {
	# restore stderr and close file descriptor #7
	if [ -f 7 ]; then
		exec 2>&7 7>&-;
	fi
}

# invoke a comamnd
prompt.trigger() {
	local key="${1:-}";
	local arguments=( "${@:2}" );
	# echo "trigger command with arguments: $arguments";
	if [ -n "$key" ]; then
		local cmd="${settings[$key]:-}";
		#echo "got cmd: $cmd";
		if [ -n "$cmd" ] && method.exists? "$cmd"; then
			"$cmd" "${arguments[@]:-}";
		fi
	fi
}

# handle option parsing
prompt.options.parse() {
	#echo "parsing opts $*";
	local optspec=":12-:";
	local optchar val opt;
	OPTIND=0;
	while getopts "$optspec" optchar; do
	    case "${optchar}" in
	        -)
	            case "${OPTARG}" in
					'')
						break;
						;;
	                before=*)
	                    val=${OPTARG#*=};
	                    opt=${OPTARG%=$val};
						settings[commands.before]="${val}";
	                    ;;
	                response=*)
	                    val=${OPTARG#*=};
	                    opt=${OPTARG%=$val};
						settings[commands.response]="${val}";
	                    ;;
	                hist-file=*)
	                    val=${OPTARG#*=};
	                    opt=${OPTARG%=$val};
						settings[hist.file]="${val}";
	                    ;;
	                id=*)
	                    val=${OPTARG#*=};
	                    opt=${OPTARG%=$val};
						settings[data.id]="${val}";
	                    ;;
	                *)
	                    if [ "$OPTERR" == 1 ] && [ "${optspec:0:1}" != ":" ]; then
	                        echo "prompt: unknown option --${OPTARG}" >&2
	                    fi
	                    ;;
	            esac;;
	        1)
				echo "got flag"
	            ;;
	        *)
	            if [ "$OPTERR" != 1 ] || [ "${optspec:0:1}" == ":" ]; then
	                echo "prompt: non-option '-${OPTARG}'" >&2
	            fi
	            ;;
	    esac
	done	
}




























# add a boolean prompt
# $1 id
# $2 true string
# $3 false string
# $4..$# message parameters ...
prompt.boolean() {
	local key="${1:-}";
	shift;
	# store newline separated
	local quoted="";
	local IFS=$'\n';
	quoted=( $@ );
	prompt_boolean["$key"]="${quoted[*]}";
}

# add a data prompt - read a non-empty string
# $1 id
# $2..$# message parameters ...
prompt.data() {
	local key="${1:-}";
	shift;
	# store newline separated
	local quoted="";
	local IFS=$'\n';
	quoted=( $@ );
	prompt_data["$key"]="${quoted[*]}";
}

# show a prompt by id
prompt.show() {
	if [ ! -t 0 ]; then
		return 0;
	fi
	
	local key="${1:-}";
	shift;
	if [ -n "${prompt_boolean["$key"]:-}" ]; then
		local IFS=$'\n';
		local values=( ${prompt_boolean["$key"]} );
		unset IFS;		
		prompt_command_options=( ${values[@]} );
		prompt_command='__prompt.show.boolean';
		__prompt.show.boolean ${values[@]};
		unset IFS;
		return $?;
	elif [ -n "${prompt_data["$key"]:-}" ]; then
		local IFS=$'\n';
		local values=( ${prompt_data["$key"]} );
		unset IFS;		
		prompt_command_options=( ${values[@]} );		
		prompt_command='__prompt.show.data';
		__prompt.show.data ${values[@]};		
		return $?;
	fi
	console warn "no prompt data for %s" "$key";
	return 1;
}

# sets accept callback method
prompt.accepts() {
	prompt_accepted="$@";
}

# sets rejects callback method
prompt.rejects() {
	prompt_rejected="$@";
}

# sets invalid callback method
prompt.invalid() {
	prompt_invalid="$@";
}

# clean prompt data
prompt.clean() {
	unset prompt_data;
	unset prompt_boolean;
	declare -Ag prompt_data;
	declare -Ag prompt_boolean;
}

######################################################################
#
#	PRIVATE METHODS
#
######################################################################

function __prompt.trigger {
	local m;
	local IFS=' ';
	local methods=( $1 );
	shift;
	unset IFS;
	for m in ${methods[@]}
		do
			if method.exists? "$m"; then
				$m "$@";
			fi
	done
}

function __prompt.accepted {
	__prompt.trigger $prompt_accepted "$@";
	return 0;
}

function __prompt.rejected {
	__prompt.trigger $prompt_rejected "$@";
	return 0;
}

function __prompt.invalid {
	if [ -n "${prompt_invalid:-}" ]; then
		__prompt.trigger $prompt_invalid;
	fi
	$prompt_command ${prompt_command_options[@]:-};
	return 0;
}

function __prompt.show.boolean {
	local value;	
	local accept="$1";
	shift;
	local reject="$1";
	shift;
	
	prompt_current=( $@ );

	if [ -t 0 ]; then
		prompt.before;
		
		# show the prompt message
		# console prompt "$@";
		
		if [ -n "${PS9:-}" ]; then
			read -ep "${PS9}" value;
		else
			read -e value;
		fi
		prompt.after;
		if [ "$value" == "$accept" ]; then
			__prompt.accepted $@;
		elif [ "$value" == "$reject" ]; then
			__prompt.rejected $@;
		else
			__prompt.invalid $@;
		fi
	fi
}

function __prompt.show.data {
	local value;
	
	prompt_current=( $@ );
	
	if [ -t 0 ]; then
		
		prompt.before;
		
		# show the prompt message
		# console prompt $@;
		
		if [ -n "${PS9:-}" ]; then
			read -ep "${PS9}" value;
		else		
			read -e value;
		fi
		prompt.after;
		if [ -n "${value:-}" ]; then
			__prompt.accepted "${value}";
		else
			__prompt.rejected "${value}";
		fi
	fi
}