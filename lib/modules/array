: <<'ronn:markdown'
array(3) -- array module
=============================================

## SYNOPSIS

Module methods for writing, reading, modifiying and inspecting arrays.

## DESCRIPTION

The array(3) modules can be used to write *global* array(s) to file(s) and read the file(s) back into array declarations.

## USAGE

To write an array file, declare the *global* array(s) and call `array.write`.

	write_array() {
		local file="${program_dirs[root]}/arrays";
		declare -a array1;
		array1=( 3 2 1 "a test string" );
		declare -A array2;
		array2[key]="value";
		array2[greeting]="hello world";
		array.write "$file" <<< "array1 array2";	# specify the array names on stdin
	}
	write_array;
	
To read an array file back into array(s) use the `array.read` method.

	read_array() {
		local file="${program_dirs[root]}/arrays";
		array.read < "$file";						# read from the `arrays` file
		
		# print array keys
		console.log "${!array1[*]}";
		console.log "${!array2[*]}";
		
		# print array values
		console.log "${array1[*]}";
		console.log "${array2[*]}";
	}
	read_array;

## BUGS

When writing and reading arrays, the variable declarations must by *global*.

Attempting to write and read associative arrays with spaces in the *keys* will result in unexpected behaviour.

**array** is written in bash and depends upon `bash` >= 4.

## COPYRIGHT

**array** is copyright (c) 2012 muji <http://xpm.io>

## SEE ALSO

require(3)
ronn:markdown

# "a string" "${array[@]}"
function array.contains {
	local e;
	for e in "${@:2}"; do [[ "$e" == "$1" ]] && return 0; done
	return 1;
}

function array.join {
	#TODO: strip leading delimiter
	local delimiter="${1:-,}";
	local elements=( "${@:2}" );
	_result=$(printf "${delimiter}%s" "${elements[@]}");
}


function array.is.array {
	local name="$1";
	set +o errexit;
	declare -p "$name" 2> /dev/null | grep -q 'declare \-a';
	local exists="$?";
	set -o errexit;
	_result="$exists";
}

function array.is.assoc {
	local name="$1";
	set +o errexit;
	declare -p "$name" 2> /dev/null | grep -q 'declare \-A';
	local exists="$?";
	set -o errexit;
	_result="$exists";
}

# TODO: rename to array.last as it cannot pop
function array.pop {
	#local arr=( "$@" );
	#_result=arr[${#arr[@]}-1];
	#unset arr[${#arr[@]}-1];
	
	#echo "1: $1";
	#echo "2: $2";
	
	local opts=( "$@" );	
	_result=${opts[${#opts[@]}-1]};
	unset opts[${#opts[@]}-1];
	#echo "got opts: ${opts[@]}";
	#echo "got opts length: ${#opts[@]}";
	
	#_result="";
	
	#while [ $# -gt 0 ]
	#	do
	#		_result="$1";			
	#		shift;
	#		echo "shifted..."
	#done
}

function array.each {
	local name="${1:-}";
	local iterator="${2:-}";
	local key value;
	local index=0;
	if [ ! -z "$name" ]; then
		eval keys="\${!$name[@]}";
		for key in ${keys}
			do
				eval value="\${$name[$key]}";
				#echo "array.each got key : $key";
				# echo "got value : $value";
				
				# TODO: check the iterator method exists
				"$iterator" "$key" "$value" "$index";
				((index++));
		done
	fi
}

#TODO: allow for spaces in associative array key names

# write array(s) to name=value pairs
function array.write {
	local opts=( "$@" );
	local file="${1:-}";
	local flags="${2:-g}";
	if [ -z "$file" ]; then
		console.warn "no file passed to array.write";
	else
		echo -ne "" > "$file" || quit 1 "could not create array.write file %s" "$file";
		local stdin;
		# this allows us to accept options and read from stdin
		# with positional parameter expansion
		if [ ! -t 0 ]; then
			# read in stdin
			read -a stdin;
			# expand stdin data to positional parameters
			set -- $( echo "${stdin[@]}" );
		fi

		function iterator {
			local key="$1" value="$2" index="$3";
			echo "${key}=${value}" >> "$file";
		}
		
		local arrflags isassoc;
		local i val;
		for((i = 0;i < $#;i++))
			do
				eval val="$"$[i+1];
				arrflags="-a";
				array.is.assoc "$val";
				isassoc="$_result";
				if [ $isassoc -eq 0 ]; then
					arrflags="-A";
				fi
				arrflags="${arrflags}${flags}";
				# write the array name header comment
				echo "#ยก declare $arrflags $val" >> "$file";
				array.each "$val" "iterator";
		done

		# clean up the iterator
		method.remove "iterator";
	fi
}

# read a name=value pair array(s) file
function array.read {
	local opts=( "$@" );
	local file="${1:-}";
	local arrayname="";
	
	# deal with comments 
	array.read.comment() {
		if [[ "$1" =~ ^#ยก ]]; then
			local declaration=${1//#ยก /};
			local name=${declaration##* };
			# store the array name
			arrayname="$name";
			# declare the array
			eval "$declaration";
		fi
	}
	
	# add an entry to the current array being processed
	array.read.add() {
		local __key__=${1%%=*};
		local __value__=${1##*=};
		if [ ! -z "$arrayname" ]; then
			local setter="$arrayname[\"$__key__\"]=\"$__value__\";";
			eval "$setter";
		fi
	}
	
	if [ ! -z "$file" ] && [ -f "$file" ] && [ -r "$file" ]; then
		while read line
			do
				if [[ "$line" =~ ^# ]]; then
					array.read.comment "$line";
				else
					array.read.add "$line";
				fi
		done < "$file"
	elif [ ! -t 0 ]; then
		while read line
			do
				if [[ "$line" =~ ^# ]]; then
					array.read.comment "$line";
				else
					array.read.add "$line";
				fi
		done
	else
		quit 1 "invalid input to array.read, usage: array.read < file";
	fi
	
	# clean up the internal methods
	method.remove "array.read.comment";
	method.remove "array.read.add";
}