# SEE: http://mywiki.wooledge.org/BashFAQ/006

# holds the last result of calling json.stringify
declare -gx json_str;

# regexp for number matching
declare -g json_number_regexp="^-?[0-9]+((\.[0-9]+)?([eE][-+]?[0-9]+)?)?$";

function json.stringify {
	
	# clean up from last call
	json.stringify.clean;
	
	local json="";
	
	local objstart="{";
	local objend="}";
	
	local arrstart="[";
	local arrend="]";
	
	local newline="
";
	local pretty=0;
	local space=' ';
	local indent="";
	local depth=0;
	
	if [ $# -gt 0 ] && [ "$1" == "--pretty" ]; then
		pretty=1;
		local indent_repeat="${2:-2}";
		space=${3:-$space};
		string.repeat "${space}" "${indent_repeat}";
		indent="$_result";
		
		objstart="${objstart}${newline}";
		objend="${newline}${objend}";
		
		arrstart="${arrstart}${newline}";
		arrend="${newline}${arrend}";
	fi
	
	# this allows us to accept options and read from stdin
	# with positional parameter expansion
	if [ ! -t 0 ]; then
		# read in stdin
		read -a stdin;
		# expand stdin data to positional parameters
		set -- $( echo "${stdin[@]}" );
	fi
	
	local json_data="${1:-}";
	if [ -z "$json_data" ]; then
		console.warn "invalid json.stringify call, usage: json.stringify <<< \"varname\"";
		return 1;
	fi
	
	#echo "testing existence of ${1:-}";
	
	$( array.is.array? "$json_data" );
	local isarr=$?;
	$( array.is.assoc? "$json_data" );	
	local isassoc=$?;
	
	# echo "is arr: $isarr : $json_data";
	# echo "is assoc: $isassoc : $json_data";
	
	#echo "got exists: $exists";
	
	# validate that plain variables are set
	if [ $isarr -gt 0 ] && [ $isassoc -gt 0 ]; then
		eval "[ \${${json_data}+a} ]";
		local exists=$?;		
		if [ $exists -gt 0 ]; then
			#echo "variable has not been set!!!";
			return 1;
		fi
	fi
	
	local keys value;
	
	# variable is a plain array
	if [ $isarr -eq 0 ] && [ $isassoc -eq 1 ]; then
		__json.stringify.array "$json_data";
	# variable is an associative array, treat as a complex object
	elif [ $isarr -eq 1 ] && [ $isassoc -eq 0 ]; then 
		eval keys="\${!$json_data[@]}";	
		__json.stringify.object "$json_data";
	# plain variable value
	else
		# variable has some sort of value
		eval value="\${$json_data}";
		if [ -n "$value" ]; then
			__json.stringify.value "$value";
			json="$_result";
			
	
			#echo "got result after evaluation : '''$json'''";
			
		# the empty string should be ""
		else
			json="\"\"";
		fi
	fi
	if [ ! -z "$json" ]; then
		json_str="$json";
	fi
	return 0;
}

# clean global variable(s)
function json.stringify.clean {
	unset json_str;
}

######################################################################
#
#	PRIVATE METHODS
#
######################################################################

function __json.stringify.array {
	eval keys="(\${!$json_data[@]})";
	
	if [ "${#keys[@]}" -eq 0 ]; then
		__json.stringify.array.start;
		__json.stringify.array.end;
		return 0;
	fi
	
	__json.stringify.array.start;
	local json_data="$1";
	local key value;
	
	#echo "arr keys: ${keys[@]}";
	
	# sort keys numerically	
	local IFS="
";
	local lines="${keys[@]}"
	unset IFS;
	keys=( $( echo "$lines" | sort -k1,1n ) );
	
	# variables for nested matches
	local k match nk nv ak nestedkey nlen;
	
	local index=0;
	# deal with direct entries
	for key in ${keys[@]}
		do
			echo "processing array key: $key";
			# direct array property
			if [[ ! "$key" =~ \. ]]; then	
				#echo "array entry key: $key";
				eval value="\${$json_data[$key]}";
				# encode the value
				__json.stringify.value "$value";
				json="${json}${indent}${_result},";
				if [ $pretty -eq 1 ]; then
					json="${json}${newline}";
				fi
				unset keys[$index];
				echo "keys after unset: ${keys[@]}";
			else
				k=${key%%.*};
				# key would be a number and
				# therefore would create an error so prefix 
				# with an underscore
				nestedkey="_$k";
				eval "declare -A $nestedkey";
				match="^$k";
				#echo "got nested entry on key: $key : nested key is: $nestedkey : match is $match";
				local ni=0;
				for nk in ${keys[@]}
					do
						if [[ "$nk" =~ $match ]]; then
							eval nv="\${$json_data[$nk]}";
							ak=${nk#*.};
							eval "${nestedkey}[\"$ak\"]=\"$nv\"";
							#echo "adding nested key: $ak : $nv";
							unset keys["$ni"];
						fi
						: $((ni++));
				done
				eval nlen="\${#$nestedkey[@]}";
				if [ $nlen -gt 0 ]; then
					echo "CALLING OBJECT.STRINGIFY WITH NESTEDKEY: $nestedkey : $index";
					
					# treat as an object
					__json.stringify.object "$nestedkey";
					# add comma between array entries
					json="${json},";
					#unset keys["$key"];
				fi
			fi
			: $((index++));
	done
	
	json="${json%$newline}";
	json="${json%,}";
	__json.stringify.array.end;
}

function __json.stringify.array.start {
	json="${json}${arrstart}";
}


function __json.stringify.array.end {
	json="${json}${arrend}";
}

function __json.stringify.object {
	local key value;
	local json_data="$1";
	eval keys="\${!$json_data[@]}";
	
	# no keys to process, nothing to be done
	# set to: {}
	if [ -z "$keys" ]; then
		__json.stringify.object.start;
		__json.stringify.object.end;
		return 0;
	fi
	
	echo "__json.stringify.object: $1 ::: ${keys}";
	
	# test if any key at this level does not start
	# with an integer value, in which case it is
	# treated as an object
	local arr=true;
	for key in $keys
		do
			if [[ ! "$key" =~ ^[0-9]+(\.[a-zA-Z0-9])? ]]; then
				arr=false;
			fi
	done
	
	echo "got is arr: $arr";
	
	if $arr; then
		__json.stringify.array "$json_data";
		return 0;
	fi	
	
	__json.stringify.object.start;
	
	# deal with top-level properties of this object
	for key in $keys
		do
			# not a nested property
			if [[ ! "$key" =~ \. ]]; then
				eval value="\${$json_data[$key]}";
				__json.add.key.value "$key" "$value";
			fi
	done
	
	#return 0;
	
	# # if all keys are numeric, treat as an array
	# if [[ "$keys" =~ ^([0-9]+ ?)+$ ]]; then
	# 	__json.stringify.array "$json_data";
	# 	return 0;
	# fi
	
	# FIXME: implement handling of arrays of objects
	
	# #deal with arrays of objects
	# declare -A array;
	# local i=0;
	# for key in $keys
	# 	do
	# 		if [[ "$key" =~ ^[0-9]+\. ]]; then
	# 			eval value="\${$json_data[$key]}";				
	# 			array[ "$key" ]="$value";
	# 			echo "GOT NUMERIC ONLY KEY USING!!! : $key";
	# 			# attempt to use array
	# 			#__json.stringify.array "$json_data";
	# 			# unset keys[$i];
	# 		fi
	# 		: $((i++));
	# done
	
	# 
	# if [ ${#array[@]} -gt 0 ]; then
	# 	echo "array data : ${!array[@]} : ${array[@]}";
	# fi
	
	# if [ ${#keys[@]} -gt 0 ]; then
	# 	return 0;
	# fi
	
	# deal with nested properties
	local k match nk nv ak nestedkey;	
	for key in $keys
		do
			
			echo "handling key: $key";
			
			# if [[ "$key" =~ ^[0-9]+\. ]]; then
			# 	echo "GOT NUMERIC ONLY KEY USING UNDERSCORE!!! : $keys";
			# 	#k="_$k";
			# 	# attempt to use array
			# 	__json.stringify.array "$json_data";
			# else
				# got a nested dot-style reference
				if [[ "$key" =~ \. ]]; then
					# FIXME: handle arrays of objects !!!
					k=${key%%.*};
					
					nestedkey="$k";
					# sane bash compatible variable name
					if [[ "$k" =~ [-.]+ ]]; then
						nestedkey=${nestedkey//-/_};
					fi
					if [[ "$nestedkey" =~ ^[0-9]+$ ]]; then
						nestedkey="_$nestedkey";
					fi					
					
					eval "declare -A $nestedkey";
					match="^$k";
					for nk in $keys
						do
							if [[ "$nk" =~ $match ]]; then
								eval nv="\${$json_data[$nk]}";
								ak=${nk#*.};
								eval "${nestedkey}[\"$ak\"]=\"$nv\"";
								#echo "adding nested key: $ak";
							fi
					done
					
					# FIXME: ensure key value is quoted using the shared method
					json="${json}\"$k\":";
					__json.stringify.object "$nestedkey";
					json="${json}${objend}";
					return 0;
				fi
			#fi
	done
	json="${json%$newline}";
	json="${json%,}";
	__json.stringify.object.end;	
}

function __json.stringify.object.start {
	json="${json}${objstart}";	
}

function __json.stringify.object.end {
	json="${json}${objend}";
}

function __json.add.key.value {
	# quote the key
	__json.stringify.quote "$1";
	json="${json}${indent}${_result}:";
	
	# encode the value
	__json.stringify.value "$2";
	json="${json}${_result},";
	if [ $pretty -eq 1 ]; then
		json="${json}${newline}";
	fi
}

function __json.stringify.quote {
	local val="${1:-}";
	# escape quotes in the value being quoted
	val="${val//\"/\\\"}";
	# quoted string
	_result="\"$val\"";
}

function __json.stringify.value {
	_result="";
	# unquoted value for null, true, false and numbers
	if [ "$1" == "null" ] || [ "$1" == true ] || [ "$1" == false ] || [[ "$1" =~ $json_number_regexp ]]; then
		_result="$1";
	else
		
		# escape special regex characters using grep !?
		# grep -v -F "$data_line" "$data_dir"
		
		local jsonval="$1";
		
		# echo "jsonval: '''$jsonval'''";
		# 
		# if [[ "$jsonval" =~ \\n ]]; then
		# 	echo "value has escaped newline!!: $jsonval";
		# else
		# 	jsonval=${jsonval//$newline/'\''\n'};			
		# fi
		
		#if [[ "$jsonval" =~ $newline ]] ; then
			#jsonval=${jsonval//'\n'/'$newline};	

			#echo "value contains newline: $jsonval";
		#fi
		
		jsonval=${jsonval//$newline/'\n'};
		
		__json.stringify.quote "$jsonval";
	fi
}