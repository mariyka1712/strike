: <<'ronn:markdown'
json(3) -- JSON manipulation
=============================================

## SYNOPSIS

An experimental module for parsing and stringifying JSON data.

## DESCRIPTION

The json(3) module adds methods for parsing and creating JSON documents.

## USAGE

	require 'json';
	
	# parse a json document
	json.parse < "${program_dirs[root]}/package.json";
	json.print;
	
	# parse a json string
	json.parse <<< '{ "data": "value" }';
	json.print;	
	
	# clean up parsed json data
	json.clean;

## BUGS

**json** is written in bash and depends upon `bash` >= 4.

The json(3) module is derived from json-sh(1).

## COPYRIGHT

**json** is copyright (c) 2012 muji <http://xpm.io>

## SEE ALSO

strike(7)
ronn:markdown

# TODO: add array _length property so arrays can be iterated?

# global json document data
declare -Agx json_doc;

function json.parse {
	set +o errexit;	
	set +o nounset;
	
	json.clean;
	
	# run the process subsititution in this manner
	# to block until the parsing is complete
	while read line
		do
			#echo "line: $line";
			
			# available outside the loop
			# because it does NOT run in a subshell
			local IFS="=";
			while read key value
				do
					#strip out the double quotes from string values
					value=$( sed "s/^\([\"']\)\(.*\)\1\$/\2/g" <<< "$value" );
					key=${key##json_};
					
					# skip any array/object definitions
					# as child elements should already by parsed
					if [[ "$value" =~ ^(\[|{) ]]; then
						continue;
					fi
					
					# echo "got key: $key";
					# echo "got value: $value";
					
					if [ ! -z "$key" ]; then
						# store the value in the json_doc associative array
						json_doc["$key"]="$value";
					fi
			done <<< "$line";
			
			#global=3D": Available outside the loop.";
	done < <( __json_tokenize <&0 > >(__json_start) );
}

function json.print {
	local key val;
	for key in "${!json_doc[@]}"
		do
			val="${json_doc["$key"]}";
			console.log "${key}=${val}";
	done
}

function json.clean {
	local key;
	# clean any existing data
	for key in "${!json_doc[@]}";
		do
			unset json_doc["$key"];
	done
}

######################################################################
#
#	PRIVATE METHODS
#
######################################################################

function __json_tokenize {
	local ESCAPE='(\\[^u[:cntrl:]]|\\u[0-9a-fA-F]{4})'
	local CHAR='[^[:cntrl:]"\\]'
	local STRING="\"$CHAR*($ESCAPE$CHAR*)*\""
	local NUMBER='-?(0|[1-9][0-9]*)([.][0-9]*)?([eE][+-]?[0-9]*)?'
	local KEYWORD='null|false|true'
	local SPACE='[[:space:]]+'
	egrep -ao "$STRING|$NUMBER|$KEYWORD|$SPACE|." --color=never | egrep -v "^$SPACE$"  # eat whitespace
}

function __json_start {
	read -r token
	__json_parse_value
	read -r token
	case "$token" in
		'') ;;
		*) __json_throw "EXPECTED EOF GOT $token" ;;
	esac
}

function __json_parse_value {
	local jpath="${1:+$1,}$2"
	case "$token" in
		'{') __json_parse_object "$jpath" ;;
		'[') __json_parse_array  "$jpath" ;;
		# At this point, the only valid single-character tokens are digits.
		''|[^0-9]) __json_throw "EXPECTED value GOT ${token:-EOF}" ;;
		*) value=${token} ;;
	esac

	# printf "[%s]\t%s\n" "$jpath" "$value";
	
	if [[ ! "$value" =~ /^{/ ]] && [[ ! "$value" =~ /^[/ ]]; then
		local key=${jpath};
		local val=${value};
		eval key=json_\$$key;
		#switch the commas for underscores
		key=${key//,/_};
		#ensure we don't get double underscores
		key=${key//__/_};
		if [ "$key" != 'json_$' ]; then
			echo "${key}=${val}";
		fi
	fi
}

function __json_parse_object {
	local key
	local obj=''
	read -r token
	case "$token" in
		'}') ;;
		*)
		while :
			do
				case "$token" in
					'"'*'"') key=$token ;;
					*) __json_throw "EXPECTED string GOT ${token:-EOF}" ;;
				esac
				read -r token
				case "$token" in
					':') ;;
					*) __json_throw "EXPECTED : GOT ${token:-EOF}" ;;
				esac
				read -r token
				__json_parse_value "$1" "$key"
				obj="$obj$key:$value"		 
				read -r token
				case "$token" in
					'}') break ;;
					',') obj="$obj," ;;
					*) __json_throw "EXPECTED , or } GOT ${token:-EOF}" ;;
				esac
				read -r token
		done
		;;
	esac
	value=`printf '{%s}' "$obj"`;
}

function __json_parse_array {
	local index=0
	local ary=''
	read -r token
	case "$token" in
		']') ;;
		*)
			while :
				do
					__json_parse_value "$1" "$index";
					let index=$index+1;
					ary="$ary""$value";
					read -r token;
					case "$token" in
						']') break ;;
						',') ary="$ary," ;;
						*) __json_throw "EXPECTED , or ] GOT ${token:-EOF}" ;;
					esac
					read -r token;
			done
		;;
	esac
	value=`printf '[%s]' "$ary"`;
}

function __json_throw {
	console.throw "$*";
	exit 1;
}