: <<'ronn:markdown'
json(3) -- JSON manipulation
=============================================

## SYNOPSIS

An experimental module for parsing and stringifying JSON data.

## DESCRIPTION

The json(3) module adds methods for parsing and creating JSON documents.

## USAGE

Parsing JSON data can be from a file, string or variable. After parsing the JSON data the parsed data is available on the global `json_doc` associative array. Use the `json.print` method to quickly inspect the contents of the parsed data.

	require 'json';
	
	# parse a json document
	json.parse < "${process_dirs[root]}/package.json";
	json.print;
	
	# parse a json string
	json.parse <<< '{ "data": "value" }';
	json.print;
	
	# clean up parsed json data
	json.clean;
	
Converting to JSON is achieved using references to variable names and afterwards the JSON string is available in the global `json_str` variable. Use the `json.string` method to print the JSON string data.

	require 'json';

	toJSON() {
		declare -A doc;
		doc[key]="value";
		doc[greeting]="hello world";
		# doc is the *name* of the variable to stringify
		json.stringify <<< "doc";
		# print the result
		json.string;
	}
	toJSON;

## BUGS

**json** is written in bash and depends upon `bash` >= 4.

The json(3) module is derived from json-sh(1).

## COPYRIGHT

**json** is copyright (c) 2012 muji <http://xpm.io>

## SEE ALSO

strike(7)
ronn:markdown

# set -- $(date)
# echo $*

# TODO: add array _length property so arrays can be iterated?

# TODO: move to the global variable file
# global json document data
declare -Agx json_doc;

# holds the last result of calling json.stringify
declare -gx json_str;

# regexp for number matching
declare -g json_number_regexp="^-?[0-9]+((\.[0-9]+)?([eE][-+]?[0-9]+)?)?$";

function json.parse {
	
	# TODO: remove this?
	set +o errexit;
	#set +o nounset;
	
	json.clean;
	
	local key value;
	local root_type;
	
	# run the process subsititution in this manner
	# to block until the parsing is complete
	while read line
		do
			# echo "line: $line";
			
			#echo "got root type: $json_root_type";
			
			# available outside the loop
			# because it does NOT run in a subshell
			local IFS="=";
			while read key value
				do
					#strip out the double quotes from string values
					value=$( sed "s/^\([\"']\)\(.*\)\1\$/\2/g" <<< "$value" );
					key=${key##json_};
					
					if [ "$key" == "root_type" ]; then
						
						root_type="$value";
						continue;
					fi
					
					#echo "got root type: $root_type";
					
					# skip any array/object definitions
					# as child elements should already by parsed
					if [[ "$value" =~ ^(\[|{) ]]; then
						continue;
					fi
					
					# echo "got key: $key";
					# echo "got value: $value";
					
					if [ ! -z "$key" ]; then
						# store the value in the json_doc associative array
						json_doc["$key"]="$value";
					fi
			done <<< "$line";
	done < <( __json_tokenize <&0 > >(__json_start) );
}

# TODO: add error handling for this method
function json.stringify {
	local json="";
	
	local objstart="{";
	local objend="}";
	
	local arrstart="[";
	local arrend="]";
	
	local newline="
";
	local pretty=0;
	local space=' ';
	local indent="";
	local depth=0;
	
	if [ $# -gt 0 ] && [ "$1" == "--pretty" ]; then
		pretty=1;
		local indent_repeat="${2:-2}";
		space=${3:-$space};
		string.repeat "${space}" "${indent_repeat}";
		indent="$_result";
		
		objstart="${objstart}${newline}";
		objend="${newline}${objend}";
		
		arrstart="${arrstart}${newline}";
		arrend="${newline}${arrend}";
	fi
	
	# this allows us to accept options and read from stdin
	# with positional parameter expansion
	if [ ! -t 0 ]; then
		# read in stdin
		read -a stdin;
		# expand stdin data to positional parameters
		set -- $( echo "${stdin[@]}" );
	fi
	
	local json_data="${1:-}";
	if [ -z "$json_data" ]; then
		console.warn "invalid json.stringify call, usage: json.stringify <<< \"varname\"";
		return 1;
	fi
	
	#json_string="";
	
	if [ ! -z "$json_data" ]; then
		local value;
		# array.is.array? "$json_data";
		# local isarray="$_result";
		# array.is.assoc? "$json_data";
		# local isassoc="$_result";
		if array.is.array? "$json_data" || array.is.assoc? "$json_data"; then
			__json_stringify_object "$json_data";
		else
			# if [ $isassoc -eq 0 ]; then
			# 	eval length="\${#$json_data[@]}";
			# 	if [ $length -gt 0 ]; then
			# 		__json_stringify_object "$json_data";
			# 	fi
			# else
				variable.get "$json_data";
				value="$_result";
				if [ ! -z "$value" ]; then
					__json_stringify_value "$value";
					json="$_result";
				else
					json="{}";
				fi
			# fi
		fi
	else
		json="{}";
	fi
	if [ ! -z "$json" ]; then
		json_str="$json";
	fi
}

function json.print {
	local key val;
	for key in "${!json_doc[@]}"
		do
			val="${json_doc["$key"]}";
			console.log "${key}=${val}";
	done
}

function json.string {
	local str="${json_str:-}";
	console.log "$str";
}

function json.clean {
	local key;
	# clean any existing data
	for key in "${!json_doc[@]}";
		do
			unset json_doc["$key"];
	done
}

######################################################################
#
#	PRIVATE METHODS
#
######################################################################

function __json_stringify_array {
	json="${json}${arrstart}";
	local json_data="$1";
	local key value;
	eval keys="\${!$json_data[@]}";	
	for key in $keys
		do
			eval value="\${$json_data[$key]}";
			# encode the value
			__json_stringify_value "$value";
			json="${json}${indent}${_result},";
			if [ $pretty -eq 1 ]; then
				json="${json}${newline}";
			fi
	done
	json="${json%$newline}";
	json="${json%,}";
	json="${json}${arrend}";

	# add to main output
	#json="${json}${obj}";
}

function __json_stringify_object {
	local json_data="$1";
	eval keys="\${!$json_data[@]}";
	
	# if all keys are numeric, treat as an array
	if [[ "$keys" =~ ^([0-9]+ ?)+$ ]]; then
		__json_stringify_array "$json_data";
		return 0;
	fi
	
	# FIXME: implement handling of arrays of objects
	
	# deal with arrays of objects
	# declare -A array;
	# local i=0;
	# for key in ${keys[@]}
	# 	do
	# 		if [[ "$key" =~ ^[0-9]+\. ]]; then
	# 			eval value="\${$json_data[$key]}";				
	# 			array[ "$key" ]="$value";
	# 			echo "GOT NUMERIC ONLY KEY USING!!! : $key";
	# 			# attempt to use array
	# 			#__json_stringify_array "$json_data";
	# 			unset keys[$i];
	# 		fi
	# 		: $((i++));
	# done
	# 
	# if [ ${#array[@]} -gt 0 ]; then
	# 	echo "array data : ${!array[@]} : ${array[@]}";
	# fi
	
	# if [ ${#keys[@]} -gt 0 ]; then
	# 	return 0;
	# fi
	
	json="${json}${objstart}";
	local key value;
	
	# deal with top-level properties of this object
	for key in $keys
		do
			# not a nested property
			if [[ ! "$key" =~ \. ]]; then
				eval value="\${$json_data[$key]}";
				__json_add_key_value "$key" "$value";
			fi
	done
	
	# deal with nested properties
	local k match nk nv ak;	
	for key in $keys
		do
			# if [[ "$key" =~ ^[0-9]+\. ]]; then
			# 	echo "GOT NUMERIC ONLY KEY USING UNDERSCORE!!! : $keys";
			# 	#k="_$k";
			# 	# attempt to use array
			# 	__json_stringify_array "$json_data";
			# else
				# got a nested dot-style reference
				if [[ "$key" =~ \. ]]; then
					# FIXME: handle arrays of objects !!!
					k=${key%%.*};
					
					# sane bash compatible variable name
					k=${k//-/_};
					
					eval "declare -A $k";
					match="^$k";
					for nk in $keys
						do
							if [[ "$nk" =~ $match ]]; then
								eval nv="\${$json_data[$nk]}";
								ak=${nk#*.};
								eval "${k}[\"$ak\"]=\"$nv\"";
							fi
					done
					json="${json}\"$k\":";
					__json_stringify_object "$k";
					json="${json}${objend}";
					return 0;
				fi
			#fi
	done
	json="${json%$newline}";
	json="${json%,}";
	json="${json}${objend}";
}

function __json_add_key_value {
	# quote the key
	__json_stringify_quote "$1";
	json="${json}${indent}${_result}:";
	
	# encode the value
	__json_stringify_value "$2";
	json="${json}${_result},";
	if [ $pretty -eq 1 ]; then
		json="${json}${newline}";
	fi
}

function __json_stringify_quote {
	# quoted string
	_result="\"$1\"";
}

function __json_stringify_value {
	_result="";
	# unquoted value for null, true, false and numbers
	if [ "$1" == "null" ] || [ "$1" == true ] || [ "$1" == false ] || [[ "$1" =~ $json_number_regexp ]]; then
		_result="$1";
	else
		
		# escape special regex characters using grep !?
		# grep -v -F "$data_line" "$data_dir"
		
		local jsonval="$1";
		jsonval=${jsonval//$newline/'\\\''\n'};
		__json_stringify_quote "$jsonval";
	fi
}

function __json_tokenize {
	local ESCAPE='(\\[^u[:cntrl:]]|\\u[0-9a-fA-F]{4})'
	local CHAR='[^[:cntrl:]"\\]'
	local STRING="\"$CHAR*($ESCAPE$CHAR*)*\""
	local NUMBER='-?(0|[1-9][0-9]*)([.][0-9]*)?([eE][+-]?[0-9]*)?'
	local KEYWORD='null|false|true'
	local SPACE='[[:space:]]+'
	egrep -ao "$STRING|$NUMBER|$KEYWORD|$SPACE|." --color=never | egrep -v "^$SPACE$"  # eat whitespace
}

function __json_start {
	read -r token
	
	##echo "got root token: $token" >&2;
	
	local json_root_type="object";
	
	if [ "$token" == "[" ]; then
		json_root_type="array";
	elif [[ "$token" =~ ^[0-9]+$ ]]; then
		## echo "setting number root type!!!: $token" >&2;
		json_root_type="number";
	fi
	
	echo "json_root_type=\"$json_root_type\"";
	
	__json_parse_value;
	read -r token
	case "$token" in
		'') ;;
		*) __json_throw "EXPECTED EOF GOT $token" ;;
	esac
}

function __json_parse_value {
	local jpath="${1:+$1,}${2:-}"
	case "$token" in
		'{') __json_parse_object "$jpath" ;;
		'[') __json_parse_array  "$jpath" ;;
		# At this point, the only valid single-character tokens are digits.
		''|[^0-9]) __json_throw "EXPECTED value GOT ${token:-EOF}" ;;
		*) value=${token} ;;
	esac

	# printf "[%s]\t%s\n" "$jpath" "$value";
	
	if [[ ! "$value" =~ /^{/ ]] && [[ ! "$value" =~ /^[/ ]]; then
		local key=${jpath};
		local val=${value};
		eval key=json_\$$key;
		#switch the commas for dot-style notation
		key=${key//,/.};
		if [ "$key" != 'json_$' ]; then
			echo "${key}=${val}";
		fi
	fi
}

function __json_parse_object {
	local key
	local obj=''
	read -r token
	case "$token" in
		'}') ;;
		*)
		while :
			do
				case "$token" in
					'"'*'"') key=$token ;;
					*) __json_throw "EXPECTED string GOT ${token:-EOF}" ;;
				esac
				read -r token
				case "$token" in
					':') ;;
					*) __json_throw "EXPECTED : GOT ${token:-EOF}" ;;
				esac
				read -r token
				__json_parse_value "$1" "$key"
				obj="$obj$key:$value"		 
				read -r token
				case "$token" in
					'}') break ;;
					',') obj="$obj," ;;
					*) __json_throw "EXPECTED , or } GOT ${token:-EOF}" ;;
				esac
				read -r token
		done
		;;
	esac
	value=`printf '{%s}' "$obj"`;
}

function __json_parse_array {
	local index=0
	local ary=''
	read -r token
	case "$token" in
		']') ;;
		*)
			while :
				do
					__json_parse_value "$1" "$index";
					let index=$index+1;
					ary="$ary""$value";
					read -r token;
					case "$token" in
						']') break ;;
						',') ary="$ary," ;;
						*) __json_throw "EXPECTED , or ] GOT ${token:-EOF}" ;;
					esac
					read -r token;
			done
		;;
	esac
	value=`printf '[%s]' "$ary"`;
}

function __json_throw {
	console.throw "$*";
	exit 1;
}