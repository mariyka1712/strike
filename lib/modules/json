
#declare -A json;
#json[ 'result' ]="whatever";

# TODO: add array _length property so arrays can be iterated?

declare -Agx json_doc;

throw () {
  #echo "$*" >&2
console.throw "$*";
  exit 1
}

tokenize () {
  local ESCAPE='(\\[^u[:cntrl:]]|\\u[0-9a-fA-F]{4})'
  local CHAR='[^[:cntrl:]"\\]'
  local STRING="\"$CHAR*($ESCAPE$CHAR*)*\""
  local NUMBER='-?(0|[1-9][0-9]*)([.][0-9]*)?([eE][+-]?[0-9]*)?'
  local KEYWORD='null|false|true'
  local SPACE='[[:space:]]+'
  egrep -ao "$STRING|$NUMBER|$KEYWORD|$SPACE|." --color=never | egrep -v "^$SPACE$"  # eat whitespace
}

parse_array () {
  local index=0
  local ary=''
  read -r token
  case "$token" in
    ']') ;;
    *)
      while :
      do
        parse_value "$1" "$index"
        let index=$index+1
        ary="$ary""$value" 
        read -r token
        case "$token" in
          ']') break ;;
          ',') ary="$ary," ;;
          *) throw "EXPECTED , or ] GOT ${token:-EOF}" ;;
        esac
        read -r token
      done
      ;;
  esac
  value=`printf '[%s]' "$ary"`
}

parse_object () {
  local key
  local obj=''
  read -r token
  case "$token" in
    '}') ;;
    *)
      while :
      do
        case "$token" in
          '"'*'"') key=$token ;;
          *) throw "EXPECTED string GOT ${token:-EOF}" ;;
        esac
        read -r token
        case "$token" in
          ':') ;;
          *) throw "EXPECTED : GOT ${token:-EOF}" ;;
        esac
        read -r token
        parse_value "$1" "$key"
        obj="$obj$key:$value"        
        read -r token
        case "$token" in
          '}') break ;;
          ',') obj="$obj," ;;
          *) throw "EXPECTED , or } GOT ${token:-EOF}" ;;
        esac
        read -r token
      done
    ;;
  esac
  value=`printf '{%s}' "$obj"`
}

parse_value () {
	
	#echo "got parse_value opts : $*";
	
  local jpath="${1:+$1,}$2"
  case "$token" in
    '{') parse_object "$jpath" ;;
    '[') parse_array  "$jpath" ;;
    # At this point, the only valid single-character tokens are digits.
    ''|[^0-9]) throw "EXPECTED value GOT ${token:-EOF}" ;;
    *) value=${token} ;;
  esac
  #printf "[%s]\t%s\n" "$jpath" "$value";
	#="$value";

	#"$jpath"="$"$value;
	
	#f=( "$jpath" );
	#subst="$f[@]"
	#echo "got: ${!subst}"	
	
	#eval echo -n "${!key}=$jpath";
	
	if [[ ! "$value" =~ /^{/ ]] && [[ ! "$value" =~ /^[/ ]]; then
		local key=${jpath};
		local val=${value};
		eval key=json_\$$key;
		#val="$value";
	
		#switch the commas for underscores
		key=${key//,/_};
		#ensure we don't get double underscores
		key=${key//__/_};
	
		if [ "$key" != 'json_$' ]; then
			#val=$(printf %q "$val");
			echo "${key}=${val}";
		fi
	
		#echo "jpath :: $key :: ${!key}";
	
		#echo "got total rows : ${json_total_rows:-}";
	
	fi
}

json_start () {
  read -r token
  parse_value
  read -r token
  case "$token" in
    '') ;;
    *) throw "EXPECTED EOF GOT $token" ;;
  esac
}

json.parse ()
{
	set +o errexit;	
	set +o nounset;
	
	# clean any existing data
	for key in "${!json_doc[@]}";
		do
			unset json_doc["$key"];
	done
	
	# run the process subsititution in this manner
	# to block until the parsing is complete
	while read line
		do
			#echo "line: $line";
			
			# available outside the loop
			# because it does NOT run in a subshell
			local IFS="=";	
			while read key value
				do
					#strip out the double quotes from string values
					value=$( sed "s/^\([\"']\)\(.*\)\1\$/\2/g" <<< "$value" );
					key=${key##json_};
					
					# skip any array/object definitions
					# as child elements should already by parsed
					if [[ "$value" =~ ^(\[|{) ]]; then
						continue;
					fi
					
					#echo "got key: $key";
					#echo "got value: $value";
					
					# store the value in the json_doc associative array
					json_doc["$key"]="$value";
			done <<< "$line";
			
			#global=3D": Available outside the loop.";
	done < <( tokenize <&0 > >(json_start) );
}

#if [ $0 = $BASH_SOURCE ];
#then
#  tokenize | parse
#fi