declare -gx module="${module:-}";
declare -gx module_method;
declare -agx module_options;

declare -gx option_verbose;
declare -gx option_quiet;

declare -gx options_minimum=0;
declare -gx options_expects_command="";
#quit = quit on fail
#warn = show warning
#info = show info
declare -gx options_fail_mode="quit";
#try to print program help on options validation fail
declare -gxi options_fail_help=0;
declare -gxi options_map_command_method=0;

declare -gx options_command_method;

declare -Agx options_fail_messages;
options_fail_messages["too_few_options"]="too few options";
options_fail_messages["invalid_command"]="invalid command %s";

declare -agx options_types=( flag option );

declare options_map_last;

#declare -Agx options_flags;

function options_add {
	local optiontype="${1:-}";
	local shortname="${2:-}";
	local fullname="${3:-}";
	local description="${4:-}";
	
	#options_flags=( "${options_flags[@]:-}" );
	
	# TODO: validate option type
	
	local varname="$fullname";
	
	# echo "adding flag prefix: $shortname";
	# echo "adding flag prefix: $fullname";
	# echo "adding flag prefix: $description";
	
	local name="options_${optiontype}_${varname}_shortname";
	local value="$shortname";
	variable_set "$name" "$value";
	
	name="options_${optiontype}_${varname}_fullname";
	value="$fullname";
	variable_set "$name" "$value";
	
	name="options_${optiontype}_${varname}_description";
	value="$description";
	variable_set "$name" "$value";
}

function options_validate {
	#shift so the array length is now zero
	if [ $# -gt 0 ] && [ -z $1 ]; then
		#echo "no options specified...";
		shift;
	fi
	
	#echo "after no options shift $#";
	
	if [ $options_minimum -gt 0 ] && [ $# -lt $options_minimum ]; then
		__options_fail "too_few_options";
		return 1;
	fi

	# validate a command option
	if [ ! -z "${options_expects_command:-}" ] && [ ${#options_expects_command[@]} -gt 0 ]; then
		local cmdopt="";
		for cmd in ${options_expects_command[@]}
			do
				#echo "got command to test : $cmd : $1";
				if [ "$cmd" == "$1" ]; then
					cmdopt="$1";
					break;
				fi
		done
	
		#invalid command specified
		if [ -z "$cmdopt" ]; then
			__options_fail "invalid_command" "$1";
		#got valid command
		else
			if [ $options_map_command_method -gt 0 ]; then
				# echo "setting command method...";
				#global method mapped to the command
				options_command_method="$cmdopt";
				# echo "setting command method... $options_command_method";
			fi
		fi
	fi
}

function options_configure {
	option_verbose=0;
	option_quiet=0;
}

function options_parse {
	#validate options
	options_validate "$@";
	
	#echo "parsing configured options...";
	
	local l=$#;
	
	if [ ! -z "${options_map_last:-}" ]; then
		#echo "map last option to a variable...";
		variable_set "$options_map_last" "${@: -1}";
	fi
	
	if [ $options_map_command_method -gt 0 ]; then
		shift;
	fi
	
	local i val;
	for((i = 1;i < l;i++))
		do
			eval val="$"$i;
			#echo "got opt:: $val";
			module_options+=( "$val" );
	done
	
	# while [ "${1:-}" != "" ]; do
	# 	case $1 in
	# 	-h | --help )
	# 		program_help;
	# 		exit 0;
	# 		;;
	# 	* )
	# 		program_help;
	# 		exit 1;
	# 	esac
	# 	shift;
	# done
}

######################################################################
#
#	PRIVATE METHODS
#
######################################################################

function __options_fail {
	local key="$1";
	shift;
	local msg="${options_fail_messages[$key]}";
	local replacements=( "$@" );
	
	#invalid fail mode - force to quit
	if [ "$options_fail_mode" != "quit" ] || [ "$options_fail_mode" != "warn" ] || [ "$options_fail_mode" != "info" ]; then
		options_fail_mode="quit";
	fi
	
	# TODO: reinstate this functionality using the help module!
	#try to output program help
	if [ $options_fail_help -gt 0 ]; then
		#program_help;
	fi
	
	if [ "$options_fail_mode" == "quit" ]; then
		#we need to prepend an exit code
		quit 1 "$msg" "${replacements[@]:-}";
	else
		"$options_fail_mode" "$msg" "${replacements[@]:-}";
	fi
}