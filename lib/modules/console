: <<'ronn:markdown'
console(3) -- console output
=============================================

## SYNOPSIS

Helper methods for printing ANSI formatted output to a terminal and redirecting output to log file(s).

## DESCRIPTION

The console(3) module is a built in module available to all programs. It is responsible for printing messages with optional replacement parameters which are highlighted when the message is printed.

If either stdout or stderr is not a *tty* then formatting of the output message is not performed which means that when redirecting to a file the ANSI sequence is omitted and the string is passed with parameter replacement performed but *no formatting*.

## USAGE

The general syntax for printing output is:

console.info "message to print with %s information" "important";
	
Whereby the `%s` substring in the main message will be highlighted and replaced with the string *important*, generating:

message to print with `important` information
	
## EXIT METHODS

The console(3) module provides methods for exiting the program (optionally with a formatted message).

* `console.success`:

	Marks the program as completed successfully (exiting with a zero exit code) and optionally prints a formatted message.
	
* `console.quit`:

	Exits the program with a non-zero exit code and optional error message. Note that the signature for this method differs from the general syntax for console(3) methods as it expects the first parameter to be the exit code.

## STDOUT

To print to standard output use the following methods.

* `console.info`:

	Prints an informational message.
	
* `console.log`:

	Prints a log message. This method *does not perform any formatting* or print any program (or message type prefix) but does provide parameter replacement. This method is essentially just a wrapper for echo(1) that allows the use of parameter replacement and the log file redirection functionality.
	
## STDERR

To print to standard error use the following methods.

* `console.warn`:

	Prints a warning message.
	
* `console.error`:

	Prints an error message.
	
* `console.throw`:

	Prints an error message followed by a stack trace of the current method call stack.
	
## LOG FILE REDIRECTION

The console(3) module supports redirecting stdout/stderr to log file(s). 

* `console.log.stdout`:

	Redirect stdout to a log file and store stdout in file descriptor #3.
	
* `console.log.stdout.close`:

	Close redirection of stdout, restoring stdout and closing file descriptor #3.
	
* `console.log.stderr`:

	Redirect stderr to a log file and store stderr in file descriptor #4.

* `console.log.stderr.close`:

	Close redirection of stderr, restoring stderr and closing file descriptor #4.
	
## OPTIONS

The console(3) module parses the program options (but does not modify them) looking for the following options:

* `--no-format`:

	Do not perform any ANSI color or formatting modifications to the output.
	
## VARIABLES

See the globals-api(3) documentation.
	
## MISCELLANEOUS

You may also print a stack trace (without any preceeding error message) using the `console.trace` method. Note that this method does not follow the general syntax for console(3) method invocations and accepts no parameters.

## BUGS

The number of replacement parameters must match exactly the number of `%s` occurences in the message otherwise unexpected behaviour will occur.

**console** is written in bash and depends upon `bash` >= 4.

## COPYRIGHT

**console** is copyright (c) 2012 muji <http://xpm.io>

## SEE ALSO

globals-api(3)
ronn:markdown

declare -gx __stdout_log_file="";
declare -gx __stderr_log_file="";

function console.log.stdout {
	touch "$1" || warn "could not create stdout log file %s" "$1";
	if [ -f "$1" ]; then
		__stdout_log_file="$1";		
		# save stdout in file descriptor #3
		exec 3>&1;
		exec 1>> "$1";
	fi
}

function console.log.stdout.close {
	if [ ! -z "$__stdout_log_file" ]; then
		# restore stdout and close file descriptor #3
		exec 1>&3 3>&- || console.warn "no file descriptor for stdout log file";
		__stdout_log_file="";
	fi
}

function console.log.stderr {
	touch "$1" || warn "could not create stderr log file %s" "$1";
	if [ -f "$1" ]; then
		__stderr_log_file="$1";
		# save stderr in file descriptor #4
		exec 4>&2;
		exec 2>> "$1";
	fi
}

function console.log.stderr.close {
	
	# TODO: potential test for an open file descriptor?
	# requires testing cross-platform
	# ls -la /dev/fd/4
	
	if [ ! -z "$__stderr_log_file" ]; then
		# restore stdout and close file descriptor #3
		exec 2>&4 4>&- || console.warn "no file descriptor for stderr log file";
		__stderr_log_file="";
	fi
}

function console.log {
	console.sprintf "${@}";
	msg="$_result";
	echo -e "$msg";
}


######################################################################
#	Colours a message string formatting each replacement as bold.
#
#	$1		The name of the colour function to call.
#	$2		The function to call to highlight each replacement parameter.	
#	$3 		The printf format string.
#	$4-#	The remaining string replacements to be highlighted.
######################################################################
function console.colorize {
	#function used to start the main color
	local start_function="$1";
	#function used to highlight each replacement parameter
	local highlight_function="$2";
	local message="$3";
	local replacements=("${@:3}");
	local output=( "$message" );
	local c=0;	
	for i in "${replacements[@]}"
		do
			if [ $c -ne 0 ]; then
				#highlight each replacement parameter
				eval "$highlight_function" "'$i'";
				local res="$_result";
				eval "$start_function";
				#concatenate together
				res="$res$_result";
				#and push back on to the output data
				output=( "${output[@]}" "$res" );
			fi
			c=$[$c+1];
	done
	#get the overall start
	eval "$start_function";
	local start="$_result";
	
	#always end with a style terminator
	style_terminator;
	local end="$_result";
	
	#perform the replacement on the message template string
	_result=$(printf "${output[@]}");	
	
	#wrap the replaced message with the start and end highlighting
	local full="$start${_result[@]}$end";
	
	#return the output
	_result="$full";
	#echo "got FULL RESULT: $full";
	#echo -e "$full";
	#echo "this is a normal message";
}

######################################################################
#	Performs replacement without performing any highlighting
#	appropriate for output to a non-terminal.
#
#	$1 		The printf format string.
#	$2-@	The remaining string replacements to be highlighted.
######################################################################
function console.sprintf {
	_result=$(printf "${@}");
}

#TODO : integrate this logic so no highlighting is performed when not a terminal
#if [ -t 1 ] ; then echo terminal; fi
#(if [ -t 1 ] ; then echo terminal; fi) | echo

#quits a program with a message and exit code
function console.quit {
	local code="${1:-1}";
	if [ $# -gt 1 ]; then
		local params=("${@:2}");
		console.error "${params[@]}";
	fi
	exit $code;
}

#prints a message with the default output formatting
function print {
	local msg="$1";
	__console_print_program_prefix;
	echo -e "$msg";
}

function __console_print_program_prefix {
	local prefix="[${program_name:-}]";
	local include_prefix=${console_print_program_prefix:-};
	if [ ! -z "$include_prefix" ]; then
		if [ -t 1 ] && [ -z "$console_no_format" ]; then	
			if [ "$prefix" != "" ]; then
				gray "$prefix";
				echo -ne "$_result";
				echo -ne " ";
			fi
		else
			echo -n "$prefix ";
		fi
	fi
}

#exits a program with a success message
function console.success {
	local status="${console_prefixes[$FUNCNAME]}";
	local prefix="$status";
	local msg="";
	if [ -t 1 ] && [ -z "$console_no_format" ]; then
		#get the message prefix
		bold "$status";
		prefix="$_result";

		#highlight the message and parameters
		msgs=( "default_style" "bold" "${@}" );
		console.colorize "${msgs[@]}";
		msg="$_result";
	else
		console.sprintf "${@}";
		msg="$_result";
	fi
	
	#output everything
	__console_print_program_prefix;
	echo -e "$prefix $msg";
	exit 0;
}

function console.ok {
	local status="${console_prefixes[$FUNCNAME]}";
	local prefix="$status";
	local msg="";
	if [ -t 1 ] && [ -z "$console_no_format" ]; then
		#get the message prefix
		bold "$status";
		prefix="$_result";

		#highlight the message and parameters
		msgs=( "default_style" "bold" "${@}" );
		console.colorize "${msgs[@]}";
		msg="$_result";
	else
		console.sprintf "${@}";
		msg="$_result";
	fi
	
	#output everything
	__console_print_program_prefix;
	echo -e "$prefix $msg";
}

#outputs an info message
function console.info {	
	local status="${console_prefixes[$FUNCNAME]}";
	local prefix="$status";
	local msg="";
	if [ -t 1 ] && [ -z "$console_no_format" ]; then
		#get the message prefix
		bold "$status";
		prefix="$_result";

		#highlight the message and parameters
		msgs=( "default_style" "bold" "${@}" );
		console.colorize "${msgs[@]}";
		msg="$_result";
	else
		console.sprintf "${@}";
		msg="$_result";
	fi
	
	#output everything
	__console_print_program_prefix;
	echo -e "$prefix $msg";
}

#outputs an important info message
# function important {
# 	local status="[info]";
# 	local prefix="$status";
# 	local msg="";
# 	if [ -t 1 ] && [ -z "$console_no_format" ]; then
# 		#get the message prefix
# 		bold "$status";
# 		prefix="$_result";
# 
# 		#highlight the message and parameters
# 		msgs=( "start_blue" "boldblue" "${@}" );
# 		console.colorize "${msgs[@]}";
# 		msg="$_result";
# 	else
# 		console.sprintf "${@}";
# 		msg="$_result";
# 	fi
# 	
# 	#output everything
# 	__console_print_program_prefix;
# 	echo -e "$prefix $msg";
# }

#outputs a usage message
# function usage {
# 	local status="[usage]";
# 	local prefix="$status";
# 	local msg="";
# 	if [ -t 1 ] && [ -z "$console_no_format" ]; then
# 		#get the message prefix
# 		bold "$status";
# 		prefix="$_result";
# 
# 		#highlight the message and parameters
# 		msgs=( "default_style" "bold" "${@}" );
# 		console.colorize "${msgs[@]}";
# 		msg="$_result";
# 	else
# 		console.sprintf "${@}";
# 		msg="$_result";
# 	fi
# 	
# 	#output everything
# 	__console_print_program_prefix;
# 	echo -e "$prefix $msg";
# }

#output a usage description with no formatting
# function usage_description {
# 	local status="[usage]";
# 	local prefix="$status";
# 	local msg="";
# 	if [ -t 1 ] && [ -z "$console_no_format" ]; then
# 		#get the message prefix
# 		bold "$status";
# 		prefix="$_result";
# 
# 		#no highlight for usage descriptions
# 		msgs=( "default_style" "default_style" "${@}" );
# 		console.colorize "${msgs[@]}";
# 		msg="$_result";
# 	else
# 		console.sprintf "${@}";
# 		msg="$_result";
# 	fi
# 	
# 	#get the message prefix
# 	#bold "[usage]";
# 	#local prefix="$_result";
# 	
# 	#highlight the message and parameters
# 	#msgs=( "default_style" "default_style" "${@}" );
# 	#console.colorize "${msgs[@]}";
# 	#local msg="$_result";
# 	
# 	#output everything
# 	__console_print_program_prefix;
# 	echo -e "$prefix $msg";
# }

#outputs a warning message
function console.warn {	
	local status="${console_prefixes[$FUNCNAME]}";
	local prefix="$status";
	local msg="";
	if [ -t 2 ] && [ -z "$console_no_format" ]; then
		#get the message prefix
		boldpurple "$status";
		prefix="$_result";

		#highlight the message and parameters
		msgs=( "start_purple" "boldpurple" "${@}" );
		console.colorize "${msgs[@]}";
		msg="$_result";
	else
		console.sprintf "${@}";
		msg="$_result";
	fi
	
	#output everything
	__console_print_program_prefix;
	echo -e "$prefix $msg" >&2;
}

#outputs an error message
function console.error {
	local status="${console_prefixes[$FUNCNAME]}";
	local prefix="$status";
	local msg="";
	if [ -t 2 ] && [ -z "$console_no_format" ]; then
		#get the message prefix
		boldred "$status";
		prefix="$_result";

		#highlight the message and parameters
		msgs=( "start_red" "boldred" "${@}" );
		console.colorize "${msgs[@]}";
		msg="$_result";
	else
		console.sprintf "${@}";
		msg="$_result";
	fi
	
	#output everything
	__console_print_program_prefix;
	echo -e "$prefix $msg" >&2;
}

# generates a stack trace
function console.trace {
	local offset="${1:-0}";
	local frame=$offset line;
	local data=( $( caller $frame ) );
	while [ "${#data[@]}" -gt 0 ]; do
		console.error "%s:%s %s" "${data[2]}" "${data[0]}" "${data[1]}";
		((frame++));
		data=( $( caller $frame ) );
	done
	return 0;
}

# throws an error message and prints the stack trace
function console.throw {
	local message="${1:-Unknown error}";
	#echo "throw message: $message";
	console.error "$message";
	console.trace 1;
}

# inspect the program options looking for a --no-format option
function console.parse {
	local l=$#;
	local i val;
	for((i = 1;i < l+1;i++))
		do
			eval val="$"$i;
			if [ "$val" == "--no-format" ]; then
				console_no_format="on";
			fi
	done
}
console.parse "$@";

# must set this option so that aliases are expanded
shopt -s expand_aliases;

# set up aliases for backward compatability
# WARNING: these aliases will be removed in a future
# version and you should use console.info etc.
alias "info=console.info";
alias "error=console.error";
alias "warn=console.warn";
alias "success=console.success";
alias "quit=console.quit";

# info "this is an info message";
# error "this is an error message";
# warn "this is a warning";

#quit;
#quit 127;
#quit 127 "this is an error message";
#success "success";

#alias;