: <<'ronn:markdown'
console(3) -- console output module
=============================================

## SYNOPSIS

	console [command] [options...] message [replacements...]

## DESCRIPTION

Helper methods for printing ANSI formatted output to a terminal and redirecting output to log file(s).

The console(3) module is a built in module available to all programs. It is responsible for printing messages with optional replacement parameters which are highlighted when the message is printed.

If either stdout or stderr is not a *tty* then formatting of the output message is not performed which means that when redirecting to a file the ANSI sequence is omitted and the string is passed with parameter replacement performed but no formatting.

## OPTIONS

* `-1`:

Print to *stdout*.

* `-2`:

Print to *stderr*.

* `--color=[color]`:

Set *color* as the foreground color.

* `--background=[color]`:

Set *color* as the background color.

* `--prefix=[prefix]`:

Prepend *prefix* to the message.

* `--suffix=[suffix]`:

Append *suffix* to the message.

* `--no-prefix`:

Do not print the prefix.

* `--readline`:

Use escape sequences compatible with passing to `read -ep`. This allows formatting to be applied to interactive prompts using `read`. When this option is used nothing is printed but the result of formatting the message is assigned to the `PS9` variable.

* `--cross`:

Append a single space and a cross character to the message.

* `--tick`:

Append a single space and a tick character to the message.

* `--debug`:

Do not interpret ANSI sequences, print them.

* `--`:

Stop processing options. Use the `--` option to signal that option processing should stop so that message and replacement values that begin with a hyphen may be processed.

## USAGE

The general syntax for printing output is:

console info "message to print with %s information" "important";
	
Whereby the `%s` substring in the main message will be highlighted and replaced with the string *important*, generating:

message to print with `important` information

## STDOUT

To print to standard output use the following methods.

* `console print`:

	Print a message with no prefix.

* `console info`:

	Print an info message.
	
* `console.log`:

	Print a log message.
	
## STDERR

To print to standard error use the following methods.

* `console warn`:

	Print a warning message.
	
* `console error`:

	Print an error message.
	
* `console throw`:

	Print an error message followed by a stack trace of the current method call stack.
	
## LOG FILE REDIRECTION

The console(3) module supports redirecting stdout/stderr to log file(s). 

* `console.log.stdout`:

	Redirect stdout to a log file and store stdout in file descriptor #3.
	
* `console.log.stdout.close`:

	Close redirection of stdout, restoring stdout and closing file descriptor #3.
	
* `console.log.stderr`:

	Redirect stderr to a log file and store stderr in file descriptor #4.

* `console.log.stderr.close`:

	Close redirection of stderr, restoring stderr and closing file descriptor #4.
	
## EXIT METHODS

The console(3) module provides methods for exiting the program (optionally with a formatted message).

* `console success`:

	Marks the program as completed successfully (exiting with a zero exit code) and optionally prints a formatted message.

* `console quit`:

	Exits the program with a non-zero exit code and optional error message. Note that the signature for this method differs from the general syntax for console(3) methods as it expects the first parameter to be the exit code.
	
## OPTIONS

The console(3) module parses the program options (but does not modify them) looking for the following options:

* `--no-color`:

	Do not perform any ANSI color or formatting modifications to the output.
	
# ITERM2

It is recommended that users of iTerm2 uncheck the *Draw bold text in bright colors* option in *Profiles > Text* for highlighted replacement values to appear consistently with the main message colour.
	
## VARIABLES

See the globals-api(3) documentation.

## BUGS

The number of replacement parameters must match exactly the number of `%s` occurences in the message otherwise unexpected behaviour will occur.

**console** is written in bash and depends upon `bash` >= 4.2.

## COPYRIGHT

**console** is copyright (c) 2012 muji <http://xpm.io>

## SEE ALSO

sprintf(3), globals-api(3)
ronn:markdown

# TODO: deprecated
declare -g __stdout_log_file="";
declare -g __stderr_log_file="";

# main console entry point
console() {
	# list of available commands
	local namespace="console.commands";
	local cmd="";
	local commands=(
		info
		warn
		error
		throw
		debug
		log
		header
		trace
		quit
		success
		print
		ok
		notok
		prompt
	);
	
	# exit code
	local code=1;
	if array.contains? "$1" "${commands[@]}"; then
		cmd="$1";
		prefix="${console_prefixes[$cmd]:-}";
		shift;
		
		if [ "$cmd" == quit ] && [ $# -gt 0 ]; then
			code="$1";
			shift;
		fi
	fi
	
	if [ -n "${cmd}" ]; then
		if ! method.exists? "${namespace}.${cmd}"; then
			console quit 2 "invalid command %s" "${cmd}";
		fi
		delegate "$namespace" "$cmd" "$@";
	fi
}

## COMMANDS

# print the generic message header
console.commands.header() {
	sprintf "$@" "${header}";
}

# print a message with no prefix
console.commands.print() {
	sprintf --no-prefix "$@";
}

# print a prompt with no newline
# and a space as the suffix
console.commands.prompt() {
	sprintf --no-newline --readline \
		--suffix="${console_prompt_suffix:-}" "$@";
}

# print a log message with a prefix
console.commands.log() {
	sprintf --prefix="${console_prefixes[log]}" "$@";
}

# print an ok message with a prefix
console.commands.ok() {
	sprintf --suffix="${characters[tick]}" \
		--prefix="${console_prefixes[ok]}" "$@";
}

# print an info message with a prefix
console.commands.info() {
	sprintf --prefix="${console_prefixes[info]}" "$@";
}

## ERROR COMMANDS

# print a debug message to stderr
console.commands.debug() {
	sprintf -2 --color=cyan --prefix="${console_prefixes[debug]}" "$@";
}

# print a not ok message to stderr
console.commands.notok() {
	sprintf -2 --color=red --suffix="${characters[cross]}" \
		--prefix="${console_prefixes[notok]}" "$@";
}

# print an error message to stderr
console.commands.error() {
	sprintf -2 --color=red --prefix="${console_prefixes[error]}" "$@";
}

# print a warning message to stderr
console.commands.warn() {
	sprintf -2 --color=magenta --prefix="${console_prefixes[warn]}" "$@";
}

# throw a stack trace with
# preceeding error message
console.commands.throw() {
	local message="${1:-Unknown error}";
	console error "$message";
	console trace 1;
}

# print a stack trace as a series of error messages
console.commands.trace() {
	local offset="${1:-0}";
	local frame="$offset";
	local line;
	local data=( $( caller $frame ) );
	while [ "${#data[@]}" -gt 0 ]; do
		sprintf -2 --color=red --prefix="${console_prefixes[trace]}" \
			"%s:%s %s" "${data[2]}" "${data[0]}" "${data[1]}";
		: $((frame++));
		data=( $( caller $frame ) );
	done
}

# exit with a failure
console.commands.quit() {
	if [ $# -gt 0 ]; then
		console notok "$@";
	fi
	exit $code;
}

# exit
console.commands.success() {
	if [ $# -gt 0 ]; then
		console ok "$@";
	fi
	exit 0;
}

# inspect the program options 
# looking for a --no-color option
console.parse() {
	local l=$#;
	local i val;
	for((i = 1;i < l+1;i++))
		do
			eval val="$"$i;
			if [ "$val" == "${console_no_color_option}" ]; then
				console_no_color=true;
			fi
	done
}
console.parse "$@";

# redirect stderr to console error
# so that all error messages are highlighted
# wherever possible
# NOTE: this must be done before setting noclobber
console.shell.error() {
	if [ -t 2 ]; then
		echo -e "\033[1;31m$line\033[0m";
	else
		echo "$line";
	fi
}

# exec 2> >( while read line; do console.shell.error >&2; done);

# exec 2> >(while read line; do echo -e "\033[1;31m[bash] $line\033[0m" >&2; done)

































# DEPRECATED

function console.log.stdout {
	touch "$1" || warn "could not create stdout log file %s" "$1";
	if [ -f "$1" ]; then
		__stdout_log_file="$1";		
		# save stdout in file descriptor #3
		exec 3>&1;
		exec 1>> "$1";
	fi
}

function console.log.stdout.close {
	if [ ! -z "$__stdout_log_file" ]; then
		# restore stdout and close file descriptor #3
		exec 1>&3 3>&- || console warn "no file descriptor for stdout log file";
		__stdout_log_file="";
	fi
}

function console.log.stderr {
	touch "$1" || warn "could not create stderr log file %s" "$1";
	if [ -f "$1" ]; then
		__stderr_log_file="$1";
		# save stderr in file descriptor #4
		exec 4>&2;
		exec 2>> "$1";
	fi
}

function console.log.stderr.close {
	
	# TODO: potential test for an open file descriptor?
	# requires testing cross-platform
	# ls -la /dev/fd/4
	
	if [ ! -z "$__stderr_log_file" ]; then
		# restore stdout and close file descriptor #3
		exec 2>&4 4>&- || console warn "no file descriptor for stderr log file";
		__stderr_log_file="";
	fi
}

# must set this option so that aliases are expanded
shopt -s expand_aliases;

# set up aliases for backward compatability
# WARNING: these aliases will be removed in a future
# version and you should use console info etc.
alias "console.info=console info";
alias "console.error=console error";
alias "console.warn=console warn";
alias "console.success=console success";
alias "console.quit=console quit";
alias "console.header=console header";
alias "console.ok=console ok";
alias "console.prompt=console prompt";
alias "console.log=console log";

# mask the info system executable
# legacy due to the old info command declaration
info() {
	console info "$@";
}

# alias "info=console info";
# alias "error=console error";
# alias "warn=console warn";
# alias "success=console.success";
# alias "quit=console quit";