: <<'ronn:markdown'
console(3) -- console output module
=============================================

## SYNOPSIS

	console [options...] message [replacements...]

## DESCRIPTION

Helper methods for printing ANSI formatted output to a terminal and redirecting output to log file(s).

The console(3) module is a built in module available to all programs. It is responsible for printing messages with optional replacement parameters which are highlighted when the message is printed.

If either stdout or stderr is not a *tty* then formatting of the output message is not performed which means that when redirecting to a file the ANSI sequence is omitted and the string is passed with parameter replacement performed but *no formatting*.

## OPTIONS

* `-1`:

Print to *stdout*.

* `-2`:

Print to *stderr*.

* `--color=[color]`:

Set *color* as the overall message color.

* `--prefix=[prefix]`:

Prepend *prefix* to the beginning of the message.

* `--debug`:

Do not interpret ANSI sequences, print them.

## USAGE

The general syntax for printing output is:

console.info "message to print with %s information" "important";
	
Whereby the `%s` substring in the main message will be highlighted and replaced with the string *important*, generating:

message to print with `important` information

## STDOUT

To print to standard output use the following methods.

* `console.info`:

	Prints an informational message.
	
* `console.log`:

	Prints a log message. This method *does not perform any formatting* or print any program (or message type prefix) but does provide parameter replacement. This method is essentially just a wrapper for echo(1) that allows the use of parameter replacement and the log file redirection functionality.
	
## STDERR

To print to standard error use the following methods.

* `console.warn`:

	Prints a warning message.
	
* `console.error`:

	Prints an error message.
	
* `console.throw`:

	Prints an error message followed by a stack trace of the current method call stack.
	
## LOG FILE REDIRECTION

The console(3) module supports redirecting stdout/stderr to log file(s). 

* `console.log.stdout`:

	Redirect stdout to a log file and store stdout in file descriptor #3.
	
* `console.log.stdout.close`:

	Close redirection of stdout, restoring stdout and closing file descriptor #3.
	
* `console.log.stderr`:

	Redirect stderr to a log file and store stderr in file descriptor #4.

* `console.log.stderr.close`:

	Close redirection of stderr, restoring stderr and closing file descriptor #4.
	
## EXIT METHODS

The console(3) module provides methods for exiting the program (optionally with a formatted message).

* `console.success`:

	Marks the program as completed successfully (exiting with a zero exit code) and optionally prints a formatted message.

* `console.quit`:

	Exits the program with a non-zero exit code and optional error message. Note that the signature for this method differs from the general syntax for console(3) methods as it expects the first parameter to be the exit code.
	
## OPTIONS

The console(3) module parses the program options (but does not modify them) looking for the following options:

* `--no-color`:

	Do not perform any ANSI color or formatting modifications to the output.
	
# ITERM2

It is recommended that users of iTerm2 uncheck the *Draw bold text in bright colors* option in *Profiles > Text* for highlighted replacement values to appear consistently with the main message colour.
	
## VARIABLES

See the globals-api(3) documentation.
	
## MISCELLANEOUS

You may also print a stack trace (without any preceeding error message) using the `console.trace` method. Note that this method does not follow the general syntax for console(3) method invocations and accepts no parameters.

## BUGS

The number of replacement parameters must match exactly the number of `%s` occurences in the message otherwise unexpected behaviour will occur.

A leading hyphen in a replacement parameter or message will cause printf to fail.

**console** is written in bash and depends upon `bash` >= 4.2.

## COPYRIGHT

**console** is copyright (c) 2012 muji <http://xpm.io>

## SEE ALSO

globals-api(3)
ronn:markdown

declare -g __stdout_log_file="";
declare -g __stderr_log_file="";

#Black       0;30     Dark Gray     1;30
#Blue        0;34     Light Blue    1;34
#Green       0;32     Light Green   1;32
#Cyan        0;36     Light Cyan    1;36
#Red         0;31     Light Red     1;31
#Purple      0;35     Light Purple  1;35
#Brown       0;33     Yellow        1;33
#Light Gray  0;37     White         1;37

declare -Ag console_styles;
console_styles[bold]="\033[1m";
console_styles[underline]="\033[4m";

console_styles[black]="\033[0;30m";
console_styles[red]="\033[0;31m";
console_styles[green]="\033[0;32m";
console_styles[brown]="\033[0;33m";
console_styles[blue]="\033[0;34m";
console_styles[magenta]="\033[0;35m";

console_styles[cyan]="\033[0;36m";
console_styles[gray]="\033[0;37m";

console_styles[yellow]="\033[1;33m";
console_styles[white]="\033[1;37m";

# generic console output command
console() {
	# style terminator
	local terminator="\033[0m";
	# message prefix
	local prefix="";
	local messages=();
	local parsed="";
	
	if [ $# -eq 0 ]; then
		echo "console: too few options" >&2;
		exit 2;
	fi
	
	local color="";
	local prefix_color="";
	local highlight_color="";
	
	declare -A flags;
	flags[debug]=false;
	flags[program.prefix]=false;
	flags[message.prefix]=true;
	flags[ansi]=true;
	flags[color]=true;
	flags[replace]=true;
	flags[replace.bold]=true;
	flags[prefix.bold]=true;
	flags[stderr]=false;
	flags[tick]=false;
	flags[cross]=false;
	
	console.options.parse "$@";
	
	if [ -n "${color}" ]; then
		console.color.validate "${color}";
	fi	
	
	if [ "${#messages[@]}" -eq 0 ]; then
		echo "no console message supplied";
		exit 2;
	fi	
	
	# list of available commands
	local namespace="console.commands";
	local cmd="";
	local commands=( info warn error throw debug log header trace quit success print ok notok );
	
	local code=1;
	if array.contains? "$1" "${commands[@]}"; then
		cmd="$1";
		prefix="${console_prefixes[$cmd]:-}";
		shift;
		
		if [ "$cmd" == quit ] && [ $# -gt 0 ]; then
			code="$1";
			shift;
		fi
	fi
	
	local message="${messages[0]}";
	if ${flags[cross]}; then
		message="${message} ${characters[cross]}";
	fi
	if ${flags[tick]}; then
		message="${message} ${characters[tick]}";
	fi
	messages[0]="${message}";
	
	local replacements=( "${messages[@]:1}" );
	
	# switch off ansi escapes for non-tty
	if ! ${flags[stderr]} && [ ! -t 1 ]; then
		console.noansi;
	elif ${flags[stderr]} && [ ! -t 2 ]; then
		console.noansi;
	elif [ "$TERM" != "xterm" ]; then
		console.noansi;
	elif ${console_no_color}; then
		console.noansi;
	fi
	
	if [ -n "${cmd}" ]; then
		if ! method.exists? "${namespace}.${cmd}"; then
			console quit 2 "invalid command %s" "${cmd}";
		fi
		delegate "$namespace" "$cmd" "$@";
	else
		console.main;
	fi
}

## COMMANDS

# print the generic message header
console.commands.header() {
	console "$@" "${header}";
}

# print a message with no prefix
console.commands.print() {
	console "$@";
}

# print a log message with a prefix
console.commands.log() {
	console --prefix="${console_prefixes[log]}" "$@";
}

# print an ok message with a prefix
console.commands.ok() {
	console --tick --prefix="${console_prefixes[ok]}" "$@";
}

# print an info message with a prefix
console.commands.info() {
	console --prefix="${console_prefixes[info]}" "$@";
}

## ERROR COMMANDS

# print a debug message to stderr
console.commands.debug() {
	console -2  --color=cyan --prefix="${console_prefixes[debug]}" "$@";
}

# print a not ok message to stderr
console.commands.notok() {
	console -2 --color=red --cross --prefix="${console_prefixes[notok]}" "$@";
}

# print an error message to stderr
console.commands.error() {
	console -2 --color=red --prefix="${console_prefixes[error]}" "$@";
}

# print a warning message to stderr
console.commands.warn() {
	console -2 --color=magenta --prefix="${console_prefixes[warn]}" "$@";
}

# print a stack trace as a series of error messages
console.commands.trace() {
	local offset="${1:-0}";
	local frame=$offset line;
	local data=( $( caller $frame ) );
	while [ "${#data[@]}" -gt 0 ]; do
		console -2 --color=red --prefix="${console_prefixes[trace]}" \
			"%s:%s %s" "${data[2]}" "${data[0]}" "${data[1]}";
		: $((frame++));
		data=( $( caller $frame ) );
	done
}

# exit with a failure
console.commands.quit() {
	if [ $# -gt 0 ]; then
		console notok "$@";
	fi
	exit $code;
}

# exit
console.commands.success() {
	if [ $# -gt 0 ]; then
		console ok "$@";
	fi
	exit 0;
}

## INTERNAL

# validate a color name
console.color.validate() {
	local val="$1";
	if ! array.contains? "${val}" "${!console_styles[@]}"; then
		console -2 --color=red --prefix="[console]" "invalid color ${val}";
		exit 2;
	fi
}

# switch off ANSI escape sequences completely
console.noansi() {
	flags[ansi]=false;
	flags[color]=false;
	flags[replace.bold]=false;
	flags[prefix.bold]=false;
}

# main 
console.main() {
	# console.debugger;	
	if ${flags[replace]}; then
		console.replace;
	fi
	console.output;
}

# print parsed result
console.output() {
	local opts="-e";
	if ${flags[debug]}; then
		opts="";
	fi
	
	#echo "parsed : $parsed";
	
	if ! ${flags[stderr]}; then
		echo $opts "$parsed";
	else
		echo $opts "$parsed" >&2;
	fi
}

# performs printf replacement
# on the primary message
console.replace() {
	local i length val;
	if ! ${flags[color]} || ! ${flags[ansi]}; then
		parsed=$( printf -- "${messages[@]}" );
	else
		if ${flags[ansi]}; then
			length="${#replacements[@]}";
			local highlight_color="";
			for((i = 0;i < $length;i++))
				do
					val="${replacements[$i]}";
					if ${flags[replace.bold]}; then
						replacements[$i]="${console_styles[bold]}${val}${terminator}";
					fi
					# ensure replacements respect the overall colour
					if ${flags[color]} && [ -n "$color" ]; then
						highlight_color="$color";
					fi
					if [ -n "${highlight_color}" ]; then
						replacements[$i]="${console_styles[$highlight_color]}${replacements[$i]}${terminator}";
					fi
					if ${flags[color]} && [ -n "$color" ]; then
						# start the message colour again for parts in
						# between replacements
						replacements[$i]="${replacements[$i]}${console_styles[$color]}";
					fi
			done
			parsed=$( printf -- "${message}" "${replacements[@]:-}" );
		fi

		# handle overall message color
		if ${flags[ansi]} && ${flags[color]} && [ -n "$color" ]; then
			# echo "add overall message color ..."
			parsed="${console_styles[$color]}${parsed}";
		fi
	fi
	console.prefix;
	
	# always add final terminator
	if ${flags[ansi]}; then
		parsed="${parsed}${terminator}";
	fi
}

# prepend prefix(es)
console.prefix() {
	if [ -n "${prefix}" ] && ${flags[message.prefix]}; then	
		# echo "prepend prefix ... $message : $prefix : ${flags[color]}";
		if ${flags[color]}; then
			if ${flags[prefix.bold]}; then
				prefix="${console_styles[bold]}${prefix}${terminator}";
			fi
			if [ -n "${color}" ]; then
				prefix="${console_styles[$color]}${prefix}${terminator}";
			fi
		fi
		parsed="${prefix} ${parsed}";
	fi
}

# debug parsed options
console.debugger() {
	echo "$header";
	local flag;
	for flag in ${!flags[@]}
		do
			echo "flag $flag :: ${flags[$flag]}";
	done
	echo "prefix is : ${prefix}"
	echo "messages length : ${#messages[@]}";
	echo "messages are : ${messages}";
	echo "primary message: $message";
	echo "replacements length: ${#replacements[@]}";
	if [ "${#replacements[@]}" -gt 0 ]; then
		echo "replacements: ${replacements[@]}";	
	fi
	echo "$header";	
}

# parse console options
console.options.parse() {
	#echo "$FUNCNAME : $*";
	local optspec=":cn12-:";
	local optchar val opt;
	OPTIND=0;
	while getopts "$optspec" optchar; do
	    case "${optchar}" in
	        -)
	            case "${OPTARG}" in
	                prefix=*)
	                    val=${OPTARG#*=};
	                    opt=${OPTARG%=$val};
						prefix="${val}";
	                    ;;
	                color=*)
	                    val=${OPTARG#*=};
	                    opt=${OPTARG%=$val};
						color="${val}";
	                    ;;
	                debug)
						flags[debug]=true;
	                    ;;	
	                tick)
						flags[tick]=true;
	                    ;;
	                cross)
						flags[cross]=true;
	                    ;;
	                *)
	                    if [ "$OPTERR" = 1 ] && [ "${optspec:0:1}" != ":" ]; then
	                        echo "console: unknown option --${OPTARG}" >&2
	                    fi
	                    ;;
	            esac;;
	        c)
				flags[color]=true;
	            ;;
	        n)
				flags[color]=false;
	            ;;
	        1)
				flags[stderr]=false;
	            ;;
	        2)
				flags[stderr]=true;
	            ;;
	        *)
	            if [ "$OPTERR" != 1 ] || [ "${optspec:0:1}" = ":" ]; then
	                echo "console: non-option '-${OPTARG}'" >&2
	            fi
	            ;;
	    esac
	done
	
	# get remaining message and printf
	# replacement values
	local opt opts=( "$@" );
	local i length="$#";
	for((i = 0;i < $length;i++))
		do
			opt="${opts[$i]}"
			if [[ "$opt" =~ ^- ]]; then
				continue;
			fi
			messages+=( "$opt" );
	done
}


# inspect the program options 
# looking for a --no-color option
console.parse() {
	local l=$#;
	local i val;
	for((i = 1;i < l+1;i++))
		do
			eval val="$"$i;
			if [ "$val" == "${console_no_color_option}" ]; then
				console_no_color=true;
			fi
	done
}
console.parse "$@";





































# DEPRECATED

function console.log.stdout {
	touch "$1" || warn "could not create stdout log file %s" "$1";
	if [ -f "$1" ]; then
		__stdout_log_file="$1";		
		# save stdout in file descriptor #3
		exec 3>&1;
		exec 1>> "$1";
	fi
}

function console.log.stdout.close {
	if [ ! -z "$__stdout_log_file" ]; then
		# restore stdout and close file descriptor #3
		exec 1>&3 3>&- || console.warn "no file descriptor for stdout log file";
		__stdout_log_file="";
	fi
}

function console.log.stderr {
	touch "$1" || warn "could not create stderr log file %s" "$1";
	if [ -f "$1" ]; then
		__stderr_log_file="$1";
		# save stderr in file descriptor #4
		exec 4>&2;
		exec 2>> "$1";
	fi
}

function console.log.stderr.close {
	
	# TODO: potential test for an open file descriptor?
	# requires testing cross-platform
	# ls -la /dev/fd/4
	
	if [ ! -z "$__stderr_log_file" ]; then
		# restore stdout and close file descriptor #3
		exec 2>&4 4>&- || console.warn "no file descriptor for stderr log file";
		__stderr_log_file="";
	fi
}
# 
# function console print {
# 	console.sprintf "${@}";
# 	msg="$_result";
# 	echo -e "$msg";
# }


######################################################################
#	Colours a message string formatting each replacement as bold.
#
#	$1		The name of the colour function to call.
#	$2		The function to call to highlight each replacement parameter.	
#	$3 		The printf format string.
#	$4-#	The remaining string replacements to be highlighted.
######################################################################
# function console.colorize {
# 	#function used to start the main color
# 	local start_function="$1";
# 	#function used to highlight each replacement parameter
# 	local highlight_function="$2";
# 	local message="$3";
# 	local replacements=("${@:3}");
# 	local output=( "$message" );
# 	local c=0;
# 	local i;
# 	for i in "${replacements[@]}"
# 		do
# 			if [ $c -ne 0 ]; then
# 				#highlight each replacement parameter
# 				eval "$highlight_function" "'$i'";
# 				local res="$_result";
# 				eval "$start_function";
# 				#concatenate together
# 				res="$res$_result";
# 				#and push back on to the output data
# 				output=( "${output[@]}" "$res" );
# 			fi
# 			c=$[$c+1];
# 	done
# 	#get the overall start
# 	eval "$start_function";
# 	local start="$_result";
# 	
# 	#always end with a style terminator
# 	style_terminator;
# 	local end="$_result";
# 	
# 	# TODO: use the shared console.sprintf message
# 	#perform the replacement on the message template string
# 	_result=$(printf "${output[@]}");
# 	
# 	#wrap the replaced message with the start and end highlighting
# 	local full="$start${_result[@]}$end";
# 	
# 	#return the output
# 	_result="$full";
# 	#echo "got FULL RESULT: $full";
# 	#echo -e "$full";
# 	#echo "this is a normal message";
# }
# 
# ######################################################################
# #	Performs replacement without performing any highlighting
# #	appropriate for output to a non-terminal.
# #
# #	$1 		The printf format string.
# #	$2-@	The remaining string replacements to be highlighted.
# ######################################################################
# function console.sprintf {
# 	#echo "sprintf length : $#"
# 	# escape hyphens
# 	#local var="$@";
# 	#var="${var//-/\-}";
# 	#echo "var is: '''$var'''"
# 	_result=$(printf "$@");
# 	#_result="${_result//\\-/-}";
# }
# 
# #TODO : integrate this logic so no highlighting is performed when not a terminal
# #if [ -t 1 ] ; then echo terminal; fi
# #(if [ -t 1 ] ; then echo terminal; fi) | echo
# 
# #quits a program with a message and exit code
# function console.quit {
# 	local code="${1:-1}";
# 	if [ $# -gt 1 ]; then
# 		local params=("${@:2}");
# 		console.error "${params[@]}";
# 	fi
# 	exit $code;
# }
# 
# #prints a message with the default output formatting
# function print {
# 	local msg="$1";
# 	__console_print_program_prefix;
# 	echo -e "$msg";
# }
# 
# function __console_print_program_prefix {
# 	local prefix="[${process_name:-}]";
# 	local include_prefix=${console_print_program_prefix:-};
# 	if [ ! -z "$include_prefix" ]; then
# 		if [ -t 1 ] && [ -z "$console_no_color" ]; then	
# 			if [ "$prefix" != "" ]; then
# 				gray "$prefix";
# 				echo -ne "$_result";
# 				echo -ne " ";
# 			fi
# 		else
# 			echo -n "$prefix ";
# 		fi
# 	fi
# }
# 
# #exits a program with a success message
# function console.success {
# 	
# 	if [ $# -eq 0 ]; then
# 		exit 0;
# 	fi
# 	
# 	local status="${console_prefixes[$FUNCNAME]}";
# 	local prefix="$status";
# 	local msg="";
# 	if [ -t 1 ] && [ -z "$console_no_color" ]; then
# 		#get the message prefix
# 		bold "$status";
# 		prefix="$_result";
# 
# 		#highlight the message and parameters
# 		msgs=( "default_style" "bold" "${@}" );
# 		console.colorize "${msgs[@]}";
# 		msg="$_result";
# 	else
# 		console.sprintf "${@}";
# 		msg="$_result";
# 	fi
# 	
# 	#output everything
# 	__console_print_program_prefix;
# 	echo -e "$prefix $msg";
# 	exit 0;
# }
# 
# function console.ok {
# 	local status="${console_prefixes[$FUNCNAME]}";
# 	local prefix="$status";
# 	local msg="";
# 	if [ -t 1 ] && [ -z "$console_no_color" ]; then
# 		#get the message prefix
# 		bold "$status";
# 		prefix="$_result";
# 
# 		#highlight the message and parameters
# 		msgs=( "default_style" "bold" "${@}" );
# 		console.colorize "${msgs[@]}";
# 		msg="$_result";
# 	else
# 		console.sprintf "${@}";
# 		msg="$_result";
# 	fi
# 	
# 	#output everything
# 	__console_print_program_prefix;
# 	echo -e "$prefix $msg";
# }
# 
# function console.prompt {
# 	local status="${console_prefixes[$FUNCNAME]}";
# 	local prefix="$status";	
# 	local msg="";
# 	if [ -t 1 ] && [ -z "$console_no_color" ]; then
# 		#get the message prefix
# 		bold "$status";
# 		prefix="$_result";
# 
# 		#highlight the message and parameters
# 		msgs=( "default_style" "bold" "${@}" );
# 		console.colorize "${msgs[@]}";
# 		msg="$_result";
# 	else
# 		console.sprintf "${@}";
# 		msg="$_result";
# 	fi
# 	
# 	#output everything
# 	__console_print_program_prefix;
# 	echo -ne "$msg ";
# }
# 
# #outputs an info message
# function console.info {	
# 	local status="${console_prefixes[$FUNCNAME]}";
# 	local prefix="$status";
# 	local msg="";
# 	if [ -t 1 ] && [ -z "$console_no_color" ]; then
# 		#get the message prefix
# 		bold "$status";
# 		prefix="$_result";
# 
# 		#highlight the message and parameters
# 		msgs=( "default_style" "bold" "${@}" );
# 		console.colorize "${msgs[@]}";
# 		msg="$_result";
# 	else
# 		console.sprintf "${@}";
# 		msg="$_result";
# 	fi
# 	
# 	#output everything
# 	__console_print_program_prefix;
# 	echo -e "$prefix $msg";
# }
# 
# # output a info message when the process is in debug mode
# function console.debug {
# 	# TODO: change prefix to debug
# 	if process.debug?; then
# 		console.info "$@";
# 	fi
# }
# 
# #outputs a warning message
# function console.warn {	
# 	local status="${console_prefixes[$FUNCNAME]}";
# 	local prefix="$status";
# 	local msg="";
# 	if [ -t 2 ] && [ -z "$console_no_color" ]; then
# 		#get the message prefix
# 		boldpurple "$status";
# 		prefix="$_result";
# 
# 		#highlight the message and parameters
# 		msgs=( "start_purple" "boldpurple" "${@}" );
# 		console.colorize "${msgs[@]}";
# 		msg="$_result";
# 	else
# 		console.sprintf "${@}";
# 		msg="$_result";
# 	fi
# 	
# 	#output everything
# 	__console_print_program_prefix;
# 	echo -e "$prefix $msg" >&2;
# }
# 
# # # executed before showing a prompt
# # console.error.before() {
# # 	# save stderr in file descriptor #7
# # 	exec 7>&2;
# # 	# redirect stderr to stdout
# # 	exec 2>&1;
# # }
# # 
# # # executed after showing a prompt
# # console.error.after() {
# # 	# restore stderr and close file descriptor #7
# # 	if [ -f 7 ]; then
# # 		exec 2>&7 7>&-;
# # 	fi
# # }
# 
# #outputs an error message
# function console.error {
# 	local status="${console_prefixes[$FUNCNAME]}";
# 	local prefix="$status";
# 	local msg="";
# 	if [ -t 2 ] && [ -z "$console_no_color" ]; then
# 		#get the message prefix
# 		boldred "$status";
# 		prefix="$_result";
# 
# 		#highlight the message and parameters
# 		msgs=( "start_red" "boldred" "${@}" );
# 		console.colorize "${msgs[@]}";
# 		msg="$_result";
# 	else
# 		console.sprintf "${@}";
# 		msg="$_result";
# 	fi
# 	
# 	#output everything
# 	__console_print_program_prefix;
# 	echo -e "$prefix $msg" >&2;
# }
# 
# # generates a stack trace
# function console.trace {
# 	local offset="${1:-0}";
# 	local frame=$offset line;
# 	local data=( $( caller $frame ) );
# 	while [ "${#data[@]}" -gt 0 ]; do
# 		console.error "%s:%s %s" "${data[2]}" "${data[0]}" "${data[1]}";
# 		: $((frame++));
# 		data=( $( caller $frame ) );
# 	done
# 	return 0;
# }
# 
# # print the generic header delimiter
# function console.header() {
# 	printf "${header:-}\n";
# }
# 
# # throws an error message and prints the stack trace
# function console.throw {
# 	local message="${1:-Unknown error}";
# 	#echo "throw message: $message";
# 	console.error "$message";
# 	console.trace 1;
# }

# must set this option so that aliases are expanded
shopt -s expand_aliases;

# set up aliases for backward compatability
# WARNING: these aliases will be removed in a future
# version and you should use console.info etc.
alias "console.info=console info";
alias "console.error=console error";
alias "console.warn=console warn";
alias "console.success=console success";
alias "console.quit=console quit";
alias "console.header=console header";
alias "console.ok=console ok";
alias "console.prompt=console prompt";
alias "console.log=console log";

# alias "info=console.info";
# alias "error=console.error";
# alias "warn=console.warn";
# alias "success=console.success";
# alias "quit=console.quit";