: <<'ronn:markdown'
console(3) -- console output module
=============================================

## SYNOPSIS

	console [options...] message [replacements...]

## DESCRIPTION

Helper methods for printing ANSI formatted output to a terminal and redirecting output to log file(s).

The console(3) module is a built in module available to all programs. It is responsible for printing messages with optional replacement parameters which are highlighted when the message is printed.

If either stdout or stderr is not a *tty* then formatting of the output message is not performed which means that when redirecting to a file the ANSI sequence is omitted and the string is passed with parameter replacement performed but no formatting.

## OPTIONS

* `-1`:

Print to *stdout*.

* `-2`:

Print to *stderr*.

* `--color=[color]`:

Set *color* as the foreground color.

* `--background=[color]`:

Set *color* as the background color.

* `--prefix=[prefix]`:

Prepend *prefix* to the message.

* `--suffix=[suffix]`:

Append *suffix* to the message.

* `--no-prefix`:

Do not print the prefix.

* `--readline`:

Use escape sequences compatible with passing to `read -ep`. This allows formatting to be applied to interactive prompts using `read`. When this option is used nothing is printed but the result of formatting the message is assigned to the `PS9` variable.

* `--cross`:

Append a single space and a cross character to the message.

* `--tick`:

Append a single space and a tick character to the message.

* `--debug`:

Do not interpret ANSI sequences, print them.

* `--`:

Stop processing options. Use the `--` option to signal that option processing should stop so that message and replacement values that begin with a hyphen may be processed.

## USAGE

The general syntax for printing output is:

console info "message to print with %s information" "important";
	
Whereby the `%s` substring in the main message will be highlighted and replaced with the string *important*, generating:

message to print with `important` information

## STDOUT

To print to standard output use the following methods.

* `console print`:

	Print a message with no prefix.

* `console info`:

	Print an info message.
	
* `console.log`:

	Print a log message.
	
## STDERR

To print to standard error use the following methods.

* `console warn`:

	Print a warning message.
	
* `console error`:

	Print an error message.
	
* `console throw`:

	Print an error message followed by a stack trace of the current method call stack.
	
## LOG FILE REDIRECTION

The console(3) module supports redirecting stdout/stderr to log file(s). 

* `console.log.stdout`:

	Redirect stdout to a log file and store stdout in file descriptor #3.
	
* `console.log.stdout.close`:

	Close redirection of stdout, restoring stdout and closing file descriptor #3.
	
* `console.log.stderr`:

	Redirect stderr to a log file and store stderr in file descriptor #4.

* `console.log.stderr.close`:

	Close redirection of stderr, restoring stderr and closing file descriptor #4.
	
## EXIT METHODS

The console(3) module provides methods for exiting the program (optionally with a formatted message).

* `console success`:

	Marks the program as completed successfully (exiting with a zero exit code) and optionally prints a formatted message.

* `console quit`:

	Exits the program with a non-zero exit code and optional error message. Note that the signature for this method differs from the general syntax for console(3) methods as it expects the first parameter to be the exit code.
	
## OPTIONS

The console(3) module parses the program options (but does not modify them) looking for the following options:

* `--no-color`:

	Do not perform any ANSI color or formatting modifications to the output.
	
# ITERM2

It is recommended that users of iTerm2 uncheck the *Draw bold text in bright colors* option in *Profiles > Text* for highlighted replacement values to appear consistently with the main message colour.
	
## VARIABLES

See the globals-api(3) documentation.

## BUGS

The number of replacement parameters must match exactly the number of `%s` occurences in the message otherwise unexpected behaviour will occur.

**console** is written in bash and depends upon `bash` >= 4.2.

## COPYRIGHT

**console** is copyright (c) 2012 muji <http://xpm.io>

## SEE ALSO

globals-api(3)
ronn:markdown

#Black       0;30     Dark Gray     1;30
#Blue        0;34     Light Blue    1;34
#Green       0;32     Light Green   1;32
#Cyan        0;36     Light Cyan    1;36
#Red         0;31     Light Red     1;31
#Purple      0;35     Light Purple  1;35
#Brown       0;33     Yellow        1;33
#Light Gray  0;37     White         1;37

# The ANSI sequence: {ESC}[{attr};{bg};{256colors};{fg}m

# {ESC} or \033 represents the ANSI escape-sequence. {attr} represents the outputs attributes (properties such as blinking and bold text), {fg} is the # foreground color, {bg} is the background color, m means the sequence ends.



# NOTE: read -ep octal formatting example
# SEE: http://lists.gnu.org/archive/html/help-bash/2013-02/msg00007.html
# $'\001\033[1m\002ABC\001\033[0m\002'

declare -Ag ansi;
ansi=(
	[terminator]="\033[0m"
	[start]="\033["
	[delimiter]=";"
	[end]="m"
	[bright.prefix]="bright"
	[foreground]="3"
	[background]="4"
	[colors]="black red green brown blue magenta cyan gray normal"
	[colors.black]="0"
	[colors.red]="1"
	[colors.green]="2"
	[colors.brown]="3"
	[colors.blue]="4"
	[colors.magenta]="5"
	[colors.cyan]="6"
	[colors.gray]="7"
	[colors.normal]="9"
	[attributes]="normal bright underline blink positive framed encircled overlined"
	[attr.normal]="0"
	[attr.bright]="1"
	[attr.underline]="4"
	[attr.blink]="5"
	[attr.negative]="7"
	[attr.positive]="27"
	[attr.framed]="51"
	[attr.encircled]="52"
	[attr.overlined]="53"
	
	[octal.terminator]=$'\001\033[0m\002'
	[octal.start]=$'\001\033['
	[octal.end]=$'m\002'
	[emulators]="xterm xterm-color vt100 ansi"
)
readonly -A ansi;

# TODO: deprecated
declare -g __stdout_log_file="";
declare -g __stderr_log_file="";

# main console entry point
console() {
	# style terminator
	local terminator start end;
	# message prefix
	local prefix="";
	local suffix="";
	local messages=();
	local parsed="";
	
	if [ $# -eq 0 ]; then
		echo "console: too few options" >&2;
		exit 2;
	fi
	
	# the style list
	declare -A styles;
	
	# message style names
	local color="normal";
	local background="";
	local attribute="";
	
	local prefix_color="";
	
	declare -A flags;
	flags[debug]=false;
	flags[readline]=false;
	flags[program.prefix]=false;
	flags[message.prefix]=true;
	flags[ansi]=true;
	flags[color]=true;
	flags[newline]=true;
	flags[replace]=true;
	flags[replace.bold]=true;
	flags[prefix.bold]=true;
	flags[stderr]=false;
	flags[tick]=false;
	flags[cross]=false;
	
	console.options.parse "$@";
	
	# initialize styles
	console.styles;
	
	if [ -n "${color}" ]; then
		console.color.validate "${color}";
	fi
	if [ -n "${background}" ]; then
		console.color.validate "${background}";
	fi

	# echo "after parse : $color";
	# echo "after parse : $background";
	# echo "after parse : $attribute";
	
	declare -A settings;
	# main message color
	if [ -n "${color:-}" ]; then
		settings[color]="${styles[$color]}";
	else
		settings[color]="";
	fi
	
	local has_custom_message_color=false;
	if [ -n "${color}" ]; then
		if [ -n "${background}" ] || [ -n "${attribute}" ]; then
			has_custom_message_color=true;
			console.color.update;
		fi
	fi
	
	if [ "${#messages[@]}" -eq 0 ]; then
		echo "no console message supplied";
		exit 2;
	fi
	
	# list of available commands
	local namespace="console.commands";
	local cmd="";
	local commands=(
		info
		warn
		error
		throw
		debug
		log
		header
		trace
		quit
		success
		print
		ok
		notok
		prompt
	);
	
	# exit code
	local code=1;
	if array.contains? "$1" "${commands[@]}"; then
		cmd="$1";
		prefix="${console_prefixes[$cmd]:-}";
		shift;
		
		if [ "$cmd" == quit ] && [ $# -gt 0 ]; then
			code="$1";
			shift;
		fi
	fi
	
	local message="${messages[0]:-}";
	if [ -n "${suffix}" ]; then
		message="${message} ${suffix}";
	fi
	if ${flags[cross]}; then
		message="${message} ${characters[cross]}";
	fi
	if ${flags[tick]}; then
		message="${message} ${characters[tick]}";
	fi
	messages[0]="${message}";
	
	local replacements=( "${messages[@]:1}" );
	
	local emulators=( ${ansi[emulators]} );
	# switch off ansi escapes for non-tty
	if ! ${flags[stderr]} && [ ! -t 1 ]; then
		console.noansi;
	elif ${flags[stderr]} && [ ! -t 2 ]; then
		console.noansi;
	elif ! array.contains? "$TERM" "${emulators[@]}"; then
		console.noansi;
	elif ${console_no_color}; then
		console.noansi;
	fi
	
	if [ -n "${cmd}" ]; then
		if ! method.exists? "${namespace}.${cmd}"; then
			console quit 2 "invalid command %s" "${cmd}";
		fi
		delegate "$namespace" "$cmd" "$@";
	else
		console.main;
	fi
}

# updates the color to include
# attribute / background information
console.color.update() {
	local key="${1:-color}";
	local fgname="${color:-}";
	local bgname="${background:-}";
	local attrname="${attribute:-}";
	local fgindex="${ansi[colors.${fgname}]:-}";
	local bgindex="${ansi[colors.${bgname}]:-}";
	
	local fgvalue="${ansi[foreground]}${fgindex}";
	local bgvalue="${ansi[background]}${bgindex}";
	local attrvalue="${ansi[attr.${attrname}]:-}";
	
	local updated="${start}";
	if [ -n "${attribute:-}" ]; then
		updated="${updated}${attrvalue}";
	fi
	
	if [ -n "${background:-}" ]; then
		if [ -n "${attribute:-}" ]; then
			updated="${updated}${ansi[delimiter]}";
		fi
		updated="${updated}${bgvalue}";
	fi
	if [ -n "${color:-}" ]; then
		if [ -n "${background:-}" ] || [ -n "${attribute:-}" ]; then
			updated="${updated}${ansi[delimiter]}";
		fi
		updated="${updated}${fgvalue}";
	fi
	updated="${updated}${end}";
	# echo "current : ${settings[$key]}";
	# echo "$FUNCNAME : $fgname : $bgname : $attrname : $fgindex : $bgindex : $attrvalue";
	# echo "$FUNCNAME : $updated";
	settings[$key]="${updated}";
}

# initialize the style list
console.styles() {
	local style;
	
	# standard escape sequences
	if ! ${flags[readline]}; then
		terminator="${ansi[terminator]}";
		start="${ansi[start]}";
		end="${ansi[end]}";
		
		console.styles.attributes;
		console.styles.standard;
		console.styles.standard bright;
	# handle read -ep octal formatting
	else
		terminator="${ansi[octal.terminator]}";
		start="${ansi[octal.start]}";
		end="${ansi[octal.end]}";

		console.styles.attributes;
		console.styles.standard;
		console.styles.standard bright;
	fi
}

# set up attribute styles
console.styles.attributes() {
	local cnames=( ${ansi[attributes]} );
	local i length="${#cnames[@]}";
	local prefix="";
	local cname attribute;
	for((i =0;i < $length;i++))
		do
			cname="${cnames[$i]}";
			attribute="$cname";
			console.styles.prefix true;
			styles[$cname]="${prefix}";
	done
}

# set up standard styles
console.styles.standard() {
	local cnames=( ${ansi[colors]} );
	local i length="${#cnames[@]}";
	local attribute=${1:-normal};
	local foreground=true;
	local prefix="";
	local cprefix="";
	local cname;
	for((i =0;i < $length;i++))
		do
			cname="${cnames[$i]}";
			console.styles.prefix;
			if [ "$attribute" == "${ansi[bright.prefix]}" ]; then
				cname="${ansi[bright.prefix]}-${cname}";
			fi
			if $foreground; then
				cprefix="${ansi[foreground]}${i}";
			else
				cprefix="${ansi[background]}${i}";
			fi
			prefix="${prefix}${cprefix}";
			prefix="${prefix}${end}";
			styles[$cname]="${prefix}";
	done
}

console.styles.prefix() {
	local terminate="${1:-false}";
	prefix="${start}${ansi[attr.${attribute}]}";
	if ! $terminate; then
		prefix="${prefix}${ansi[delimiter]}";
	else
		prefix="${prefix}${end}";
	fi
}

## COMMANDS

# print the generic message header
console.commands.header() {
	console print "$@" "${header}";
}

# print a message with no prefix
console.commands.print() {
	console -1 --no-prefix "$@";
}

# print a prompt with no newline
# and a space as the suffix
console.commands.prompt() {
	console print --no-newline --readline \
		--suffix="${console_prompt_suffix:-}" "$@";
}

# print a log message with a prefix
console.commands.log() {
	console --prefix="${console_prefixes[log]}" "$@";
}

# print an ok message with a prefix
console.commands.ok() {
	console --tick --prefix="${console_prefixes[ok]}" "$@";
}

# print an info message with a prefix
console.commands.info() {
	console --prefix="${console_prefixes[info]}" "$@";
}

## ERROR COMMANDS

# print a debug message to stderr
console.commands.debug() {
	console -2  --color=cyan --prefix="${console_prefixes[debug]}" "$@";
}

# print a not ok message to stderr
console.commands.notok() {
	console -2 --color=red --cross --prefix="${console_prefixes[notok]}" "$@";
}

# print an error message to stderr
console.commands.error() {
	console -2 --color=red --prefix="${console_prefixes[error]}" "$@";
}

# print a warning message to stderr
console.commands.warn() {
	console -2 --color=magenta --prefix="${console_prefixes[warn]}" "$@";
}

# throw a stack trace with
# preceeding error message
console.commands.throw() {
	local message="${1:-Unknown error}";
	console error "$message";
	console trace 1;
}

# print a stack trace as a series of error messages
console.commands.trace() {
	local offset="${1:-0}";
	local frame="$offset";
	local line;
	local data=( $( caller $frame ) );
	while [ "${#data[@]}" -gt 0 ]; do
		console -2 --color=red --prefix="${console_prefixes[trace]}" \
			"%s:%s %s" "${data[2]}" "${data[0]}" "${data[1]}";
		: $((frame++));
		data=( $( caller $frame ) );
	done
}

# exit with a failure
console.commands.quit() {
	if [ $# -gt 0 ]; then
		console notok "$@";
	fi
	exit $code;
}

# exit
console.commands.success() {
	if [ $# -gt 0 ]; then
		console ok "$@";
	fi
	exit 0;
}

## INTERNAL

# validate a color name
console.color.validate() {
	local val="$1";
	if ! array.contains? "${val}" "${!styles[@]}"; then
		console -2 --color=red --prefix="[console]" "invalid color ${val}";
		exit 2;
	fi
}

# switch off ANSI escape sequences completely
console.noansi() {
	flags[ansi]=false;
	flags[color]=false;
	flags[replace.bold]=false;
	flags[prefix.bold]=false;
}

# main 
console.main() {
	# console.debugger;	
	if ${flags[replace]}; then
		console.replace;
	fi
	console.output;
}

# print parsed result
console.output() {
	local opts="-e";
	if ! ${flags[newline]}; then
		opts="${opts}n";
	fi
	if ${flags[readline]}; then
		PS9="$parsed";
		return 0;
	fi
	if ${flags[debug]}; then
		opts="";
	fi
	
	if ! ${flags[stderr]}; then
		echo $opts "$parsed";
	else
		echo $opts "$parsed" >&2;
	fi
}

# performs printf replacement
# on the primary message
console.replace() {
	local i length val;
	if ! ${flags[color]} || ! ${flags[ansi]}; then
		parsed=$( printf -- "${messages[@]}" );
	else
		if ${flags[ansi]}; then
			length="${#replacements[@]}";
			local highlight_color="";
			for((i = 0;i < $length;i++))
				do
					val="${replacements[$i]}";
					if $has_custom_message_color; then
						replacements[$i]="${settings[color]}${replacements[$i]}${terminator}";
					else
						if ${flags[replace.bold]}; then
							replacements[$i]="${styles[bright]}${val}${terminator}";
						fi
						# ensure replacements respect the overall colour
						if ${flags[color]} && [ -n "$color" ]; then
							highlight_color="$color";
						fi
						if [ -n "${highlight_color}" ]; then
							replacements[$i]="${styles[$highlight_color]}${replacements[$i]}${terminator}";
						fi
					fi
					# start the message colour again for parts in
					# between replacements
					if ${flags[color]} && [ -n "$color" ]; then
						replacements[$i]="${replacements[$i]}${settings[color]}";
					fi
			done
			parsed=$( printf -- "${message}" "${replacements[@]:-}" );
		fi

		# handle overall message color
		if ${flags[ansi]} && ${flags[color]} && [ -n "$color" ]; then
			# echo "add overall message color ..."
			parsed="${settings[color]}${parsed}";
		fi
	fi
	console.prefix;
	
	# always add final terminator
	if ${flags[ansi]}; then
		parsed="${parsed}${terminator}";
	fi
}

# prepend prefix(es)
console.prefix() {
	if [ -n "${prefix}" ] && ${flags[message.prefix]}; then	
		# echo "prepend prefix ... $message : $prefix : ${flags[color]}";
		if ${flags[color]}; then
			if ${flags[prefix.bold]}; then
				prefix="${styles[bright]}${prefix}${terminator}";
			fi
			if [ -n "${color}" ]; then
				prefix="${settings[color]}${prefix}${terminator}";
			fi
		fi
		parsed="${prefix} ${parsed}";
	fi
}

# debug parsed options
console.debugger() {
	echo "$header";
	local flag;
	for flag in ${!flags[@]}
		do
			echo "flag $flag :: ${flags[$flag]}";
	done
	echo "prefix is : ${prefix}"
	echo "messages length : ${#messages[@]}";
	echo "messages are : ${messages}";
	echo "primary message: $message";
	echo "replacements length: ${#replacements[@]}";
	if [ "${#replacements[@]}" -gt 0 ]; then
		echo "replacements: ${replacements[@]}";	
	fi
	echo "$header";	
}

# parse console options
console.options.parse() {
	#echo "$FUNCNAME : $*";
	local optspec=":cn12-:";
	local optchar val opt;
	OPTIND=0;
	while getopts "$optspec" optchar; do
	    case "${optchar}" in
	        -)
	            case "${OPTARG}" in
					'')
						break;
						;;
	                prefix=*)
	                    val=${OPTARG#*=};
	                    opt=${OPTARG%=$val};
						prefix="${val}";
	                    ;;
	                suffix=*)
	                    val=${OPTARG#*=};
	                    opt=${OPTARG%=$val};
						suffix="${val}";
	                    ;;	
	                color=*)
	                    val=${OPTARG#*=};
	                    opt=${OPTARG%=$val};
						color="${val}";
	                    ;;
	                background=*)
	                    val=${OPTARG#*=};
	                    opt=${OPTARG%=$val};
						background="${val}";
	                    ;;
	                attribute=*)
	                    val=${OPTARG#*=};
	                    opt=${OPTARG%=$val};
						attribute="${val}";
	                    ;;		
	                no-prefix)
						flags[message.prefix]=false;
	                    ;;
	                readline)
						flags[readline]=true;
	                    ;;	
	                no-newline)
						flags[newline]=false;
	                    ;;	
	                debug)
						flags[debug]=true;
	                    ;;	
	                tick)
						flags[tick]=true;
	                    ;;
	                cross)
						flags[cross]=true;
	                    ;;
	                *)
	                    if [ "$OPTERR" = 1 ] && [ "${optspec:0:1}" != ":" ]; then
	                        echo "console: unknown option --${OPTARG}" >&2
	                    fi
	                    ;;
	            esac;;
	        c)
				flags[color]=true;
	            ;;
	        n)
				flags[color]=false;
	            ;;
	        1)
				flags[stderr]=false;
	            ;;
	        2)
				flags[stderr]=true;
	            ;;
	        *)
	            if [ "$OPTERR" != 1 ] || [ "${optspec:0:1}" = ":" ]; then
	                echo "console: non-option '-${OPTARG}'" >&2
	            fi
	            ;;
	    esac
	done
	
	# get remaining message and printf
	# replacement values
	local opt opts=( "$@" );
	local i length="$#";
	local stopped=false;
	for((i = 0;i < $length;i++))
		do
			opt="${opts[$i]}";
			if [ "$opt" == "--" ]; then
				stopped=true;
				continue;
			fi
			if ! $stopped && [[ "$opt" =~ ^- ]]; then
				continue;
			fi
			messages+=( "$opt" );
	done
}


# inspect the program options 
# looking for a --no-color option
console.parse() {
	local l=$#;
	local i val;
	for((i = 1;i < l+1;i++))
		do
			eval val="$"$i;
			if [ "$val" == "${console_no_color_option}" ]; then
				console_no_color=true;
			fi
	done
}
console.parse "$@";


# # executed before showing a prompt
# console error.before() {
# 	# save stderr in file descriptor #7
# 	exec 7>&2;
# 	# redirect stderr to stdout
# 	exec 2>&1;
# }
# 
# # executed after showing a prompt
# console error.after() {
# 	# restore stderr and close file descriptor #7
# 	if [ -f 7 ]; then
# 		exec 2>&7 7>&-;
# 	fi
# }


































# DEPRECATED

function console.log.stdout {
	touch "$1" || warn "could not create stdout log file %s" "$1";
	if [ -f "$1" ]; then
		__stdout_log_file="$1";		
		# save stdout in file descriptor #3
		exec 3>&1;
		exec 1>> "$1";
	fi
}

function console.log.stdout.close {
	if [ ! -z "$__stdout_log_file" ]; then
		# restore stdout and close file descriptor #3
		exec 1>&3 3>&- || console warn "no file descriptor for stdout log file";
		__stdout_log_file="";
	fi
}

function console.log.stderr {
	touch "$1" || warn "could not create stderr log file %s" "$1";
	if [ -f "$1" ]; then
		__stderr_log_file="$1";
		# save stderr in file descriptor #4
		exec 4>&2;
		exec 2>> "$1";
	fi
}

function console.log.stderr.close {
	
	# TODO: potential test for an open file descriptor?
	# requires testing cross-platform
	# ls -la /dev/fd/4
	
	if [ ! -z "$__stderr_log_file" ]; then
		# restore stdout and close file descriptor #3
		exec 2>&4 4>&- || console warn "no file descriptor for stderr log file";
		__stderr_log_file="";
	fi
}
# 
# function console print {
# 	console.sprintf "${@}";
# 	msg="$_result";
# 	echo -e "$msg";
# }


######################################################################
#	Colours a message string formatting each replacement as bold.
#
#	$1		The name of the colour function to call.
#	$2		The function to call to highlight each replacement parameter.	
#	$3 		The printf format string.
#	$4-#	The remaining string replacements to be highlighted.
######################################################################
# function console.colorize {
# 	#function used to start the main color
# 	local start_function="$1";
# 	#function used to highlight each replacement parameter
# 	local highlight_function="$2";
# 	local message="$3";
# 	local replacements=("${@:3}");
# 	local output=( "$message" );
# 	local c=0;
# 	local i;
# 	for i in "${replacements[@]}"
# 		do
# 			if [ $c -ne 0 ]; then
# 				#highlight each replacement parameter
# 				eval "$highlight_function" "'$i'";
# 				local res="$_result";
# 				eval "$start_function";
# 				#concatenate together
# 				res="$res$_result";
# 				#and push back on to the output data
# 				output=( "${output[@]}" "$res" );
# 			fi
# 			c=$[$c+1];
# 	done
# 	#get the overall start
# 	eval "$start_function";
# 	local start="$_result";
# 	
# 	#always end with a style terminator
# 	style_terminator;
# 	local end="$_result";
# 	
# 	# TODO: use the shared console.sprintf message
# 	#perform the replacement on the message template string
# 	_result=$(printf "${output[@]}");
# 	
# 	#wrap the replaced message with the start and end highlighting
# 	local full="$start${_result[@]}$end";
# 	
# 	#return the output
# 	_result="$full";
# 	#echo "got FULL RESULT: $full";
# 	#echo -e "$full";
# 	#echo "this is a normal message";
# }
# 
# ######################################################################
# #	Performs replacement without performing any highlighting
# #	appropriate for output to a non-terminal.
# #
# #	$1 		The printf format string.
# #	$2-@	The remaining string replacements to be highlighted.
# ######################################################################
# function console.sprintf {
# 	#echo "sprintf length : $#"
# 	# escape hyphens
# 	#local var="$@";
# 	#var="${var//-/\-}";
# 	#echo "var is: '''$var'''"
# 	_result=$(printf "$@");
# 	#_result="${_result//\\-/-}";
# }
# 
# #TODO : integrate this logic so no highlighting is performed when not a terminal
# #if [ -t 1 ] ; then echo terminal; fi
# #(if [ -t 1 ] ; then echo terminal; fi) | echo
# 
# #quits a program with a message and exit code
# function console quit {
# 	local code="${1:-1}";
# 	if [ $# -gt 1 ]; then
# 		local params=("${@:2}");
# 		console error "${params[@]}";
# 	fi
# 	exit $code;
# }
# 
# #prints a message with the default output formatting
# function print {
# 	local msg="$1";
# 	__console_print_program_prefix;
# 	echo -e "$msg";
# }
# 
# function __console_print_program_prefix {
# 	local prefix="[${process_name:-}]";
# 	local include_prefix=${console_print_program_prefix:-};
# 	if [ ! -z "$include_prefix" ]; then
# 		if [ -t 1 ] && [ -z "$console_no_color" ]; then	
# 			if [ "$prefix" != "" ]; then
# 				gray "$prefix";
# 				echo -ne "$_result";
# 				echo -ne " ";
# 			fi
# 		else
# 			echo -n "$prefix ";
# 		fi
# 	fi
# }
# 
# #exits a program with a success message
# function console.success {
# 	
# 	if [ $# -eq 0 ]; then
# 		exit 0;
# 	fi
# 	
# 	local status="${console_prefixes[$FUNCNAME]}";
# 	local prefix="$status";
# 	local msg="";
# 	if [ -t 1 ] && [ -z "$console_no_color" ]; then
# 		#get the message prefix
# 		bold "$status";
# 		prefix="$_result";
# 
# 		#highlight the message and parameters
# 		msgs=( "default_style" "bold" "${@}" );
# 		console.colorize "${msgs[@]}";
# 		msg="$_result";
# 	else
# 		console.sprintf "${@}";
# 		msg="$_result";
# 	fi
# 	
# 	#output everything
# 	__console_print_program_prefix;
# 	echo -e "$prefix $msg";
# 	exit 0;
# }
# 
# function console.ok {
# 	local status="${console_prefixes[$FUNCNAME]}";
# 	local prefix="$status";
# 	local msg="";
# 	if [ -t 1 ] && [ -z "$console_no_color" ]; then
# 		#get the message prefix
# 		bold "$status";
# 		prefix="$_result";
# 
# 		#highlight the message and parameters
# 		msgs=( "default_style" "bold" "${@}" );
# 		console.colorize "${msgs[@]}";
# 		msg="$_result";
# 	else
# 		console.sprintf "${@}";
# 		msg="$_result";
# 	fi
# 	
# 	#output everything
# 	__console_print_program_prefix;
# 	echo -e "$prefix $msg";
# }
# 
# function console prompt {
# 	local status="${console_prefixes[$FUNCNAME]}";
# 	local prefix="$status";	
# 	local msg="";
# 	if [ -t 1 ] && [ -z "$console_no_color" ]; then
# 		#get the message prefix
# 		bold "$status";
# 		prefix="$_result";
# 
# 		#highlight the message and parameters
# 		msgs=( "default_style" "bold" "${@}" );
# 		console.colorize "${msgs[@]}";
# 		msg="$_result";
# 	else
# 		console.sprintf "${@}";
# 		msg="$_result";
# 	fi
# 	
# 	#output everything
# 	__console_print_program_prefix;
# 	echo -ne "$msg ";
# }
# 
# #outputs an info message
# function console info {	
# 	local status="${console_prefixes[$FUNCNAME]}";
# 	local prefix="$status";
# 	local msg="";
# 	if [ -t 1 ] && [ -z "$console_no_color" ]; then
# 		#get the message prefix
# 		bold "$status";
# 		prefix="$_result";
# 
# 		#highlight the message and parameters
# 		msgs=( "default_style" "bold" "${@}" );
# 		console.colorize "${msgs[@]}";
# 		msg="$_result";
# 	else
# 		console.sprintf "${@}";
# 		msg="$_result";
# 	fi
# 	
# 	#output everything
# 	__console_print_program_prefix;
# 	echo -e "$prefix $msg";
# }
# 
# # output a info message when the process is in debug mode
# function console.debug {
# 	# TODO: change prefix to debug
# 	if process.debug?; then
# 		console info "$@";
# 	fi
# }
# 
# #outputs a warning message
# function console warn {	
# 	local status="${console_prefixes[$FUNCNAME]}";
# 	local prefix="$status";
# 	local msg="";
# 	if [ -t 2 ] && [ -z "$console_no_color" ]; then
# 		#get the message prefix
# 		boldpurple "$status";
# 		prefix="$_result";
# 
# 		#highlight the message and parameters
# 		msgs=( "start_purple" "boldpurple" "${@}" );
# 		console.colorize "${msgs[@]}";
# 		msg="$_result";
# 	else
# 		console.sprintf "${@}";
# 		msg="$_result";
# 	fi
# 	
# 	#output everything
# 	__console_print_program_prefix;
# 	echo -e "$prefix $msg" >&2;
# }
# 
# 
# #outputs an error message
# function console error {
# 	local status="${console_prefixes[$FUNCNAME]}";
# 	local prefix="$status";
# 	local msg="";
# 	if [ -t 2 ] && [ -z "$console_no_color" ]; then
# 		#get the message prefix
# 		boldred "$status";
# 		prefix="$_result";
# 
# 		#highlight the message and parameters
# 		msgs=( "start_red" "boldred" "${@}" );
# 		console.colorize "${msgs[@]}";
# 		msg="$_result";
# 	else
# 		console.sprintf "${@}";
# 		msg="$_result";
# 	fi
# 	
# 	#output everything
# 	__console_print_program_prefix;
# 	echo -e "$prefix $msg" >&2;
# }
# 
# # generates a stack trace
# function console.trace {
# 	local offset="${1:-0}";
# 	local frame=$offset line;
# 	local data=( $( caller $frame ) );
# 	while [ "${#data[@]}" -gt 0 ]; do
# 		console error "%s:%s %s" "${data[2]}" "${data[0]}" "${data[1]}";
# 		: $((frame++));
# 		data=( $( caller $frame ) );
# 	done
# 	return 0;
# }
# 
# # print the generic header delimiter
# function console.header() {
# 	printf "${header:-}\n";
# }
# 
# # throws an error message and prints the stack trace
# function console.throw {
# 	local message="${1:-Unknown error}";
# 	#echo "throw message: $message";
# 	console error "$message";
# 	console.trace 1;
# }

# must set this option so that aliases are expanded
shopt -s expand_aliases;

# set up aliases for backward compatability
# WARNING: these aliases will be removed in a future
# version and you should use console info etc.
alias "console.info=console info";
alias "console.error=console error";
alias "console.warn=console warn";
alias "console.success=console success";
alias "console.quit=console quit";
alias "console.header=console header";
alias "console.ok=console ok";
alias "console.prompt=console prompt";
alias "console.log=console log";

# mask the info system executable
# legacy due to the old info command declaration
info() {
	console info "$@";
}

# alias "info=console info";
# alias "error=console error";
# alias "warn=console warn";
# alias "success=console.success";
# alias "quit=console quit";