if [ -z "${!summary[@]:-}" ]; then
	# the test summary must be global and exported for executables
	# using inline assertions to be picked
	declare -Ag summary;
	summary[suites]=0;
	summary[methods]=0;
	summary[executables]=0;
	summary[assertions]=0;
	summary[assertions.pass]=0;
	summary[assertions.fail]=0;
fi

# default to running as a standalone
declare -g __assert_standalone=true;

declare -g header;

# CONSTRUCTOR

function assert.initialize {
	string.repeat "+" 80;
	header="$_result";
}

# MANUAL ASSERTIONS

function assert.pass {
	__assert_ok "$FUNCNAME" "$@";
}

function assert.fail {
	__assert_err "$FUNCNAME" "$@";
}

# STRING ASSERTIONS

# asserts that two string values are equal
function assert.equal {
	local expected="${1:-}";
	local received="${2:-}";
	if [ "$expected" == "$received" ]; then
		__assert_ok "$FUNCNAME";
	else
		__assert_err "$FUNCNAME";
	fi
}

# asserts that a string matches a regex
function assert.match {
	local expected="${1:-}";
	local received="${2:-}";
	if [[ "$received" =~ $expected ]]; then
		__assert_ok "$FUNCNAME";
	else
		__assert_err "$FUNCNAME";
	fi
}

# asserts that a string does not matche a regex
function assert.match! {
	local expected="${1:-}";
	local received="${2:-}";
	if [[ "$received" =~ $expected ]]; then
		__assert_err "$FUNCNAME";
	else
		__assert_ok "$FUNCNAME";
	fi
}

# asserts that a string is empty, blank string
function assert.empty? {
	local expected="";
	local received="${1:-}";
	if [ -z "$received" ]; then
		__assert_ok "$FUNCNAME";
	else
		__assert_err "$FUNCNAME";
	fi
}

# NUMERIC ASSERTIONS

# asserts that an integer is greater than
# an expected value
function assert.gt {
	local expected="${1:-}";
	local received="${2:-}";
	if [ "$received" -gt "$expected" ]; then
		__assert_ok "$FUNCNAME";
	else		
		expected=">$expected";
		__assert_err "$FUNCNAME";
	fi
}

# asserts that an integer is less than
# an expected value
function assert.lt {
	local expected="${1:-}";
	local received="${2:-}";
	if [ "$received" -lt "$expected" ]; then
		__assert_ok "$FUNCNAME";
	else
		expected="<$expected";
		__assert_err "$FUNCNAME";
	fi
}

# asserts that an integer is equal to
# an expected value
function assert.eq {
	local expected="${1:-}";
	local received="${2:-}";
	if [ "$received" -eq "$expected" ]; then
		__assert_ok "$FUNCNAME";
	else
		expected="==$expected";
		__assert_err "$FUNCNAME";
	fi
}

# asserts that an integer is not equal to
# an expected value
function assert.ne {
	local expected="${1:-}";
	local received="${2:-}";
	if [ "$received" -ne "$expected" ]; then
		__assert_ok "$FUNCNAME";
	else
		expected="!=$expected";
		__assert_err "$FUNCNAME";
	fi
}

# FILE ASSERTIONS

# assert with -f
function assert.file.exists? {
	# TODO: add custom error message
	local expected="0";
	set +o errexit;
	`test -f "$1"`;
	local received="$?";
	set -o errexit;
	if [ "$expected" == "$received" ]; then
		__assert_ok "$FUNCNAME";
	else
		__assert_err "$FUNCNAME";
	fi
}

# assert that a file does not exist
function assert.file.exists! {
	# TODO: add custom error message
	local expected="1";
	set +o errexit;
	`test -f "$1"`;
	local received="$?";
	set -o errexit;
	if [ "$expected" == "$received" ]; then
		__assert_ok "$FUNCNAME";
	else
		__assert_err "$FUNCNAME";
	fi
}

# parses command line options to see whether
# this test is running standalone or from a test runner
function assert.parse {
	#echo "assert.parse: $@";
	: $((summary[executables]++));
	local i opt;
	for((i=1;i < $#+1;i++))
		do
			eval "opt=\"\${$i}\"";
			case $opt in
				--suite )
					__assert_standalone=false;
					;;
				--standalone )
					__assert_standalone=true;
					;;
			esac
	done
}

# output the assertion summary
function assert.summary {
	__assert.write.summary!;
	# if running standalone then
	# we print the summary
	if $__assert_standalone; then
		__assert.print.summary;
	fi
	return 0;
}

######################################################################
#
#	PRIVATE METHODS
#
######################################################################

function __assert.write.summary! {
	require.once json;	
	
	fs.walk "tasks";
	local base=$( dirname "$_result" );
	local target="${target:-}";
	if [ -z "${target}" ]; then
		target="${base}/target";
	fi
	local test_result_dir="${target}/test/result/bin";
	if [ ! -d "$test_result_dir" ]; then
		mkdir -p "$test_result_dir";
	fi
	local name="${process_dirs[root]}";
	name="${name#${base}/test}";
	name="${name#/}";
	name="${name#bin/}";
	name="${name//\//.}";
	if [ -z "$name" ]; then
		name="${process_name}";
	else
		name="${name}.${process_name}";
	fi
	local resultfile="${test_result_dir}/${name}.json";
	#echo "result file is: $resultfile : ${!summary[@]} : ${summary[@]}"
	json.stringify <<< "summary" || quit 1 "could not create json result data";
	json.string > "${resultfile}" || quit 1 "could not write test result file %s" "$resultfile";
}

function __assert_ok {
	local ttyout="${ttyout:-}";
	
	if [ -n "${!summary[*]}" ]; then
		: $((summary[assertions]++));
		: $((summary[assertions.pass]++));
	fi
	
	local assertion="$1";
	local stack=( $( caller 1 ) );
	local method="${stack[1]}";
	# FIXME: don't use fd 5, see: https://groups.google.com/forum/?fromgroups=#!topic/gnu.bash.bug/E5Vdqv3tO1w
	if [ ! -z "$ttyout" ]; then
		# save stdout in file descriptor #5		
		exec 5>&1;
		exec 1> /dev/tty;
	fi

	if [ $# -eq 1 ]; then
		console.ok "$assertion %s" "$method";
	elif [ $# -gt 1 ]; then
		# custom message
		console.ok "${@:2}";
	fi
	
	if [ ! -z "$ttyout" ]; then	
		# restore stdout and close file descriptor #5
		exec 1>&5 5>&-;
	fi
}

function __assert_err {
	
	if [ -n "${!summary[*]}" ]; then
		: $((summary[assertions]++));
		: $((summary[assertions.fail]++));
	fi
	
	local ttyerr="${ttyerr:-}";
	local assertion="$1";
	local stack=( $( caller 1) );
	local lineno="${stack[0]}";
	local method="${stack[1]}";
	local file="${stack[2]}";
	local frame="${file}:${lineno}";
	if [ ! -z "$ttyerr" ]; then
		# save stdout in file descriptor #6	
		exec 6>&1;
		exec 2> /dev/tty;
	fi
	
	if [ $# -eq 1 ]; then
		console.error "$assertion %s" "$method";	
		console.error "$frame";
		console.error "expected %s, got %s" "$expected" "$received";
	elif [ $# -gt 1 ]; then
		# custom message
		console.error "${@:2}";
	fi
	
	# FIXME: correct this test for the presence of the failures list?
	if [ "${!failures[@]}" ]; then
		failures["${frame}:${method}"]="$assertion";
	fi
	
	if [ ! -z "$ttyerr" ]; then
		# restore stderr and close file descriptor #6
		exec 1>&6 6>&-;
	fi
}

function __assert.print.header {
	local output="${1:-$output}";
	if [ -z "$output" ]; then
		output="console.log";
	fi
	$output "$header";
}

function __assert.print.summary {
	
	# switch output method for summary
	# based on any assertions failing
	local output="console.info";
	
	# some assertions failed
	if [ ${summary[assertions.fail]} -gt 0 ]; then
		output="console.warn";
	fi
	
	__assert.print.header $output;
	
	local testfiles=0;
	if [ ${summary[suites]} -gt 0 ]; then
		testfiles=$(( ${summary[suites]} - ${summary[executables]} ));
	fi
	
	$output "suites (total): %s" "${summary[suites]}";
	$output "suites (binary): %s" "${summary[executables]}";
	$output "suites (test): %s" "$testfiles";
	$output "methods: %s" "${summary[methods]}";
	$output "assertions: %s" "${summary[assertions]}";
	$output "assertions (pass): %s" "${summary[assertions.pass]}";
	
	if [ ${summary[assertions.fail]} -eq 0 ]; then
		console.info "assertions (fail): %s" "${summary[assertions.fail]}";
	else
		console.warn "assertions (fail): %s" "${summary[assertions.fail]}";
	fi
	
	if [ ${summary[assertions.fail]} -eq 0 ]; then
		__assert.print.header;		
		console.ok "test(s) passed %s" "✓";
		console.success;
	else
		
		__assert.print.header;
		console.warn "# FAILURES";
		__assert.print.header;		
		console.warn "# STDOUT: %s" "$stdout";
		console.warn "# STDERR: %s" "$stderr";
		__assert.print.header;
		
		local debuginfo;
		for debuginfo in ${!failures[@]}
			do
				local assertion="${failures[$debuginfo]}";
				local frame=${debuginfo%:*};
				local method=${debuginfo##*:};
				console.error "$assertion %s" "$method";
				console.error "$frame";
		done
		
		__assert.print.header;		
		
		console.error "test(s) failed %s" "✘";
		exit ${summary[assertions.fail]};
	fi
}