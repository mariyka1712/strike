# MANUAL ASSERTIONS

function assert.pass {
	__assert_ok "$FUNCNAME" "$@";
}

function assert.fail {
	__assert_err "$FUNCNAME" "$@";
}

# STRING ASSERTIONS

# asserts that two string values are equal
function assert.equal {
	local expected="${1:-}";
	local received="${2:-}";
	if [ "$expected" == "$received" ]; then
		__assert_ok "$FUNCNAME";
	else
		__assert_err "$FUNCNAME";
	fi
}

# asserts that a string matches a regex
function assert.match {
	local expected="${1:-}";
	local received="${2:-}";
	if [[ "$received" =~ $expected ]]; then
		__assert_ok "$FUNCNAME";
	else
		__assert_err "$FUNCNAME";
	fi
}

# asserts that a string does not matche a regex
function assert.match! {
	local expected="${1:-}";
	local received="${2:-}";
	if [[ "$received" =~ $expected ]]; then
		__assert_err "$FUNCNAME";
	else
		__assert_ok "$FUNCNAME";
	fi
}

# NUMERIC ASSERTIONS

# asserts that an integer is greater than
# an expected value
function assert.gt {
	local expected="${1:-}";
	local received="${2:-}";
	if [ "$received" -gt "$expected" ]; then
		__assert_ok "$FUNCNAME";
	else		
		__assert_err "$FUNCNAME";
	fi
}

# asserts that an integer is less than
# an expected value
function assert.lt {
	local expected="${1:-}";
	local received="${2:-}";
	if [ "$received" -lt "$expected" ]; then
		__assert_ok "$FUNCNAME";
	else
		__assert_err "$FUNCNAME";
	fi
}

# asserts that an integer is equal to
# an expected value
function assert.eq {
	local expected="${1:-}";
	local received="${2:-}";
	if [ "$received" -eq "$expected" ]; then
		__assert_ok "$FUNCNAME";
	else
		__assert_err "$FUNCNAME";
	fi
}

# FILE ASSERTIONS

# assert with -f
function assert.file.exists? {
	# TODO: add custom error message
	local expected="0";
	set +o errexit;
	`test -f "$1"`;
	local received="$?";
	set -o errexit;
	if [ "$expected" == "$received" ]; then
		__assert_ok "$FUNCNAME";
	else
		__assert_err "$FUNCNAME";
	fi
}

# assert that a file does not exist
function assert.file.exists! {
	# TODO: add custom error message
	local expected="1";
	set +o errexit;
	`test -f "$1"`;
	local received="$?";
	set -o errexit;
	if [ "$expected" == "$received" ]; then
		__assert_ok "$FUNCNAME";
	else
		__assert_err "$FUNCNAME";
	fi
}

######################################################################
#
#	PRIVATE METHODS
#
######################################################################

function __assert_ok {
	local ttyout="${ttyout:-}";
	
	local assertion="$1";
	local stack=( $( caller 1 ) );
	local method="${stack[1]}";
	if [ ! -z "$ttyout" ]; then
		# save stdout in file descriptor #5		
		exec 5>&1;
		exec 1> /dev/tty;
	fi

	if [ $# -eq 1 ]; then
		console.ok "$assertion %s" "$method";
	elif [ $# -gt 1 ]; then
		# custom message
		console.ok "${@:2}";
	fi
	
	if [ ! -z "$ttyout" ]; then	
		# restore stdout and close file descriptor #5
		exec 1>&5 5>&-;
	fi
}

function __assert_err {
	local ttyerr="${ttyerr:-}";
	local assertion="$1";
	local stack=( $( caller 1) );
	local lineno="${stack[0]}";
	local method="${stack[1]}";
	local file="${stack[2]}";
	local frame="${file}:${lineno}";
	if [ ! -z "$ttyerr" ]; then
		# save stdout in file descriptor #6	
		exec 6>&1;
		exec 2> /dev/tty;
	fi
	
	if [ $# -eq 1 ]; then
		console.error "$assertion %s $frame" "$method";	
		console.error "expected %s, got %s" "$expected" "$received";
	elif [ $# -gt 1 ]; then
		# custom message
		console.error "${@:2}";
	fi
	
	if [ ! -z "$ttyerr" ]; then
		# restore stderr and close file descriptor #6
		exec 1>&6 6>&-;
	fi
}