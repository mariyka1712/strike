: <<'ronn:markdown'
task-deploy(7) -- deploy task(s) for bake(1)
=============================================

## SYNOPSIS

Deploy task(s) for bake(1).

## DESCRIPTION

Performs a deployment for a project.

## REQUIRE

You do not need to require(3) this task as it is a builtin task.

## USAGE

	bake deploy [options...] [profiles...]
	
## OPTIONS

* `--ok`:

Disable interactivity and assume *yes* for every prompt.

* `--noop`:

Print commands but do not execute them, implies `--ok` to disable interactivity.

* `--all`:

Deploy all profiles in the descriptor.

* `--name [name]`:

Override the default project name (determined by the name of the parent directory), see `NAMES` for project and profile name rules.

* `--directory [directory]`:

Use *directory* for deployment. When this option is specified it overrides any directory specified in *deploy.json* for all profiles.

* `--host [user@host]`:

The scp(1) and ssh(1) *user@host* specification. When this option is specified it overrides any host properties in *deploy.json*. This is useful if you wish to deploy everything using the profile(s) in *deploy.json* to a different host.

* `--descriptor [file]`:

Use *file* as the deployment descriptor.

* `--script-source [script]`:

Use *script* as the deployment script instead of any generated script. The *script* must exist and be executable. When this option is specified then the automatically generated script is ignored and the source *script* is used instead. It is written to disc in the same location, deployed to the remote host (or localhost with the `--local` option) and executed.

When this option is specified the `--shell` option has no effect as it is only used to determine the *shebang* for generated deployment scripts.

If multiple profiles are being deployed then *script* is used for all active deployment profiles.

* `--shell [shell]`:

Use *shell* for the script shebang. Must be one of *sh*, *bash*, *zsh* or *dash*.

* `--staging [directory]`:

Use *directory* as the staging directory.

* `--lint`:

Perform a sanity check on the generated script and exit, implies `--noop`. You must have the *checkbashisms* script installed in \$PATH in order to use this option. Useful for debugging the generated script. This can be used in conjunction with the `--script` option to inspect the script output as well as run the script through *checkbashisms*.

Note that when using the `--script-source` option the source script becomes the target for this operation. If the `--shell` option has been specified then the *shebang* will not be `#!/bin/sh` which will cause *checkbashisms* to output a warning but still pass the lint operation if there are no errors.

* `--lint-run`:

Executes the script in the local target directory in the context of the *localhost*, implies `--lint` and `--noop`. The script is only executed if the `--lint` operation succeeds. Useful for testing and debugging purposes.

* `--list`:

List profile names in a deployment descriptor.

* `--log`:

Redirect *stdout* messages to `target/deploy/deploy.log`. Note that when using the `--json` option that the JSON document is always sent to *stdout*.

* `--flat`:

Do not include the profile name in the target directory, see `TARGET` for more information.

* `--include-version`:

Include version information in the target directory, see `TARGET` for more information.

* `--local`:

Perform a deployment on the local host.

* `--json`:

Dump all profile configuration settings that would be used by a deployment as a JSON document to *stdout*, implies `--noop`. This is useful to determine the settings that would be used when running a deployment.

If this option is used in conjunction with `--script` the last option will take preference.

* `--pretty`:

Use in conjunction with the `--json` option to pretty print the JSON document. Uses two spaces as the indentation.

* `--write-json`:

Write the deployment settings to `target/deploy/settings.json`. If used in conjunction with the `--json` option then the settings will be printed to *stdout* and written to disc. The generated document will be formatted if the `--pretty` flag has been set.

* `--script`:

Dump script(s) to *stdout*, implies `--noop`. If this option is used in conjunction with `--json` the last option will take preference. Note that when this option is used the script(s) are still written to `target/deploy`.

* `--no-local`:

Shortcut for combining `--no-local-pre` and `--no-local-post`.

* `--no-local-pre`:

Do not execute the pre-deployment commands on the local host.

* `--no-local-post`:

Do not execute the post-deployment commands on the local host.

* `--no-remote`:

Shortcut for combining `--no-remote-pre` and `--no-remote-post`.

* `--no-remote-pre`:

Do not execute the pre-deployment commands on the remote host.

* `--no-remote-post`:

Do not execute the post-deployment commands on the remote host.

* `--no-growl`:

Do not send growl notifications.

* `--expand`:

Do not quote command options. When this options is set parameter expansion is performed on command options declared in a deployment descriptor.
	
## TYPES

The deploy tasks support the *git*, *tar* and *npm* deployment types.

### GIT

This deployment type will clone if the deployment directory does not exist and fetch the specified branch from the remote repository.

### TAR

This deployment type will fetch a tarball from a filesystem path or remote URL and extract the contents to the target directory.

### NPM

This deployment type uses npm(1) to fetch a package and then copies over the extracted contents of the package to the `target` directory.

## JSON FORMAT

The format of the *deploy.json* descriptor is described in the task-deploy-json(7) man page, to view this man page run:

	bake help deploy-json
	
## TARGET

The final deploy target is a combination of the *directory*, *name* and *profile* by default. Assuming a *directory* of `~/www` and the project name `project` with a deployment profile of `stage` the target used for deployment is:

	~/www/project/stage
	
If you do not wish to include the profile name in the target directory specify the `--flat` option which results in:

	~/www/project
	
It depends upon your deployment requirements as to which strategy you wish to use. Generally, if you are deploying to the same host then it makes sense to separate the deployment profiles, whereas if each deployment profile is using a different host then it is more consistent to have the same directory structure across the different hosts.

You may also create separate deployment targets based on the project version using the `--include-version` option. Continuing the above example with a version of `0.0.1` and the default behaviour (no `--flat` option specified) then the target becomes:

	~/www/project-0.0.1/stage
	
Or alternatively in conjunction with the `--flat` option the target directory becomes:

	~/www/project-0.0.1
	
## PROFILES

You may specify one or more profiles to deploy after any options. If no profiles are specified then a deploy is attempted using the *default* profile.

## DEFAULT PROFILE

The default profile uses a *git* deployment type and the current branch and git remote URL for deployment to the target host.

## NAMES

Profile and project names may not start with a hyphen and should match the pattern ^[-a-zA-Z0-9]+.

## STRICT

The deployment process is strict. Failure is always assumed and when deploying multiple profiles, failure of a profile to deploy will prevent any subsequent profiles from being processed.

## FILES

A *deploy.json* file must be present in the root of the project and must be valid JSON. This file may just contain '{}' if you wish to use the *default* profile and configure deployment parameters via environment variables or command line options.

## ENVIRONMENT

* `bake_deploy_remote`:

The remote host used for deployment when none is specified in *deploy.json*.

* `bake_deploy_shell`:

The shell used on the remote server, defaults to `sh` if none is specified.

* `bake_deploy_staging`:

The directory used on the remote server for staging deployment scripts, default is `~/.deploy`.

## COMMAND EXECUTION

The deployment process can optionally execute arbitrary simple commands on the local and remote host. For each host, command execution is split into the pre-deployment and post-deployment execution phases.

Note that when running a local deployment (using `--local`) then remote commands are executed on the local host.

If any command exits with an exit code *>0* then the deployment is aborted. This is useful for running tests prior to performing a deployment or other tasks such as creating a tarball package.

The general syntax for declaring commands is:

	"commands": {
	  "local": {
	    "pre": [
	      {
	        "command": "ls",
	        "options": [ "-la", "lib", "man" ]
	      }
	    ],
	    "post": [
	      {
	        "command": "echo",
	        "options": [ "deployment complete $deploy_name" ]
	      }
	    ]
	  }
	}
	
All commands are encapsulated by the *commands* object which can contain *local* and *remote* properties indicating whether the commands should be executed on the local or remote host. The *pre* and *post* properties are arrays of commands to execute for the deployment phase(s).

A *commands* object may be declared at the top-level of the JSON descriptor document, in which case the commands will be executed for *all* profiles. A *commands* object may also be declared in a profile to execute commands specific to that profile. When *commands* are declared at the top-level of the document and in a profile then they are concatenated together and all commands are executed.

### Parameter Expansion

By default parameters are not expanded - whitespace in a parameter is preserved and passed as a single argument to the command being executed. For example, imagine you wanted to list the contents of the *lib* and *man* directories, this would fail (with the default settings) if you specified both directories in a single option (`ls` would be looking for a directory named "lib man" rather than attempting to list two separate directories):

	{
	  "command": "ls",
	  "options": [ "-la", "lib man" ]
	}
	
You have two options to remedy this scenario. You may either decide to separate the parameters:

	{
	  "command": "ls",
	  "options": [ "-la", "lib", "man" ]
	}
	
So that the *lib* and *man* are passed as separate arguments to *ls*. Or you may use the `--expand` option to allow parameter expansion on command options. You should only use the `--expand` option if you are certain that you do not want to include whitespace in any options passed to command(s) being executed.

### Command Environment

Commands executing in a *local* context have access to the entire bake(1) variable scope chain which means that there are some useful variables exposed to your commands.

* `project_name`:

The name of the project.

* `project_version`:

The project version.

* `root`:

The project root directory.

* `project`:

The root directory for multi-module projects, when bake(1) is executing at the root of a multi-module project then `root` and `project` point to the same directory.

* `target`:

The `target` directory relative to `${root}` used by bake(1) for staging files.

* `profile`:

The name of the profile currently being deployed.

* `deploy_target`:

The final target directory used for the deployment, see the `TARGET` section.

* `deploy_name`:

The human readable name used by task-deploy(7). This is the project name and version delimited by @, for example: project@0.0.1.

* `deploy_file_name`:

The prefix used when defining file names. Uses - as the delimiter, for example: project-0.0.1.

* `script_name`:

The name of the script that will be used by task-deploy(7) for deployment.

* `script`:

The path to the script that will be used to perform deployment.

* `log`:

The path to the log file used by task-deploy(7).

* `logging`:

A boolean indicating whether output is being redirected to the file defined by the *log* variable.

* `type`:

The type of deployment being performed, see the `TYPES` section.

* `noop`:

A boolean indicating if this deployment is a non-operation, will be *true* if the `--noop` option has been specified.

* `flat`:

A boolean indicating if a flat directory structure is being used, see the `TARGET` section.

* `include_version`:

A boolean indicating if version information is being included in the directory structure, see the `TARGET` section.

### Custom Environment

You may declare properties specific to your deployment process in a top-level *env* object. You may then access these variables in your deployment profiles using the `env_` variable prefix.

Properties declared in the *env* object may reference any variable documented in the `Command Environment` section but they may not use `Cross References` using a `json_` variable prefix.

If you attempt to create a document cross-reference in an *env* property task-deploy(7) will exit immediately with a *>0* exit code.

See the section `Command Examples` for example(s).

### Cross References

It is recommended that you use the functionality provided by `Custom Environment` whenever possible but if you absolutely must reference other data in a deployment profile this section provides some information on using deployment descriptor cross-references.

The JSON document properties are expanded to variables that you may reference in the deployment descriptor. These variables are exposed using a `json_` prefix.

This is useful to prevent duplication of information between profiles that share some (but not all) commands or properties.

Consider the following example document:

	{
	  "host": "user@example.com",
	  "directory": "~/www",
	  "commands": {
	    "local": {
	      "pre": [
	        {
	          "command": "echo",
	          "options": [ "$json_directory", "$json_host" ]
	        }
	      ]
	    }
	  }
	}
	
In this instance the `\$json_` variables reference the *directory* and *host* properties declared at the top-level of the document.

This results in the command (for the local host pre-deployment phase):

	echo ~/www user@example.com
	
When the command is executed it generates the output:

	~/www user@example.com

You may reference any property in the document by full path delimited by an underscore (_) for the variable name.

To illustrate, a convoluted example which generates the same output as the above example but also prepends the command being executed and appends the number of options being passed to the command:

	{
	  "host": "user@example.com",
	  "directory": "~/www",
	  "commands": {
	    "local": {
	      "pre": [
	        {
	          "command": "echo",
	          "options": [
	            "$json_commands_local_pre_0_command",
	            "$json_directory",
	            "$json_host",
	            "$json_commands_local_pre_0_options_length"
	          ]
	        }
	      ]
	    }
	  }
	}
	
The command becomes:

	echo echo ~/www user@example.com 4
	
Which generates the *output*:

	echo ~/www user@example.com 4
	
Notice how you can access array elements by index and also the the *length* properties of array types.
	
### Command Errors

Commands (declared by the *command* property) may not contain any whitespace (space, tab or newline). It is a JSON error to declare literal whitespace characters such as \\n or \\t, if these are specified using the escaped values (allowed by JSON) the program will exit with a whitespace error.

If you reference a variable that is unbound in a command the program will exit immediately with a >0 exit code and an error message.

### Command Examples

A complete example that uses npm(1) to create a tarball, moves it to the local `target` staging directory and copies the tarball to a remote host prior to the main deployment process which will take the created archive (on the remote host) and deploy it to the *target* directory:

	{
	  "env": {
	    "archive": {
	      "name": "${project_name}-${project_version}.tgz",
	      "dir": "$target",
	      "path": "${target}/${project_name}-${project_version}.tgz"
	    }
	  },
	  "host": "user@example.com",
	  "directory": "~/www",
	  "profiles": {
	    "npm": {
	      "type": "tar",
	      "url": "~/$env_archive_name",
	      "commands": {
	        "local": {
	          "pre": [
	            {
	              "command": "npm",
	              "options": [ "pack" ]
	            },
	            {
	              "command": "mv",
	              "options": [ "$env_archive_name", "$env_archive_dir" ]
	            },
	            {
	              "command": "scp",
	              "options": [ "$env_archive_path", "${host}:~/" ]
	            }
	          ]
	        }
	      }
	    }
	  }
	}
	
## DEPLOYMENT PROCESS

This section describes the process that task-deploy(7) uses to perform a deployment assuming that no command line options (other than profile(s)) have been specified on the command line, see `OPTIONS` for how command line options influence behaviour.

Load and parse the deployment descriptor JSON document and exit with a *>0* exit code if invalid JSON is encountered.

Start processing of the target profiles specified on the command line, profile execution order is the order that profiles are specified on the command line or non-determinate when executing all profiles.

If no profiles are specified on the command line then a *default* profile is assumed, see `DEFAULT PROFILE`.

Before profile execution starts command line options are processed that may override any settings in the deployment descriptor and the deployment descriptor is evaluated using `eval` so that variable references declared in a deployment descriptor are resolved correctly in the context of the current profile being executed. If any errors are encountered task-deploy(7) exits with a *>0* exit code.

An interactive prompt is displayed asking for confirmation that you wish to deploy the profile.

If global and/or profile-specific *local* pre-deployment commands have been specified they are executed, if any command exits with a *>0* exit code the deployment is aborted.

At this point the deployment process starts. When running as a *local* deployment (using `--local`) then the deployment script is copied to the local filesystem staging directory otherwise the deployment script is transferred to the staging directory on the remote host using scp(1).

If global and/or profile-specific *remote* pre-deployment commands have been specified they are executed, if any command exits with a *>0* exit code the deployment is aborted.

The deployment script is executed to perform the deployment based on the deployment type for the profile, see `TYPES`.

If the deployment script detects any error the deployment process is aborted.

If global and/or profile-specific *remote* post-deployment commands have been specified they are executed on the remote host by the deployment script.

If global and/or profile-specific *local* post-deployment commands have been specified they are executed on the local host.

Success or failure notifications are delivered.

## INTERACTIVE

Deploying code is an important process and task-deploy(7) by design presents confirmation prompt(s) to ensure you wish to proceed.

This interactivity can be disabled in a variety of ways which is often necessary when executing a deployment from another program or if you are re-deploying in quick succession. The recommended way is to specify the `--ok` option.

If the `--noop` option is specified interactive prompt(s) are not displayed as no commands are executed.

Interactive prompts write to *stdout* and read from *stdin* you may also disable interactivity by piping to *stdin* or redirecting *stdout*. For example:

	echo "" | bake deploy
	bake deploy > target/deploy.log

## NOTIFICATIONS

If the *growlnotify* executable is available then a success or failure notification will be sent using *growlnotify*. Note that *growlnotify* notifications are *not* sent for a `noop` which is the case if the `--noop`, `--json` or `--script` options are specified.

You may disable the use of growl notifications by specifying the `--no-growl` option.

## FILES

All generated files are written to `target/deploy`.

When the `--log` option is specified *stdout* messages are redirected to `target/deploy/deploy.log`.

The generated script file(s) are written to `target/deploy` using the following naming strategy:

	${name}-${version}-${profile}.sh
	
If the `--write-json` option is specified then the deployment settings are written to `target/deploy/settings.json`.

## EXIT CODES

A >0 exit code indicates failure while a 0 exit code indicates success.

## EXAMPLES

Deploy using the default profile:

	bake deploy
	
Deploy to *localhost* using the default profile:

	bake deploy --local
	
Deploy the profile *stage*:

	bake deploy stage

Deploy the profiles *test*, *stage* and *production*:

	bake deploy test stage production

Deploy all profiles in the descriptor:

	bake deploy --all	
	
Inspect deployment commands but do not execute them:

	bake deploy --noop
	
List profiles in *deploy.json*:

	bake deploy --list
	
List profiles in a specific descriptor:

	bake deploy --list --descriptor ~/project/deploy.json
	
Print the script that will be used for deployment:

	bake deploy --script
	
Inspect the settings used for a *default* deployment:

	bake deploy --json --pretty \\
		--staging ~/project-staging \\
		--name project \\
		--directory ~/www
		
Display this man page:

	bake help deploy

## ROADMAP

Add npm(1) deployment type.

Add rsync(1) deployment type.

Implement lock files for the local and remote scripts to prevent concurrency issues when multiple deployments are attempted.

Add ability to rollback a deployment if an existing `target` directory existed prior to deployment and the deployment process fails (such as due to a network error).

Add `--branch` option to specify a git branch to use for all profiles that are of the `git` type.

Add `--refspec` option so that `git` deployments may also be done from tags.

Implement notifications using `mail`.

Attach log file(s) to `mail` notifications.

Add the `deploy_ssh_options` and `deploy_scp_options` environment variables so that custom options (such as port numbers) can be passed on to ssh(1) and scp(1).

Add `enable` boolean property to profiles in a descriptor to prevent deployment of a profile.

## BUGS

**task-deploy** is written in bash and depends upon `bash` >= 4.2.

## COPYRIGHT

**task-deploy** is copyright (c) 2012 muji <http://xpm.io>

## SEE ALSO

bake(1), task-deploy-json(7)
ronn:markdown

require.once 'json';
require.once 'git';

# module libraries
require.library 'deploy.script';

# list of property names that are first set
# from the top-level of a document and then
# overriden by declarations in specific profiles
# these properties are shared by all deployment types
declare -ag deploy_property_names;
deploy_property_names=(
	"host"
	"directory"
	"type"
	"url"
	"description"
	"package"
	"directory"
	"staging"
);

# deploy delegate
tasks.deploy() {
	executable.validate scp ssh;
	executable.validate --test growlnotify;
	
	# interactive by default
	local interactive=true;
	
	# list of all profiles
	# defined in descriptor
	local all_profiles=();
	
	# --list: determine if we are just
	# printing profiles available in descriptor
	local print_profiles=false;
	
	# determine if we are deploying
	# all profiles in descriptor, see --all
	local deploy_all=false;
	
	# run script through checkbashisms and exit
	local lint=false;
	local run_script=false;
	
	# the prefix used for deployment
	# interactive prompts
	local deploy_prompt_prefix="\033[1m[deploy]\033[0m";
	local deploy_prompt="${deploy_prompt_prefix} \033[4m%s\033[0m";
	local deploy_prompt_suffix=" ⚡";
	
	# start time for the entire deployment
	local deploy_start_time=$( date );
	local deploy_local_host_name=$( hostname );
	local deploy_user=$( id -nu );

	local descriptor="${root}/deploy.json";
	local newline=$'\n';
	
	# name validation regex
	local re="^[-a-zA-Z0-9]+$";
	
	# list of supported shells
	local shells=( sh bash zsh dash );

	# default to git deployment
	local default_type="git";	
	local type="${default_type}";
	local profile="default";
	local directory="";
	local shell="${bake_deploy_shell:-sh}";
	local host="${bake_deploy_remote:-}";
	local staging="${bake_deploy_staging:-~/.deploy}";
	local git_url git_branch;
	git.remote.url "git_url";
	git.branch.current "git_branch";	
	
	# human readable name using @ delimiter
	# must be set after option parsing in case a --name
	# option has been specified
	local deploy_name="${project_name}@${project_version}";
	# file name using a - delimiter	
	local deploy_file_name="${project_name}-${project_version}";
	
	# profile specific variables
	local script_name="${deploy_file_name}.sh";
	local script="${target}/${script_name}";
	local log_name="${deploy_file_name}.log";
	local log_dir="${staging}/log";
	local log_file="${log_dir}/${log_name}";
	
	# messages
	declare -A messages;
	# messages sent via `growlnotify`
	messages[success]="deploy ${deploy_name} complete";
	messages[fail]="deploy ${deploy_name} failed";	
	
	local deploy_target_directory="${target}/deploy";
	if [ ! -d "${deploy_target_directory}" ]; then
		mkdir -p "${deploy_target_directory}" \
			|| :tasks.deploy.fail "could not create %s" "${deploy_target_directory}";
	fi
	
	local log="${deploy_target_directory}/deploy.log";
	local logging=false;
	# clear the log file
	printf "" >| "${log}";	
	
	# non-operation
	local noop=false;
	
	# quote command options by default
	local quote=true;
	
	# stores flags used to skip command
	# execution phases
	declare -A skip;
	skip["local.pre"]=false;
	skip["local.post"]=false;
	skip["remote.pre"]=false;
	skip["remote.post"]=false;
	skip["growl"]=false;

	# valid deployment types
	local types=( git tar npm );
	
	local profiles=();
	
	# a custom script file to use
	# instead of the generated script
	local script_source="";
	
	# determine if we are deploying locally
	local deploy_local=false;
	
	# include version information in the target
	local include_version=false;
	
	# dump script contents to stdout
	local dump_script=false;

	# strategy used to determine the target
	# directory. the default is to include
	# the profile name in the target directory
	# structure
	local flat=false;
	
	# command line options that override
	# properties set in deploy.json
	declare -A overrides;
	
	# JSON PROPERTIES
	# determines whether we are generating json
	local print_json=false;
	local write_json=false;
	local json_settings_file="${deploy_target_directory}/settings.json";
	local pretty=false;
	# array used to store properties to be
	# dumped as json
	declare -A json_dump;
	json_dump["project-version"]="${project_version}";

	# assume failure
	local success=false;
	
	# parse options
	:tasks.deploy.options.parse "$@";
	
	# validate the descriptor after option parsing
	:tasks.deploy.descriptor.validate;
	
	:tasks.deploy.parse;
	
	local default_profile="default";
	# if we are deploying everything
	if $deploy_all; then
		profiles=( ${all_profiles[@]} );
	fi
	
	# attempt to deploy the default profile
	# if profiles are empty this will occur
	# if none are specified on the command line
	# or none exist in the descriptor
	if [ ${#profiles[*]} -eq 0 ]; then
		profiles+=( "${default_profile}" );
	fi
	
	# prevent duplicate executions if a command line
	# declaration declares the same profile name
	:tasks.deploy.profiles.uniq!;
	
	# update some json dump properties after option parsing
	json_dump["project-name"]="${project_name}";	
	json_dump["descriptor"]="${descriptor}";
	json_dump["noop"]="${noop}";
	json_dump["local"]="${deploy_local}";
	local i;
	for i in ${!profiles[@]}
		do
			json_dump["targets.$i"]="${profiles[$i]}";
	done
	
	# validate whitespace on the project name
	:tasks.deploy.whitespace.validate "${project_name}" "project name";
	# validate whitespace on the staging property
	:tasks.deploy.whitespace.validate "${staging}" "staging";
	
	# validate the shell in use
	if ! array.contains? "$shell" "${shells[@]}"; then
		:tasks.deploy.fail "shell %s is not supported" "$shell";
	fi
	
	# configure the shebang
	local shebang="#!/bin/sh";
	if [ "${shell}" != "sh" ]; then
		shebang="#!/usr/bin/env ${shell}";
	fi
	
	# deploy all profiles
	:tasks.deploy.profiles;

	# show the complete message
	:tasks.deploy.complete;
}

# DEPLOY PRIVATE COMMANDS

# validate a descriptor file
:tasks.deploy.descriptor.validate() {
	if [[ ! "${descriptor}" =~ \.json$ ]]; then
		:tasks.deploy.fail "descriptor %s does not have a .json file extension" \
			"${descriptor}";
	fi
	if [ ! -f "${descriptor}" ]; then
		:tasks.deploy.fail "no deploy descriptor %s" "${descriptor}";
	fi
}

# make profile list unique
:tasks.deploy.profiles.uniq!() {
	local IFS=$'\n';
	local lines=( ${profiles[*]} );
	unset IFS;
	profiles=( $( printf "${lines[*]}" | sort | uniq ) );
}

# deploy a series of profiles
:tasks.deploy.profiles() {
	local profile;

	# print profiles being processed
	:tasks.deploy.print.profiles;
	
	for profile in "${profiles[@]}"
		do
			if [ "${profile}" != "${default_profile}" ]; then
				if ! array.contains? "${profile}" "${all_profiles[@]:-}"; then
					console.warn "profile %s does not exist in %s" "${profile}" "${descriptor}";
					continue;
				fi
			fi
			# now attempt to deploy the profile
			:tasks.deploy.profile;
	done
	# dump/write json information
	if $print_json || $write_json; then
		if ! $pretty; then
			json.stringify <<< "json_dump";
		else
			json.stringify --pretty 2 <<< "json_dump";
		fi
		if $print_json; then
			json.string;
			printf "\n";
		fi
		if $write_json; then
			printf "" >| "$json_settings_file";
			json.string >> "$json_settings_file";
			printf "\n" >> "$json_settings_file";
		fi
	fi
}

# deploy a single profile
:tasks.deploy.profile() {
	
	# stores command to execute
	# for all profiles
	declare -A global_commands;
	
	# stores command to execute
	# for a profile
	declare -A profile_commands;
	
	# update profile specific variables
	script_name="${deploy_file_name}-${profile}.sh";
	script_dir="${deploy_target_directory}";
	script="${script_dir}/${script_name}";
	log_name="${deploy_file_name}-${profile}.log";
	log_dir="${staging}/log";
	log_file="${log_dir}/${log_name}";
	
	# TODO: allow for the version to be included in the target directory
	local target_name="${project_name}";
	if $include_version; then
		target_name="${deploy_file_name}";
	fi
	# the full deployment target directory
	local deploy_target;
	
	# cascade properties
	:tasks.deploy.cascade;
}

# start execution of a profile
:tasks.deploy.profile.start() {
	
	# run local pre-deployment command execution
	:tasks.deploy.run.pre;
	
	echo "start deployment !!!";

	# scp the script to the remote server
	# :tasks.deploy.script.push!;		
	
	# run local post-deployment command execution
	:tasks.deploy.run.post;	
}

# cascade properties from the root of the document
# overwriting with profile specific properties if
# they have been set and finally with cli overrides
:tasks.deploy.cascade() {
	local prop var val;
	for prop in "${deploy_property_names[@]}"
		do
			val="";
			var="$prop";
			var="${var//[^a-zA-Z0-9_]/_}";
			
			# set top-level property
			if [ -n "${json_doc[$prop]:-}" ]; then
				val="${json_doc[$prop]:-}";
				# echo "setting top-level property: $var=$val";
			fi
			
			# set profile-specific property
			if [ -n "${json_doc[profiles.${profile}.${prop}]:-}" ];then
				val="${json_doc[profiles.${profile}.${prop}]}";
				# echo "setting profile property ($profile): $var=$val";
			fi
			
			# override with command line option
			if [ -n "${overrides[${prop}]:-}" ];then
				val="${overrides[${prop}]}";
				# echo "setting cli override: $var=$val";
			fi
			
			# set the variable
			if [ -n "$val" ]; then
				eval "local $var=\"\${val}\"";
			fi
	done
	
	# verify deployment type is valid
	local type="${type:-git}";
	if ! array.contains? "${type:-}" "${types[@]}"; then
		:tasks.deploy.fail "invalid deployment type %s" "${type:-}";
	fi
	
	# validate required data
	if ! $deploy_local && [ -z "${host}" ]; then
		:tasks.deploy.fail "no remote host information available for deploy";
	fi
	
	# set up the full deployment target directory
	deploy_target="${directory}/${target_name}";
	if ! $flat; then
		deploy_target="${deploy_target}/${profile}";
	fi
	
	if [ -z "${staging}" ]; then
		:tasks.deploy.fail "staging directory may not be empty";
	elif [[ "${staging}" =~ ^/+$ ]]; then
		:tasks.deploy.fail "staging directory may not be at the filesystem root";
	fi
	
	# NOTE: reading commands should be done
	# NOTE: after setting all relevant variables
	# NOTE: so that all variables are available to commands being
	# NOTE: declared in the deploy.json descriptor
	
	local json_key json_value env_re="^env_." env_json_re="\\\$json_";
	# 1) expand properties in an `env`
	# 1) object exposed by direct variable name
	# 2) expand JSON document properties
	# 2) to json_ local variables
	# 2) so that descriptor documents may
	# 2) cross-reference properties
	for json_key in "${!json_doc[@]}"
		do
			json_value="${json_doc["$json_key"]}";
			# sanitized to _ delimiter for variable names
			json_key="${json_key//\./_}";
			if [[ ! "$json_key" =~ $env_re ]]; then
				# escape dollar symbols as `eval`
				# is invoked later on
				json_value="${json_value//\$/\\\$}";
								
				# prefix with json_ for non-env properties
				json_key="json_${json_key}";
			else
				if [[ "$json_value" =~ $env_json_re ]]; then
					:tasks.deploy.fail \
						"invalid %s cross-reference in %s" \
						"json" "env";
				fi
			fi
			
			#sanitize variable name
			json_key="${json_key//[^a-zA-Z0-9_]/_}";
			
			# echo "expanding $json_key : $json_value";
			# declare variable
			eval "local $json_key=\"$json_value\"";
	done
	
	# read in global commands
	:tasks.deploy.commands.read;
	
	# read in profile specific commands
	:tasks.deploy.commands.read "profiles.${profile}";
	
	# ready to start, output useful settings information
	:tasks.deploy.info;	
	
	if ! $print_json; then
		# write the deploy script file
		:tasks.deploy.script.write!;
	fi
	
	# run script through `checkbashisms`
	if $lint; then
		:tasks.deploy.script.lint;
	fi

	if ! $dump_script && ! $print_json; then
	
		# prompt for confirmation when possible
		:tasks.deploy.confirm ":tasks.deploy.profile.start" "$profile";
	fi
	
	# clean up
	unset type;
	unset host;
	unset directory;
	unset profile_commands;	
}

# run pre-deployment local commands
:tasks.deploy.run.pre() {
	if "${skip["local.pre"]}"; then
		return 0;
	fi
	if [ "${#global_commands[@]:-0}" ]; then
		:tasks.deploy.run "commands.local.pre" true;
	fi
	:tasks.deploy.run "commands.local.pre";
}

# run post-deployment local commands
:tasks.deploy.run.post() {
	if "${skip["local.post"]}"; then
		return 0;
	fi
	if [ "${#global_commands[@]:-0}" ]; then
		:tasks.deploy.run "commands.local.post" true;
	fi	
	:tasks.deploy.run "commands.local.post";
}

# run a set of local commands
:tasks.deploy.run() {
	local varname="$1";
	local use_global_commands="${2:-false}";
	local cmd list arr exe opt exit_code;
	
	# shortcut out for empty command maps	
	local length=0;
	if $use_global_commands; then
		length="${global_commands["${varname}.length"]:-0}";
	else
		length="${profile_commands["${varname}.length"]:-0}";
	fi
	if [ $length -eq 0 ]; then
		return 0;
	fi
	
	# build list of commands to execute
	list=();
	:tasks.deploy.run.list;
	for cmd in "${list[@]:-}"
		do
			# echo "cmd is : ${cmd}";
			local IFS=$'\n';
			arr=( ${cmd} );
			unset IFS;
			if [ ${#arr[@]} -gt 0 ]; then
				#echo "arr length is :: ${#arr[@]}";
				exe="${arr[0]}";
				local IFS=$'\n';
				opt=( "${arr[@]:1}" );
				unset IFS;
				:tasks.deploy.out.info "exec %s %s" "${exe}" "${opt[*]:-}";
				
				# echo "run command : ${exe} : ${opt[@]:-}";
				
				# validate the executable being executed
				executable.validate --test "${exe}";
				if [ -z "${executables[$exe]}" ]; then
					:tasks.deploy.fail "executable %s is not available" "$exe";
				fi
				
				#echo "run command (after validation) : ${exe} : ${opt[@]:-} : length:  ${#opt[@]}";
				
				# execute the command
				if ! $noop; then
					if ! $logging; then
						if $quote; then
							( ${exe} "${opt[@]:-}" ); exit_code=$?;
						else
							( ${exe} ${opt[@]:-} ); exit_code=$?;
						fi
					else
						if $quote; then
							( ${exe} "${opt[@]:-}" >> "${log}" 2>&1 );
							exit_code=$?;
						else
							( ${exe} ${opt[@]:-} >> "${log}" 2>&1 );
							exit_code=$?;
						fi
					fi
					if [ $exit_code -gt 0 ]; then
						:tasks.deploy.fail "execution error %s %s" "$exe" "${opt[*]:-}";
					fi
				fi
			fi
	done
}

# fetch the command type subset 
# as an ordered array of commands
:tasks.deploy.run.list() {
	local k v keys i;
	local re="${varname//\./\\.}";
	re="^$re\.([0-9]+)";
	if $use_global_commands; then
		for k in "${!global_commands[@]}"
			do
				v="${global_commands[$k]}";
				:tasks.deploy.run.list.add;
		done
	else
		for k in "${!profile_commands[@]}"
			do
				v="${profile_commands[$k]}";
				:tasks.deploy.run.list.add;
		done		
	fi
}

# add a command to the list of
# commands to be processed
:tasks.deploy.run.list.add() {
	if [[ "$k" =~ $re ]]; then
		i="${BASH_REMATCH[1]}";
		list[$i]="$v";
	fi
}

# read in commands
:tasks.deploy.commands.read() {
	local prefix="${1:-}";
	local use_global_commands=false;
	if [ -z "$prefix" ]; then
		prefix="commands";
		use_global_commands=true;
	else
		prefix="${prefix}.commands";
	fi
	
	local local_pre_length="${json_doc[${prefix}.local.pre.length]:-0}";
	local local_post_length="${json_doc[${prefix}.local.post.length]:-0}";
	local remote_pre_length="${json_doc[${prefix}.remote.pre.length]:-0}";
	local remote_post_length="${json_doc[${prefix}.remote.post.length]:-0}";
	if [ $local_pre_length -gt 0 ]; then
		:tasks.deploy.commands.read.group \
			"$prefix" \
			"${prefix}.local.pre" \
			$local_pre_length \
			"commands.local.pre"
	fi
	if [ $local_post_length -gt 0 ]; then
		:tasks.deploy.commands.read.group \
			"$prefix" \
			"${prefix}.local.post" \
			$local_post_length \
			"commands.local.post"
	fi
	if [ $remote_pre_length -gt 0 ]; then
		:tasks.deploy.commands.read.group \
			"$prefix" \
			"${prefix}.remote.pre" \
			$remote_pre_length \
			"commands.remote.pre"
	fi
	if [ $remote_post_length -gt 0 ]; then
		:tasks.deploy.commands.read.group \
			"$prefix" \
			"${prefix}.remote.post" \
			$remote_post_length \
			"commands.remote.post"
	fi
}

# read in a group of commands
:tasks.deploy.commands.read.group() {
	local prefix="$1";
	local group="$2";
	local length="$3";
	local varname="$4";
	local i j jl exe opt cmd;
	
	local whitespace="[ 	]";
	
	# echo "GROUP READ !!! : $group";
	# echo "GROUP READ !!! : ${!json_doc[*]}";
	
	for((i = 0;i < $length;i++))
		do
			cmd="";
			exe="${json_doc[${group}.$i.command]:-}";
			if [ -z "$exe" ]; then
				console.error "invalid command %s in %s" "$exe" "$descriptor";
				:tasks.deploy.fail "%s may not be a blank string" "command";
			fi
			
			# echo "got exe: $exe";
			
			if [[ "$exe" =~ $whitespace ]]; then
				console.error "invalid command %s in %s" "$exe" "$descriptor";
				:tasks.deploy.fail "%s may not contain whitespace" "command";
			fi
			
			jl="${json_doc[${group}.$i.options.length]:-0}";
			
			# echo "read command at index $i : $group : $exe"
			
			if [ -n "$exe" ]; then
				cmd="${exe}";
			fi
			
			for((j = 0;j < $jl;j++))
				do
					opt="${json_doc[${group}.$i.options.$j]}";
					
					# evaluate each option so that variable
					# references can be used
					trap :tasks.deploy.unbound.variable EXIT
					eval "opt=\"${opt}\"";
					trap - EXIT
					
					cmd="${cmd}
${opt}";
			done
			
			if $use_global_commands; then
				global_commands["${varname}.$i"]="${cmd}";
			else
				profile_commands["${varname}.$i"]="${cmd}";
			fi
	done
	
	# add length properties
	if $use_global_commands; then
		global_commands["${varname}.length"]="${i}";
	else
		profile_commands["${varname}.length"]="${i}";
	fi
}

# handles the situation when a command *probably*
# references an unbound variable
:tasks.deploy.unbound.variable()
{
	# console.throw "probable reference to unbound variable";
	console.error "probable reference to unbound variable";
	:tasks.deploy.fail "invalid command %s" "${cmd//$newline/ }";
}

# either outputs configuration information
# for the profile being processed or prints
# a json document 
:tasks.deploy.info() {

	# always build up the json settings so that
	# this data can be written to a file when
	# performing a deployment
	local script_file="${script}";
	local script_shell="${shell}";
	local script_shebang="${shebang}";
	
	# variable names to inspect for
	# each profile being processed
	local var key
	
	# use all json property names
	local vars=( "${deploy_property_names[@]}" );
	# add property names set internally
	vars+=(
		deploy_name
		deploy_file_name
		deploy_target
		script_shell
		script_shebang
		script_file
		script_dir
		log_file
		log_dir
		git_url
		git_branch
	);
	
	# using custom script
	if [ -n "${script_source}" ]; then
		vars+=( script_source );
	fi
	
	local value k len;
	for var in "${vars[@]}"
		do
			# replace first underscore with a dot to group
			# as object on variable names with the same prefix
			key="${var/_/.}";
			if ! array.is.array? "${var}" && ! array.is.assoc? "${var}"; then
				key="${key//_/-}";
				variable.get "${var}";
				value="${_result:-}";
				if [ -n "${value}" ]; then
					json_dump["profiles.${profile}.$key"]="$value";
				fi
			else
				key="${var//_/.}";
				#echo "ADD ARRAY CONTENTS:::!!! $key : $var"
				eval "keys=( \${!$var[@]} )";
				eval len="\${#$var[@]}";
				if [ $len -gt 0 ]; then
					# echo "add with array length : ${len}";
					for k in "${keys[@]:-}"
						do
							eval value="\${$var[$k]}";
							# echo "adding array element : $k : $value"
							if [ -n "${value}" ]; then
								json_dump["profiles.${profile}.${key}.${k}"]="$value";
							fi
					done
				fi
			fi
	done
	
	# otherwise print out information to stdout
	if ! $print_json && ! $dump_script; then
		local start_time=$( date )
		:tasks.deploy.out.info "date %s" "${start_time}";
		:tasks.deploy.out.info "deploy %s" "${deploy_name}";
		if [ -n "${description:-}" ]; then
			:tasks.deploy.out.info "description %s" "${description}";
		fi
		:tasks.deploy.out.info "profile %s" "${profile}";
		:tasks.deploy.out.info "type %s" "${type}";
		:tasks.deploy.out.info "noop %s" "${noop}";
		:tasks.deploy.out.info "shell %s" "${shell}";
		# using custom script
		if [ -n "${script_source}" ]; then
			:tasks.deploy.out.info "source script %s" "${script_source}";
		fi		
		:tasks.deploy.out.info "script %s" "${script}";
		:tasks.deploy.out.info "directory %s" "${directory}";
		:tasks.deploy.out.info "staging %s" "${staging}";
		:tasks.deploy.out.info "target %s" "${deploy_target}";
		:tasks.deploy.out.info "log file %s" "${log_file}";
		:tasks.deploy.out.info "git url %s" "${git_url}";
		:tasks.deploy.out.info "git branch %s" "${git_branch}";
		:tasks.deploy.out.info "host %s" "${host}";
	fi
}

# print profiles
:tasks.deploy.print.profiles() {
	:tasks.deploy.out.info "deploy %s" "$deploy_start_time";
	:tasks.deploy.out.info "started by %s" "${deploy_user}@${deploy_local_host_name}";
	:tasks.deploy.out.info "";		
	local p;
	for p in "${profiles[@]}"
		do
			:tasks.deploy.out.info "\t%s" "$p";
	done
	:tasks.deploy.out.info "";
}

# output an info message to stdout or
# the log file if logging
:tasks.deploy.out.info() {
	if $print_json || $dump_script; then
		return 0;
	fi
	
	if ! $logging; then
		console.info "$@";
	else
		console.info "$@" >> "${log}" 2>&1;
	fi
}

# build up the prompt string
:tasks.deploy.prompt() {
	local replace="${1:-}";
	local ps1=$( printf "$deploy_prompt" "$replace" );
	#echo -n "${ps1}${rlx_prompt_suffix}";
	prompt="${ps1}${deploy_prompt_suffix}";
}

# interactive confirmation for
# a profile deployment
:tasks.deploy.confirm() {
	local callback="${1:-}";
	# stdin or stdout is not a tty
	# cannot interact
	if ! $interactive || [ ! -t 0 ] || [ ! -t 1 ]; then
		# invoke callback to start deployment
		$callback;
		return 0;
	fi
	
	local replace="${2:-}";
	:tasks.deploy.prompt "${replace}";

	accepted() {
		$callback;
	}

	rejected() {
		:tasks.deploy.fail "aborted %s" "${replace}";
	}

	# define a boolean prompt
	prompt.boolean confirm y n "${prompt} are you sure? (y/n)";
	# set accept/reject callback(s)
	prompt.accepts accepted;
	prompt.rejects rejected;
	prompt.show confirm;
	prompt.clean;
	
	# clean up confirmation callbacks
	method.remove accepted rejected;
}

# validate variable value does not contain
# whitespace: space or tab character
:tasks.deploy.whitespace.validate() {
	local value="${1:-}";
	local name="${2:-}";
	# staging directory cannot contain whitespace
	# so that we can perform tilde expansion
	local re="[ 	]+";
	if [[ "${value}" =~ $re ]]; then
		:tasks.deploy.fail "invalid %s value %s, cannot contain whitespace" \
			"${name}" "${value}";
	fi
}

# parse the deploy descriptor as JSON
:tasks.deploy.parse() {
	json_exit=false;
	json.parse < "${descriptor}" >> "$log" 2>&1;
	if [ $json_exit_code -gt 0 ]; then
		console.error "invalid json in %s" "$descriptor";
		:tasks.deploy.fail "stack trace in %s" "$log";
	fi	
	# fetch all profile names in to
	# the all_profiles list
	declare -A names;
	local k tk profile_re="^(profiles\.([^.]+))\.?";
	for k in "${!json_doc[@]}"
		do
			if [[ "$k" =~ $profile_re ]]; then
				names["${BASH_REMATCH[2]}"]=true;
				
				# assign the default deployment type when none
				# has been specified
				tk="${BASH_REMATCH[1]}.type";
				if [ -z "${json_doc[$tk]:-}" ]; then
					json_doc[$tk]="${default_type}";
				fi
			fi
	done
	# validate profile names in descriptor
	# match the rules for project/profile names
	for k in "${!names[@]}"
		do
			# quit on invalid profile name in the deploy descriptor
			if ! :tasks.name.valid? "${k}"; then
				:tasks.name.quit "profile" "$k";
			fi
	done
	all_profiles=( ${!names[@]} );
	
	if $print_profiles; then
		if [ "${#all_profiles[@]}" -eq 0 ]; then
			:tasks.deploy.fail "no profiles in %s" "$descriptor";
		else
			local IFS="$newline";
			local all="${all_profiles[@]}";
			echo "$all";
			console.success;
		fi
	fi
}

# failure
:tasks.deploy.fail() {
	:tasks.deploy.complete.notify;
	if [ $# -gt 0 ]; then
		console.error "$@";
	fi
	console.quit 1 "deploy %s failed %s" \
			"${deploy_name}" "${characters[cross]}";
}

# attempts to notify via `growlnotify` when available
:tasks.deploy.complete.notify() {
	
	# don't send growl notifications for
	# json dumps or noop
	if $noop || ${skip[growl]}; then
		return 0;
	fi
	
	if [ -n "${executables[growlnotify]}" ]; then
		local message;
		local priority="${2:-Normal}";
		if $success; then
			message="${messages[success]}";
		else
			priority="Emergency";
			message="${messages[fail]}";
		fi
		"${executables[growlnotify]}" -m "$message" --priority "$priority";
	fi
}

# output the complete message
:tasks.deploy.complete() {
	
	# noop should always succeed
	if $noop; then
		success=true;
	fi
	
	# output success information
	if $success; then
		:tasks.deploy.complete.notify;
		if $print_json || $dump_script; then
			console.success;
		else
			console.success "deploy %s complete %s" \
				"${deploy_name}" "${characters[tick]}";
		fi
	else
		:tasks.deploy.fail;
	fi
}

# validate a name follows the convention
:tasks.name.valid?() {
	local name="${1:-}";
	# may not start with a hyphen
	# and must match the name regex
	if [[ "$name" =~ ^-+ ]] || [[ ! "$name" =~ $re ]]; then
		return 1;
	fi
	return 0;
}

# quit if an invalid name is encountered
:tasks.name.quit() {
	local var="$1";
	local value="$2";
	console.error "names may not start with a hyphen and must match %s" "$re";	
	console.error "invalid $var name %s" "$value";
	:tasks.deploy.fail;
}

# write the script to the remote server
:tasks.deploy.script.push!() {
	local test_staging='test -d '${staging}'; echo $?;';
	local mk_staging='mkdir -p '${staging}'';

	# test if the staging directory exists
	:tasks.deploy.out.info "${executables[ssh]} %s %s" \
		"${host}" "${test_staging}";
	local exists=0;
	if ! $noop; then
		exists=$( "${executables[ssh]}" "${host}" ""${test_staging}"" );
	fi

	# create remote staging directory if it does not exist
	if [ $exists -gt 0 ]; then
		:tasks.deploy.out.info "${executables[ssh]} %s %s" \
			"${host}" "${mk_staging}";
		if ! $noop; then
			( "${executables[ssh]}" "${host}" ""${mk_staging}"" ) \
				|| :tasks.deploy.fail \
				"could not create remote staging directory %s" \
				"${staging}";
		fi
	fi

	local remote="${host}:${staging}/${script_name}";
	:tasks.deploy.out.info "scp -p %s %s" \
		"${script}" "${remote}";
	if ! $noop; then
		echo "SCP SCRIPT";
	fi	
}

# OPTIONS

# parse options
:tasks.deploy.options.parse() {
	local value ;
	while test -n "${1:-}"; do
		case $1 in
			--ok )
				interactive=false;
				;;
			--noop )
				noop=true;
				interactive=false;				
				;;
			--list )
				print_profiles=true;
				;;				
			--staging )
				shift;
				staging="${1:-}";
				;;
			--local )
				deploy_local=true;
				;;
			--json )
				print_json=true;
				noop=true;
				dump_script=false;				
				;;
			--write-json )
				write_json=true;
				;;
			--script )
				dump_script=true;
				noop=true;
				print_json=false;
				;;
			--lint )
				lint=true;
				noop=true;				
				;;
 			--lint-run )
				lint=true;
				run_script=true;
				noop=true;
				;;				
			--pretty )
				pretty=true;
				;;
			--expand )
				quote=false;
				;;
			--flat )
				flat=true;
				;;	
			--include-version )
				include_version=true;
				;;
			--all )
				deploy_all=true;
				;;				
			--no-local )
				skip["local.pre"]=true;
				skip["local.post"]=true;
				;;
			--no-local-pre )
				skip["local.pre"]=true;
				;;
			--no-local-post )
				skip["local.post"]=true;
				;;
			--no-remote )
				skip["remote.pre"]=true;
				skip["remote.post"]=true;
				;;
			--no-remote-pre )
				skip["remote.pre"]=true;
				;;
			--no-remote-post )
				skip["remote.post"]=true;
				;;
			--no-growl )
				skip["growl"]=true;
				;;
			--log )
				logging=true;
				;;
			--script-source )
				shift;
				value="${1:-}";
				if [ ! -f "${value}" ]; then
					:tasks.deploy.fail "script file %s does not exist" "$value";
				fi
				if [ ! -x "${value}" ]; then
					:tasks.deploy.fail "script file %s is not executable" "$value";
				fi
				script_source="${value}";
				;;
			--shell )
				shift;
				value="${1:-}";
				if [ -z "${value}" ]; then
					:tasks.deploy.fail "no shell specified";
				fi
				shell="${value}";
				;;
			--name )
				shift;
				value="${1:-}";
				if [ -z "${value}" ]; then
					:tasks.deploy.fail "no name specified";
				fi
				if ! :tasks.name.valid? "${value}"; then
					:tasks.name.quit "project" "$value";
				fi
				project_name="${value}";
				;;
			--directory )
				shift;
				value="${1:-}";
				if [ -z "${value}" ]; then
					:tasks.deploy.fail "no directory specified";
				fi
				overrides[directory]="${value}";
				;;
			--host )
				shift;
				value="${1:-}";
				if [ -z "${value}" ]; then
					:tasks.deploy.fail "no host specified";
				fi
				overrides[host]="${value}";
				;;
			--descriptor )
				shift;
				value="${1:-}";
				if [ -z "${value}" ]; then
					:tasks.deploy.fail "no descriptor specified";
				fi
				descriptor="${value}";
				;;
			-* | --* )
				:tasks.deploy.fail "unknown option %s" "$1";
				;;
			* )
				if ! :tasks.name.valid? "$1"; then
					:tasks.name.quit "profile" "$1";
				fi
				profiles+=( "$1" );
				;;
		esac
		shift;
	done
}