: <<'ronn:markdown'
task-deploy(7) -- deploy task(s) for bake(1)
=============================================

## SYNOPSIS

Deploy task(s) for bake(1).

## DESCRIPTION

Performs a deployment for a project.

## REQUIRE

In your tasks(7) file `require` the `deploy` task(s) using:

	require 'tasks/deploy';

## USAGE

	bake deploy [options...] [profiles...]
	
## OPTIONS

* `--ok`:

Disable interactivity and assume *yes* for every prompt.

* `--noop`:

Print commands but do not execute them, implies `--ok` to disable interactivity.

* `--quiet`:

Suppress messages sent to standard output.

* `--verbose`:

Print more information.

* `--all`:

Operate on all profiles in the descriptor.

* `--name [name]`:

Override the default project name (determined by the name of the parent directory), see `NAMES` for project and profile name rules.

* `--directory [directory]`:

Use *directory* for deployment. When this option is specified it overrides any directory specified in *deploy.json* for all profiles.

* `--host [user@host]`:

The scp(1) and ssh(1) *user@host* specification. When this option is specified it overrides any host properties in *deploy.json*. This is useful if you wish to deploy everything using the profile(s) in *deploy.json* to a different host.

* `--descriptor [file]`:

Use *file* as the deployment descriptor.

* `--script-source [script]`:

Use *script* as the deployment script instead of any generated script. The *script* must exist and be executable. When this option is specified then the automatically generated script is ignored and the source *script* is used instead. It is written to disc in the same location, deployed to the remote host (or localhost with the `--local` option) and executed.

When this option is specified the `--shell` option has no effect as it is only used to determine the *shebang* for generated deployment scripts.

If multiple profiles are being deployed then *script* is used for all target profiles.

It is important to note that because remote command execution is performed by the generated script when this option is used, remote commands specified in the deployment descriptor are *never* executed.

* `--shell [shell]`:

Use *shell* for the script shebang. Must be one of *sh*, *bash*, *zsh* or *dash*.

* `--staging [directory]`:

Use *directory* as the staging directory.

* `--list`:

List profile names in a deployment descriptor. By default the default profile is not listed but if you have declared a custom configuration for the default profile then it will be included in the list.

* `--log`:

Redirect *stdout* messages to `target/deploy/deploy.log`. Note that when using the `--json` option that the JSON document is always sent to *stdout*.

* `--flat`:

Do not include the profile name in the target directory, see `TARGET` for more information.

* `--include-version`:

Include version information in the target directory, see `TARGET` for more information.

* `--local`:

Perform a deployment on the local host.

* `--no-local`:

Shortcut for combining `--no-local-pre` and `--no-local-post`.

* `--no-local-pre`:

Do not execute the pre-deployment commands on the local host.

* `--no-local-post`:

Do not execute the post-deployment commands on the local host.

* `--no-remote`:

Shortcut for combining `--no-remote-pre` and `--no-remote-post`.

* `--no-remote-pre`:

Do not execute the pre-deployment commands on the remote host.

* `--no-remote-post`:

Do not execute the post-deployment commands on the remote host.

* `--no-growl`:

Do not send growl notifications.

* `--expand`:

Do not quote command options. When this options is set parameter expansion is performed on command options declared in a deployment descriptor.

## BUNDLE OPTIONS

This section describes bundle options.

* `--bundle`:

Just create bundles do not deploy anything and do not execute any commands. Implies `--noop`, `--no-local` and `--no-remote`. See the `BUNDLES` section.

* `--output [directory]`:

Use *directory* as the target for generated bundles. The *directory* must exist and be writable.

* `--inspect`:

Print the contents of a bundle after creation. This option may be combined with `--quiet` to only print the bundle contents and/or combined with the `--verbose` option to print an extended listing (similar to `ls -la`).

* `--timestamp`:

Append a timestamp to the bundle name.

* `--author`:

Prepend an author to the name of the bundle. This sanitizes the user name (determined by `id -nu`) to remove any non-alphanumeric characters.

* `--pkg`:

Also package a directory into the *contents* directory of the bundle.

* `--include-hidden`:

Also include hidden files when packaging bundle contents.

* `--follow-symlinks`:

Do not preserve symbolic links. Used in conjunction with the `--pkg` option this copies the symbolic link target into the bundle *contents* directory.

### Checksums

By default a `Secure Hash Algorithm` is generated for created bundles using the *512* algorithm and written to a file as a sibling of the generated bundle. You may influence the behaviour of checksum generation with the following options (last option takes precedence).

* `--sha [algorithm]`:

Use *algorithm* when generating checksums. Available values are *224*, *256*, *384* and *512*, specifying any other value for this option will result in an error.

* `--no-sha`:

Do not generate a checksum file.

### Compression

The default compression used is `gzip` although if the `xz` and `xzdec` binaries are available then the `xz` compression type is preferred. You may override this behaviour by specifying a compression type option (last option takes precedence).

Note that whichever compression type is chosen the binaries must be available on the remote host as well as the local host when performing a remote deployment.

* `--gz`:

Force bundle creation to use `gzip`, bundle(s) are created with the `tgz` file extension.

* `--bz`:

Force bundle creation to use `bzip2`, bundle(s) are created with the `bz2` file extension.

* `--xz`:

Force bundle creation to use `xz`, bundle(s) are created with the `xz` file extension.

* `--lzma`:

Force bundle creation to use `lzma`, bundle(s) are created with the `lzma` file extension.

## DEBUG OPTIONS

This section describes options for debugging and unit testing.

* `--global-env`:

Declare variables exposed to deployment descriptors as *export* rather than *local*. This is used for unit testing purposes.

* `--json`:

Dump all profile configuration settings that would be used by a deployment as a JSON document to *stdout*, implies `--noop`. This is useful to determine the settings that would be used when running a deployment.

If this option is used in conjunction with `--script` the last option will take preference.

* `--lint`:

Perform a sanity check on the generated script and exit, implies `--noop`. You must have the checkbashisms(1) script installed in \$PATH in order to use this option. Useful for debugging the generated script. This can be used in conjunction with the `--script` option to inspect the script output as well as run the script through checkbashisms(1).

Note that when using the `--script-source` option the source script becomes the target for this operation. If the `--shell` option has been specified then the *shebang* will not be `#!/bin/sh` which will cause checkbashisms(1) to output a warning but still pass the lint operation if there are no errors.

This option ignores multiple profiles, it only executes for the first target profile.

* `--lint-run`:

Executes the script in the local target directory in the context of the *localhost*, implies the `--lint`, `--local` and `--noop` options. The script is only executed if the `--lint` operation succeeds. Useful for testing and debugging purposes.

Note that although this option implies `--noop` (so no commands are executed) it does actually perform a deployment locally.

This option ignores multiple profiles, it only executes for the first target profile.

* `--pretty`:

Use in conjunction with the `--json` option to pretty print the JSON document. Uses two spaces as the indentation.

* `--print-env`:

Print variables exposed to deployment descriptors and exit.

* `--script`:

Dump script(s) to *stdout*, implies `--noop`. If this option is used in conjunction with `--json` the last option will take preference. Note that when this option is used the script(s) are still written to `target/deploy`.

* `--write-json`:

Write the deployment settings to `target/deploy/settings.json`. If used in conjunction with the `--json` option then the settings will be printed to *stdout* and written to disc. The generated document will be formatted if the `--pretty` flag has been set.
	
## TYPES

The deploy tasks support the *git*, *tar* and *npm* deployment types.

### GIT

This deployment type will clone if the deployment directory does not exist and fetch the specified branch from the remote repository.

### NPM

This deployment type uses npm(1) to fetch a package and then copies over the extracted contents of the package to the target directory.

### TAR

This deployment type will fetch a tarball from a filesystem path or remote URL and extract the contents to the target directory.

Unlike the *npm* and *git* deployment types we cannot be certain that we are only deploying a single directory. So this type uses the rule that when an archive contains a single directory then that directory is used as the final deployment directory.

If the archive contains more than one file or a single non-directory file then the entire contents of the archive are copied into the final deployment directory.

It is a subtle but important difference that caters to the common use case for working with archives. Generally, when packaging a project for distribution all files are placed in a single directory and that directory is converted to an archive. If we did not follow the above rule the resulting deployment would have an additional nested directory which is probably undesirable.

To illustrate, if we are deploying to *~/www* with a deployment profile named *stage* and working with an archive named *project.tgz* that contains a single directory *project* then if we did not follow the above rule we would end up with a final directory of:

	~/www/stage/project
	
Instead, by following the above rule we end up with the contents of the extracted *project* directory at the expected final directory:

	~/www/stage

## BUNDLES

The task-deploy(7) execution creates a tarball bundle of the deployment files using the project *name* and *version* concatenated with the current *profile* for the bundle file name. Assuming a project name of *project*, with version *0.0.1* and a deployment profile of *stage* the resulting bundle is `project-0.0.1-stage.tgz`.

Bundles are created in the `target/deploy` directory.

A generated bundle will include:

* `descriptor.json`:

The descriptor used to create the bundle.

* `settings.json`:

A JSON document containing the computed settings for the deployment.

* `deploy.sh`:

The generated deployment script or the contents of *script* if `--script-source` was specified.

* `contents`:

A directory containing packaged contents, see `Package`.

* `scripts`:

A directory containing bundled scripts, see `Scripts`.

* `gitignore.txt`:

A text file containing a list of all the files ignored by git(1). This file will only be present if git(1) is available and the directory being packaged is a git repository.

* `.xpmignore`:

If the source directory being packaged contains a file named `.xpmignore` it is copied to the root of the bundle.

### NPM

For the `npm` deployment type the bundle will also include:

* `package.json`:

An npm(1) conformant package descriptor used to perform the deployment.

### Package

A bundle may include packaged files to create a *standalone* bundle or to append/overwrite files in a deployment. Packaged files are stored in the *contents* directory within the bundle archive.

Use the `--pkg` option to indicate that packaging of files should also be performed. By default when the `--pkg` option is specified task-deploy(7) will attempt to package *all* files in the directory containing the descriptor and following the rules described in `Package Ignores`.

Symbolic links are preserved by default, although you may override this behaviour by specifying the `--follow-symlinks` option.

### Package Ignores

Hidden files or directories are ignored by default, you can specify the `--include-hidden` option to also include hidden files.

Any relative paths starting with *.git* or *.svn* are automatically ignored, this behaviour is *not* affected by the `--include-hidden` option.

If the source directory is a git repository the files ignored by git are excluded from packaging, files excluded by git(1) are written to `gitignore.txt`.

If the source directory contains a file named `.xpmignore` the patterns defined in the file are processed against the *relative* path for each file, if the pattern matches the file is ignored. Patterns are `Extended Regular Expressions`, it is an error to specify an invalid pattern.

### Scripts

You may include custom scripts in a bundle by declaring a `scripts` array in the `bundles` object either globally or specific to a profile, the syntax is:

	"bundle": {
	  "scripts": [
	    {
	      "dir": "opt/bin",		
	      "file": "script.sh"
	    }
	  ]
	}

A referenced script must exist on the filesystem and must be executable. Bundled scripts are placed in a `scripts` directory automatically generated within the archive.
	
Filesystem references may be absolute or relative, relative paths are resolved relative to the directory containing the descriptor.

Global scripts are *always* added to bundles for all profiles whereas profile specific script(s) will only be bundled for that profile.

By default no hierarchy is maintained for bundled scripts so names should be unique for all bundled scripts, attempting to add a duplicate script will fail.

To create a hierarchy for bundled scripts you may create a directory within the bundled `scripts` by specifying a `dir` property. Leading periods or slashes are not allowed when specifying directories to create using the `dir` property.

## ROLLBACK

The generated *deploy.sh* script attempts to rollback to a previous deployment if a deployment fails.

This operation will only be performed if the final target directory for the deployment existed prior to starting a deployment, ie, the operation is a re-deployment.

For the `npm` and `tar` deployment types a backup is created by moving the existing directory prior to starting deployment and moving back to the target destination if deployment fails.

For the `git` deployment type a current revision is extracted from the existing repository using `rev-parse` and if the deployment fails it is reverted to the previous revision using `reset`.

## JSON FORMAT

The format of the *deploy.json* descriptor is described in the task-deploy-json(7) man page, to view this man page run:

	bake help deploy-json
	
## TARGET

The final deploy target is a combination of the *directory*, *name* and *profile* by default. Assuming a *directory* of `~/www` and the project name `project` with a deployment profile of `stage` the target used for deployment is:

	~/www/project/stage
	
If you do not wish to include the profile name in the target directory specify the `--flat` option which results in:

	~/www/project
	
It depends upon your deployment requirements as to which strategy you wish to use. Generally, if you are deploying to the same host then it makes sense to separate the deployment profiles, whereas if each deployment profile is using a different host then it is more consistent to have the same directory structure across the different hosts.

You may also create separate deployment targets based on the project version using the `--include-version` option. Continuing the above example with a version of `0.0.1` and the default behaviour (no `--flat` option specified) then the target becomes:

	~/www/project-0.0.1/stage
	
Or alternatively in conjunction with the `--flat` option the target directory becomes:

	~/www/project-0.0.1
	
## PROFILES

You may specify one or more profiles to deploy after any options. If no profiles are specified then a deploy is attempted using the *default* profile.

## DEFAULT PROFILE

The default profile uses a *git* deployment type and the current branch and git remote URL for deployment to the target host.

This profile is used when no profiles are specified on the command line but may also be explicitly declared. For example, to execute the default profile run:

	bake deploy
	
But if a profile is specified:

	bake deploy stage
	
Then the default profile is not a target profile, only the *stage* profile is deployed. To also execute the default profile, declare it on the command line:

	bake deploy stage default

Note that when the `--all` option is specififed the *default* profile is not included, if you wish to also execute the default profile in addition to execute the default profile as well:

	bake deploy --all default

You may override settings for the default profile by declaring a profile named *default* in the descriptor.

## NAMES

Profile and project names may not start with a hyphen and should match the pattern ^[-a-zA-Z0-9]+.

## STRICT

The deployment process is fail fast. Failure is always assumed and when deploying multiple profiles, failure of a profile to deploy will prevent any subsequent profiles from being processed.

## FILES

A *deploy.json* file must be present in the root of the project and must be valid JSON. This file may just contain '{}' if you wish to use the *default* profile and configure deployment parameters via environment variables or command line options.

## ENVIRONMENT

* `bake_deploy_remote`:

The remote host used for deployment when none is specified in *deploy.json*.

* `bake_deploy_shell`:

The shell used on the remote server, defaults to `sh` if none is specified.

* `bake_deploy_staging`:

The directory used on the remote server for staging deployment scripts, default is `~/.deploy`.

## COMMAND EXECUTION

The deployment process can optionally execute arbitrary simple commands on the local and remote host. For each host, command execution is split into the pre-deployment and post-deployment execution phases.

Note that when running a local deployment (using `--local`) then remote commands are executed on the local host.

If any command exits with an exit code *>0* then the deployment is aborted. This is useful for running tests prior to performing a deployment or other tasks such as creating a tarball package.

The general syntax for declaring commands is:

	"commands": {
	  "local": {
	    "pre": [
	      {
	        "command": "ls",
	        "options": [ "-la", "lib", "man" ]
	      }
	    ],
	    "post": [
	      {
	        "command": "echo",
	        "options": [ "deployment complete" ]
	      }
	    ]
	  }
	}
	
All commands are encapsulated by the *commands* object which can contain *local* and *remote* properties indicating whether the commands should be executed on the local or remote host. The *pre* and *post* properties are arrays of commands to execute for the deployment phase(s).

A *commands* object may be declared at the top-level of the JSON descriptor document, in which case the commands will be executed for *all* profiles. A *commands* object may also be declared in a profile to execute commands specific to that profile. When *commands* are declared at the top-level of the document and in a profile then they are concatenated together and all commands are executed (global commands are executed first).

### Working Directory

In order to be able to resolve relative path references correctly it is important to know the working directory used for command execution.

For *local* commands (pre and post execution phases) the working directory is always set to the directory that contains the deployment descriptor. This ensures consistency when executing in the context of a project as well as when the `--descriptor` option is set.

For *remote* command execution the rule(s) are a little more complex.

Remote pre-deployment commands follow the rule that if the final target directory does not exist (first deployment) then commands are executed in the context of the sandbox directory used to perform the deployment. If the final target directory already exists then the remote pre-deployment commands are executed in the context of the *existing* deployment. This is useful if you wish to perform an action (such as stopping a server) on the existing deployment prior to performing a re-deployment.

Remote post-deployment commands are always executed in the context of the final target directory. You could use this command execution phase to restart a server after deployment.

### Parameter Expansion

By default parameters are not expanded - whitespace in a parameter is preserved and passed as a single argument to the command being executed. For example, imagine you wanted to list the contents of the *lib* and *man* directories, this would fail (with the default settings) if you specified both directories in a single option (`ls` would be looking for a directory named "lib man" rather than attempting to list two separate directories):

	{
	  "command": "ls",
	  "options": [ "-la", "lib man" ]
	}
	
You have two options to remedy this scenario. You may either decide to separate the parameters:

	{
	  "command": "ls",
	  "options": [ "-la", "lib", "man" ]
	}
	
So that the *lib* and *man* are passed as separate arguments to *ls*. Or you may use the `--expand` option to allow parameter expansion on command options. You should only use the `--expand` option if you are certain that you do not want to include whitespace in any options passed to command(s) being executed.

### Command Environment

Commands executing in a *local* context have access to the entire bake(1) variable scope chain which means that there are some useful variables exposed to your commands.

* `project_name`:

The name of the project.

* `project_version`:

The project version.

* `root`:

The project root directory.

* `project`:

The root directory for multi-module projects, when bake(1) is executing at the root of a multi-module project then `root` and `project` point to the same directory.

* `target`:

The `target` directory relative to `${root}` used by bake(1) for staging files.

* `profile`:

The name of the profile currently being deployed.

* `deploy_target`:

The final target directory used for the deployment, see the `TARGET` section.

* `deploy_name`:

The human readable name used by task-deploy(7). This is the project name and version delimited by @, for example: project@0.0.1.

* `deploy_file_name`:

The prefix used when defining file names. Uses - as the delimiter, for example: project-0.0.1.

* `script_name`:

The name of the script that will be used by task-deploy(7) for deployment.

* `script`:

The path to the script that will be used to perform deployment.

* `log`:

The path to the log file used by task-deploy(7).

* `logging`:

A boolean indicating whether output is being redirected to the file defined by the *log* variable.

* `type`:

The type of deployment being performed, see the `TYPES` section.

* `noop`:

A boolean indicating if this deployment is a non-operation, will be *true* if the `--noop` option has been specified.

* `flat`:

A boolean indicating if a flat directory structure is being used, see the `TARGET` section.

* `include_version`:

A boolean indicating if version information is being included in the directory structure, see the `TARGET` section.

### Custom Environment

You may declare properties specific to your deployment process in a top-level *env* object. You may then access these variables in your deployment profiles using the `env_` variable prefix.

Properties declared in the *env* object may reference any variable documented in the `Command Environment` section but they may not use `Cross References` using a `doc_` variable prefix.

If you attempt to create a document cross-reference in an *env* property task-deploy(7) will exit immediately with a *>0* exit code.

See the section `Command Examples` for example(s).

### Cross References

It is recommended that you use the functionality provided by `Custom Environment` whenever possible but if you absolutely must reference other data in a deployment profile this section provides some information on using deployment descriptor cross-references.

The JSON document properties are expanded to variables that you may reference in the deployment descriptor. These variables are exposed using a `doc_` prefix.

This is useful to prevent duplication of information between profiles that share some (but not all) commands or properties.

Consider the following example document:

	{
	  "host": "user@example.com",
	  "directory": "~/www",
	  "commands": {
	    "local": {
	      "pre": [
	        {
	          "command": "echo",
	          "options": [ "$doc_directory", "$doc_host" ]
	        }
	      ]
	    }
	  }
	}
	
In this instance the `\$doc_` variables reference the *directory* and *host* properties declared at the top-level of the document.

This results in the command (for the local host pre-deployment phase):

	echo ~/www user@example.com
	
When the command is executed it generates the output:

	~/www user@example.com

You may reference any property in the document by full path delimited by an underscore (_) for the variable name.

To illustrate, a convoluted example which generates the same output as the above example but also prepends the command being executed and appends the number of options being passed to the command:

	{
	  "host": "user@example.com",
	  "directory": "~/www",
	  "commands": {
	    "local": {
	      "pre": [
	        {
	          "command": "echo",
	          "options": [
	            "$doc_commands_local_pre_0_command",
	            "$doc_directory",
	            "$doc_host",
	            "$doc_commands_local_pre_0_options_length"
	          ]
	        }
	      ]
	    }
	  }
	}
	
The command becomes:

	echo echo ~/www user@example.com 4
	
Which generates the *output*:

	echo ~/www user@example.com 4
	
Notice how you can access array elements by index and also the the *length* properties of array types.
	
### Command Errors

Commands (declared by the *command* property) may not contain any whitespace (space, tab or newline). It is a JSON error to declare literal whitespace characters such as \\n or \\t, if these are specified using the escaped values (allowed by JSON) the program will exit with a whitespace error.

If you reference a variable that is unbound in a command the program will exit immediately with a >0 exit code and an error message.

### Command Examples

A complete example that uses npm(1) to create a tarball, moves it to the local `target` staging directory and copies the tarball to a remote host prior to the main deployment process which will take the created archive (on the remote host) and deploy it to the *target* directory:

	{
	  "env": {
	    "archive": {
	      "name": "${project_name}-${project_version}.tgz",
	      "dir": "$target",
	      "path": "${target}/${project_name}-${project_version}.tgz"
	    }
	  },
	  "host": "user@example.com",
	  "directory": "~/www",
	  "profiles": {
	    "npm": {
	      "type": "tar",
	      "url": "~/$env_archive_name",
	      "commands": {
	        "local": {
	          "pre": [
	            {
	              "command": "npm",
	              "options": [ "pack" ]
	            },
	            {
	              "command": "mv",
	              "options": [ "$env_archive_name", "$env_archive_dir" ]
	            },
	            {
	              "command": "scp",
	              "options": [ "$env_archive_path", "${host}:~/" ]
	            }
	          ]
	        }
	      }
	    }
	  }
	}
	
## DEPLOYMENT PROCESS

This section describes the process that task-deploy(7) uses to perform a deployment assuming that no command line options (other than profile(s)) have been specified on the command line, see `OPTIONS` for how command line options influence behaviour.

Load and parse the deployment descriptor JSON document and exit with a *>0* exit code if invalid JSON is encountered.

Start processing of the target profiles specified on the command line, profile execution order is the order that profiles are specified on the command line or non-determinate when executing all profiles.

If no profiles are specified on the command line then a *default* profile is assumed, see `DEFAULT PROFILE`.

Before profile execution starts command line options are processed that may override any settings in the deployment descriptor and the deployment descriptor is evaluated using `eval` so that variable references declared in a deployment descriptor are resolved correctly in the context of the current profile being executed. If any errors are encountered task-deploy(7) exits with a *>0* exit code.

An interactive prompt is displayed asking for confirmation that you wish to deploy the profile.

If global and/or profile-specific *local* pre-deployment commands have been specified they are executed, if any command exits with a *>0* exit code the deployment is aborted.

At this point the deployment process starts. When running as a *local* deployment (using `--local`) then the deployment script is copied to the local filesystem staging directory otherwise the deployment script is transferred to the staging directory on the remote host using scp(1).

If global and/or profile-specific *remote* pre-deployment commands have been specified they are executed, if any command exits with a *>0* exit code the deployment is aborted.

The deployment script is executed to perform the deployment based on the deployment type for the profile, see `TYPES`.

If the deployment script detects any error the deployment process is aborted.

If global and/or profile-specific *remote* post-deployment commands have been specified they are executed on the remote host by the deployment script.

If global and/or profile-specific *local* post-deployment commands have been specified they are executed on the local host.

Success or failure notifications are delivered.

## INTERACTIVE

Deploying code is an important process and task-deploy(7) by design presents confirmation prompt(s) to ensure you wish to proceed.

This interactivity can be disabled in a variety of ways which is often necessary when executing a deployment from another program or if you are re-deploying in quick succession. The recommended way is to specify the `--ok` option.

If the `--noop` option is specified interactive prompt(s) are not displayed as no commands are executed.

Interactive prompts write to *stdout* and read from *stdin* you may also disable interactivity by piping to *stdin* or redirecting *stdout*. For example:

	echo "" | bake deploy
	bake deploy > target/deploy.log

## NOTIFICATIONS

If the *growlnotify* executable is available then a success or failure notification will be sent using *growlnotify*. Note that *growlnotify* notifications are *not* sent for a `noop` which is the case if the `--noop`, `--json` or `--script` options are specified.

You may disable the use of growl notifications by specifying the `--no-growl` option.

## FILES

All generated files are written to `target/deploy` by default.

When the `--log` option is specified *stdout* messages are redirected to `target/deploy/deploy.log`.

The generated script file(s) are written to `target/deploy` using the following naming strategy:

	${name}-${version}-${profile}.sh
	
If the `--write-json` option is specified then the deployment settings are written to `target/deploy/settings.json`.

## EXIT CODES

A >0 exit code indicates failure while a 0 exit code indicates success.

## EXAMPLES

### Deploying

Deploy using the default profile:

	bake deploy
	
Deploy to *localhost* using the default profile:

	bake deploy --local
	
Deploy the profile *stage*:

	bake deploy stage

Deploy the profiles *test*, *stage* and *production*:

	bake deploy test stage production

Deploy all profiles in the descriptor:

	bake deploy --all
	
### Bundling

Bundle the default profile:

	bake deploy --bundle
	
Bundle all profiles:

	bake deploy --all --bundle
	
Bundle profiles *stage* and *production* and place generated bundles in *~/bundles*:

	bake deploy --bundle --output ~/bundles stage production
	
### Inspecting
	
List profiles in *deploy.json*:

	bake deploy --list
	
List profiles in a specific descriptor:

	bake deploy --list --descriptor ~/project/deploy.json
	
### Debugging

Inspect deployment commands but do not execute them:

	bake deploy --noop

Print the script that will be used for deployment:

	bake deploy --script
	
Inspect the settings used for a *default* deployment:

	bake deploy --json --pretty \\
		--staging ~/project-staging \\
		--name project \\
		--directory ~/www
		
Display this man page:

	bake help deploy

## ROADMAP

Add rsync(1) deployment type.

Implement lock files for the local and remote scripts to prevent concurrency issues when multiple deployments are attempted.

Add ability to rollback a deployment if an existing `target` directory existed prior to deployment and the deployment process fails (such as due to a network error).

Add `--branch` option to specify a git branch to use for all profiles that are of the `git` type.

Add `--refspec` option so that `git` deployments may also be done from tags.

Implement notifications using `mail`.

Attach bundle to `mail` notifications.

Add the `deploy_ssh_options` and `deploy_scp_options` environment variables so that custom options (such as port numbers) can be passed on to ssh(1) and scp(1).

Add `enable` boolean property to profiles in a descriptor to prevent deployment of a profile.

## DEPENDENCIES

GNU tar(1) >= 1.22, scp(1), ssh(1)

## BUGS

**task-deploy** is written in bash and depends upon `bash` >= 4.2.

## COPYRIGHT

**task-deploy** is copyright (c) 2012 muji <http://xpm.io>

## SEE ALSO

bake(1), task-deploy-json(7), scp(1), ssh(1), tar(1), growlnotify(1), checkbashisms(1)
ronn:markdown

require.once 'json';
require.once 'git';
require.once 'util/checksum';

# module libraries
require.library 'deploy.script';
require.library 'deploy.bundle';

# list of property names that are first set
# from the top-level of a document and then
# overriden by declarations in specific profiles
# these properties are shared by all deployment types
declare -ag deploy_property_names;
deploy_property_names=(
	"host"
	"directory"
	"type"
	"url"
	"description"
	"directory"
	"staging"
);

# deploy delegate
tasks.deploy() {
	executable.validate scp ssh;
	executable.validate --test growlnotify;
	
	# regex for matching a url scheme
	# eg: file: http: https: ftp:
	# this is only necessary for the *tar*
	# type which uses curl to fetch the package.
	# the *git* deployment can cope with local
	# repositories that do not specify a scheme
	local scheme="^[a-zA-Z]+:";
	
	declare -A defaults;
	defaults[sha.algorithms]="224 256 384 512";
	defaults[sha.default.algorithm]="512";
	
	declare -A compression_types;
	compression_types[gz]="tgz gzip gunzip";
	compression_types[bz]="bz2 bzip2 bunzip2";
	compression_types[xz]="xz xz xzdec";
	compression_types[lzma]="lzma lzma lzmadec";
	
	# default compression
	local compression="gz";
	local compression_extension="tgz";
	
	# prefer xz if we have the executables
	executable.validate --test xz xzdec;
	if [ -n "${executables[xz]}" ] && [ -n "${executables[xzdec]}" ]; then
		compression="xz";
		compression_extension="xz";
	fi
	
	# list of files ignored when bundling
	declare -a bundle_ignores;
	bundle_ignores=();
	
	# SETUP
	declare -A setup;
	setup[owd]="$PWD";
	setup[sha.algorithm]="${defaults[sha.default.algorithm]}";
	setup[timestamp]=$( date +%s );
	setup[user]=$( id -nu );
	setup[hostname]=$( hostname );
	setup[uname]=$( uname -a );
	setup[date]=$( date );
	setup[creator]="${setup[user]}@${setup[hostname]}";
	setup[platform]=$( uname | tr '[:upper:]' '[:lower:]' );

	# TODO: remove these duplicate variables
	local deploy_user=$( id -nu );
	local timestamp=$( date +%s );
	local localhost=$( hostname );
	local creator="${deploy_user}@${localhost}";
	local deploy_start_time=$( date );		
	
	local creator_host=$( uname -a | fmt );	
	
	# FLAGS
	
	declare -A flags;
	flags[verbose]=false;
	flags[quiet]=false;
	flags[print.env]=false;
	flags[global.env]=false;
	flags[timestamp]=false;
	flags[author]=false;
	flags[sha]=true;
	flags[bundle.inspect]=false;
	flags[bundle.package]=false;
	flags[bundle.package.follow.symlinks]=false;
	flags[bundle.package.include.hidden]=false;
	
	# TODO: move all other flag variables into $flags
	
	# assume failure
	local success=false;
	
	# just creating bundles
	local bundling=false;
	
	# determine if we are printing
	# messages to a log file
	local logging=false;
	
	# interactive by default
	local interactive=true;
	
	# non-operation
	local noop=false;
	
	# --list: determine if we are just
	# printing profiles available in descriptor
	local print_profiles=false;
	
	# determine if we are deploying
	# all profiles in descriptor, see --all
	local deploy_all=false;
	
	# run script through checkbashisms and exit
	local lint=false;
	local run_script=false;	
	
	# quote command options by default
	local quote=true;
	
	# stores flags used to skip command
	# execution phases
	declare -A skip;
	skip["local.pre"]=false;
	skip["local.post"]=false;
	skip["remote.pre"]=false;
	skip["remote.post"]=false;
	skip["growl"]=false;
	
	# determine if we are deploying locally
	local deploy_local=false;
	
	# include version information in the target
	local include_version=false;
	
	# dump script contents to stdout
	local dump_script=false;

	# strategy used to determine the target
	# directory. the default is to include
	# the profile name in the target directory
	# structure
	local flat=false;	
	
	# determines whether we are generating json
	local print_json=false;
	local write_json=false;
	local pretty=false;	
	
	## DEFAULTS	
	
	# list of all profiles
	# defined in descriptor
	local all_profiles=();
	
	# the prefix used for deployment
	# interactive prompts
	local deploy_prompt_prefix="\033[1m[deploy]\033[0m";
	local deploy_prompt="${deploy_prompt_prefix} \033[4m%s\033[0m";
	local deploy_prompt_suffix=" ${characters[lightning]}";

	local descriptor="${root}/deploy.json";
	local newline=$'\n';
	
	# name validation regex
	local re="^[-a-zA-Z0-9]+$";
	
	# list of supported shells
	local shells=( sh bash zsh dash );

	# default to git deployment
	local default_type="git";	
	local type="${default_type}";
	local profile="default";
	local directory="";
	local shell="${bake_deploy_shell:-sh}";
	local host="${bake_deploy_remote:-}";
	
	# staging must be unquoted to allow ~ expansion
	local staging=${bake_deploy_staging:-~/.deploy};
	
	# human readable name using @ delimiter
	# must be set after option parsing in case a --name
	# option has been specified
	local deploy_name="${project_name}@${project_version}";
	# file name using a - delimiter	
	local deploy_file_name="${project_name}-${project_version}";
	
	# profile specific variables
	local script_name="${deploy_file_name}.sh";
	local script="${target}/${script_name}";
	local log_name="${deploy_file_name}.log";
	local log_dir="${staging}/log";
	local log_file="${log_dir}/${log_name}";
	
	# messages
	declare -A messages;
	# messages sent via `growlnotify`
	messages[success]="deploy ${deploy_name} complete";
	messages[fail]="deploy ${deploy_name} failed";	
	
	local deploy_staging_directory="${target}/deploy";
	local bundle_output="${deploy_staging_directory}";
	
	if [ ! -d "${deploy_staging_directory}" ]; then
		mkdir -p "${deploy_staging_directory}" \
			|| :tasks.deploy.fail "could not create %s" "${deploy_staging_directory}";
	fi
	
	local log="${deploy_staging_directory}/deploy.log";
	# clear the log file
	printf "" >| "${log}";

	# valid deployment types
	local types=( git tar npm );
	
	local profiles=();
	
	# a custom script file to use
	# instead of the generated script
	local script_source="";
	
	# command line options that override
	# properties set in deploy.json
	declare -A overrides;
	
	# JSON PROPERTIES
	
	local json_settings_file="${deploy_staging_directory}/settings.json";
	# array used to store properties to be
	# dumped as json
	unset json_dump;
	declare -A json_dump;
	json_dump["project-version"]="${project_version}";
	
	# parse options
	:tasks.deploy.options.parse "$@";
	
	# validate compression executables exist
	:tasks.compression.validate;
	
	# validate the descriptor after option parsing
	:tasks.deploy.descriptor.validate;
	
	# setting git defaults should be done
	# after validating the descriptor so that
	# this is done in the context of
	# the descriptor directory
	local default_git_remote="origin";
	local git_url git_ref git_remote="${default_git_remote}";
	git.remote.url "git_url";
	git.branch.current "git_ref";
	local default_url="${git_url}";
	
	# escape spaces in paths
	printf -v staging "%q" "${staging}";
	
	:tasks.deploy.parse;
	
	local default_profile="default";
	# if we are deploying everything
	if $deploy_all; then
		profiles=( ${all_profiles[@]} );
	fi
	
	# attempt to deploy the default profile
	# if profiles are empty this will occur
	# if none are specified on the command line
	# or none exist in the descriptor
	if [ ${#profiles[*]} -eq 0 ]; then
		profiles+=( "${default_profile}" );
	fi
	
	# prevent duplicate executions if a command line
	# declaration declares the same profile name
	:tasks.deploy.profiles.uniq!;
	
	# update some json dump properties after option parsing
	json_dump["project-name"]="${project_name}";	
	json_dump["descriptor"]="${descriptor}";
	json_dump["noop"]="${noop}";
	json_dump["local"]="${deploy_local}";
	local i;
	for i in ${!profiles[@]}
		do
			json_dump["targets.$i"]="${profiles[$i]}";
	done
	
	# validate whitespace on the project name
	:tasks.deploy.whitespace.validate "${project_name}" "project name";
	# validate whitespace on the staging property
	:tasks.deploy.whitespace.validate "${staging}" "staging";
	
	# validate the shell in use
	if ! array.contains? "$shell" "${shells[@]}"; then
		:tasks.deploy.fail "shell %s is not supported" "$shell";
	fi
	
	# configure the shebang
	local shebang="#!/bin/sh";
	if [ "${shell}" != "sh" ]; then
		shebang="#!/usr/bin/env ${shell}";
	fi
	
	# NOTE: reading commands should be done
	# NOTE: after setting all relevant variables
	# NOTE: so that all variables are available to commands being
	# NOTE: declared in the deploy.json descriptor
	
	local dly_doc_key dly_doc_value dly_env_re="^env_." dly_env_doc_re="\\\$doc_";
	# 1) expand properties in an `env`
	# 1) object exposed by direct variable name
	# 2) expand JSON document properties
	# 2) to doc_ local variables
	# 2) so that descriptor documents may
	# 2) cross-reference properties
	for dly_doc_key in "${!json_doc[@]}"
		do
			dly_doc_value="${json_doc["$dly_doc_key"]}";
			# sanitized to _ delimiter for variable names
			dly_doc_key="${dly_doc_key//\./_}";
			if [[ ! "$dly_doc_key" =~ $dly_env_re ]]; then
				# escape dollar symbols as `eval`
				# is invoked later on
				dly_doc_value="${dly_doc_value//\$/\\\$}";
								
				# prefix with doc_ for non-env properties
				dly_doc_key="doc_${dly_doc_key}";
			else
				if [[ "$dly_doc_value" =~ $dly_env_doc_re ]]; then
					:tasks.deploy.fail \
						"invalid %s cross-reference in %s" \
						"json" "env";
				fi
			fi
			
			dly_doc_value="${dly_doc_value//\`/\\\`}";
			
			#sanitize variable name
			dly_doc_key="${dly_doc_key//[^a-zA-Z0-9_]/_}";
			
			# declare variable
			if ${flags[global.env]}; then
				eval "export $dly_doc_key=\"$dly_doc_value\"";
			else
				eval "local $dly_doc_key=\"$dly_doc_value\"";
			fi
	done
	
	# deploy all profiles
	:tasks.deploy.profiles;

	# show the complete message
	:tasks.deploy.complete;
}

# DEPLOY PRIVATE COMMANDS

# validate a descriptor file
:tasks.deploy.descriptor.validate() {
	if [[ ! "${descriptor}" =~ \.json$ ]]; then
		:tasks.deploy.fail "descriptor %s does not have a .json file extension" \
			"${descriptor}";
	fi
	if [ ! -f "${descriptor}" ]; then
		:tasks.deploy.fail "no deploy descriptor %s" "${descriptor}";
	fi
	
	fs.path.expand "${descriptor}";
	descriptor="${_result}";
	
	# make working directory the descriptor parent
	fs.dirname "${descriptor}";
	setup[wd]="${_result}";
	
	local nm;
	fs.basename "${descriptor}" "nm";
	setup[descriptor.path]="${descriptor}";	
	setup[descriptor.name]="${nm}";
	
	:tasks.deploy.out.info "cd %s" "${setup[wd]}";
	cd "${setup[wd]}" \
		|| :tasks.deploy.fail "could not enter %s" "${setup[wd]}";
	:tasks.deploy.out.info "working directory %s" "$PWD";
	
	# fetch git information into set up for bundling
	if git.valid? "${setup[wd]}" && git.exists?; then
		setup[git.global.user.name]=$( git config --get --global user.name );
		setup[git.global.user.email]=$( git config --get --global user.email );	
		
		setup[git.user.name]=$( git config --get user.name );
		setup[git.user.email]=$( git config --get user.email );
		
		local git_branch_current git_branch_hash git_branch_message;
		git.branch.current;
		git.branch.hash;
		git.branch.message;
		
		# duplication but better for clarity
		setup[git.repo.path]="${setup[wd]}";		
		setup[git.repo.branch]="${git_branch_current}";
		
		setup[git.commit.hash]="${git_branch_hash}";
		setup[git.commit.message]="${git_branch_message}";
		setup[git.commit.author]=$( git.show.author "$git_branch_hash" );
	fi
}

# validate the directory
:tasks.deploy.directory.validate() {
	if [ -z "${directory}" ]; then
		:tasks.deploy.fail "directory may not be empty";
	fi
	
	# is this necessary???
	printf -v directory "%q" "${directory}";
}

# make profile list unique
:tasks.deploy.profiles.uniq!() {
	local IFS=$'\n';
	local lines=( ${profiles[*]} );
	unset IFS;
	profiles=( $( printf "${lines[*]}" | sort | uniq ) );
}

# deploy a series of profiles
:tasks.deploy.profiles() {
	local profile;

	# print profiles being processed
	:tasks.deploy.print.profiles;
	
	for profile in "${profiles[@]}"
		do
			if [ "${profile}" != "${default_profile}" ]; then
				if ! array.contains? "${profile}" "${all_profiles[@]:-}"; then
					console.warn "profile %s does not exist in %s" "${profile}" "${descriptor}";
					continue;
				fi
			fi
			# now attempt to deploy the profile
			:tasks.deploy.profile;
	done
	# dump/write json information
	if $print_json || $write_json; then
		if ! $pretty; then
			json.stringify <<< "json_dump";
		else
			json.stringify --pretty 2 <<< "json_dump";
		fi
		if $print_json; then
			json.string;
			printf "\n";
		fi
		if $write_json; then
			printf "" >| "$json_settings_file";
			json.string >> "$json_settings_file";
			printf "\n" >> "$json_settings_file";
		fi
	fi
}

# deploy a single profile
:tasks.deploy.profile() {
	
	# stores command to execute
	# for all profiles
	declare -A global_commands;
	
	# stores command to execute
	# for a profile
	declare -A profile_commands;

	# update profile specific variables
	
	local bundle_source bundle_name bundle_archive bundle_path;
	local settings;
	
	# bundle directory and move script to bundle
	bundle_name="${deploy_file_name}-${profile}";
	if ${flags[timestamp]}; then
		bundle_name="${bundle_name}-${setup[timestamp]}";
	fi
	
	if ${flags[author]}; then
		declare -l bundle_author="${setup[user]}";
		bundle_author="${bundle_author/^[^a-zA-Z0-9]/}";
		bundle_author="${bundle_author//[^a-zA-Z0-9]/-}";
		bundle_name="${bundle_author}-${bundle_name}";
	fi
	
	bundle_source="${bundle_output}/${bundle_name}";
	bundle_archive="${bundle_name}.${compression_extension}";
	bundle_path="${bundle_output}/${bundle_archive}";
	bundle_destination="${staging}/${bundle_name}";
	settings="${bundle_source}/settings.json";
	
	# clean an existing bundle directory
	if [ -d "${bundle_source}" ]; then
		rm -rfv "${bundle_source}" >> "${log}" 2>&1 \
			|| :tasks.deploy.fail "could not clean %s" "${bundle_source}";
	fi
	
	# create a fresh bundle directory
	mkdir -p "${bundle_source}" \
		|| :tasks.deploy.fail "could not create %s" "${bundle_source}";
	
	# scipt / log variables
	script_name="deploy.sh";
	script_dir="${bundle_source}";
	script="${script_dir}/${script_name}";
	log_name="${deploy_file_name}-${profile}.log";
	log_dir="${staging}/log";
	log_file="${log_dir}/${log_name}";
	
	# TODO: allow for the version to be included in the target directory
	local target_name="${project_name}";
	if $include_version; then
		target_name="${deploy_file_name}";
	fi
	# the full deployment target directory
	local deploy_target;
	
	# cascade properties
	:tasks.deploy.cascade;
}

# start execution of a profile
:tasks.deploy.profile.start() {
	# run local pre-deployment command execution
	:tasks.deploy.run.pre;
	
	:tasks.deploy.bundle.install!;
	
	# run local post-deployment command execution
	:tasks.deploy.run.post;
}

# cascade properties from the root of the document
# overwriting with profile specific properties if
# they have been set and finally with cli overrides
:tasks.deploy.cascade() {
	local prop var val;
	for prop in "${deploy_property_names[@]}"
		do
			val="";
			var="$prop";
			var="${var//[^a-zA-Z0-9_]/_}";
			
			# set top-level property
			if [ -n "${json_doc[$prop]:-}" ]; then
				val="${json_doc[$prop]:-}";
				# echo "setting top-level property: $var=$val";
			fi
			
			# set profile-specific property
			if [ -n "${json_doc[profiles.${profile}.${prop}]:-}" ];then
				val="${json_doc[profiles.${profile}.${prop}]}";
				# echo "setting profile property ($profile): $var=$val";
			fi
			
			# override with command line option
			if [ -n "${overrides[${prop}]:-}" ];then
				val="${overrides[${prop}]}";
				# echo "setting cli override: $var=$val";
			fi
			
			# set the variable
			if [ -n "$val" ]; then
				eval "local $var=\"\${val}\"";
			fi
	done
	
	# verify deployment type is valid
	local type="${type:-git}";
	if ! array.contains? "${type:-}" "${types[@]}"; then
		:tasks.deploy.fail "invalid deployment type %s" "${type:-}";
	fi
	
	# tar / git types must specify a url
	if [ -z "${url:-}" ]; then
		# use the default url extracted for a git repository
		# for the default profile if possible
		if [ "$profile" == "$default_profile" ] \
			&& [ "$type" == "git" ] \
			&& [ -n "${default_url:-}" ]; then
			url="$default_url";
		else
			:tasks.deploy.fail "%s (type: %s) no url" \
				"${profile}" "${type}";
		fi
	fi
	
	# allow variable references in the *url* property		
	if [ -n "${url:-}" ]; then
		eval "url=\"$url\"";
	fi
	
	# npm specific properties
	if [ "$type" == "npm" ] && [ -n "${url:-}" ]; then
		local npm_package_name="${project_name}";
		local npm_package_version="null";
		local npm_use_package=false;		
		local npm_package_re="([^@ ]+)(@| )(.*)?$";
		if [[ "${url:-}" =~ $npm_package_re ]]; then
			# echo "MATCHES NPM RE!!!"
			npm_package_name="${BASH_REMATCH[1]}";
			url="${BASH_REMATCH[3]}";
			npm_package_version="${url}";
			npm_use_package=true;
		fi
	fi
	
	# deploying default profile with a git type
	# and the parent of the descriptor is not 
	# a git repository
	if [ "$type" == "git" ] \
		&& [ "$profile" == "$default_profile" ] \
		&& ! git.valid? "${setup[wd]}"; then
		:tasks.deploy.fail "%s is not a git repsitory" "${setup[wd]}";
	fi
	
	if [ "$type" == "tar" ] \
		&& [[ ! "$url" =~ $scheme ]]; then
			:tasks.deploy.fail \
				"%s (type: %s) invalid url %s, must specify a scheme" \
				"${profile}" "${type}" "${url}";
	fi	
	
	# validate required data
	if ! $deploy_local && [ -z "${host}" ]; then
		:tasks.deploy.fail "no remote host information available for deploy";
	elif $deploy_local; then
		host="${localhost}";
	fi
	
	# set up the full deployment target directory
	deploy_target="${directory}/${target_name}";
	if ! $flat; then
		deploy_target="${deploy_target}/${profile}";
	fi
	
	# wrap descriptions
	if [ -n "${description:-}" ]; then
		description=$( printf "${description}" | fmt );
	fi
	
	if [ -z "${staging}" ]; then
		:tasks.deploy.fail "staging directory may not be empty";
	elif [[ "${staging}" =~ ^/+$ ]]; then
		:tasks.deploy.fail "staging directory may not be at the filesystem root";
	fi
	
	#echo "validating directory ... ${directory} ... ";
	
	# revalidate directory for profile specific overrides
	:tasks.deploy.directory.validate;
	
	# read in global commands
	:tasks.deploy.commands.read;
	
	# read in profile specific commands
	:tasks.deploy.commands.read "profiles.${profile}";

	if ${flags[print.env]}; then
		:tasks.deploy.env.print;
		return 0;
	fi	
	
	# ready to start, output useful settings information
	:tasks.deploy.info;
	
	if ! $print_json; then
		
		# create a package.json for the *npm* deployment type
		# must be done prior to creating the script so that
		# --lint-run works as expected
		if [ "$type" == "npm" ]; then
			:tasks.bundle.npm.package.write!;
		fi
		
		# write the deploy script file
		:tasks.deploy.script.write!;
	fi
	
	# run script through `checkbashisms`
	if $lint; then
		:tasks.deploy.script.lint;
	fi

	if ! $dump_script && ! $print_json; then
	
		:tasks.bundle.create;
		
		# only show the prompt and start
		# a deployment process if we are not
		# just creating bundles
		if ! $bundling; then
			# prompt for confirmation when possible
			# if --ok has been set the confirm command
			# will fall through to execution
			:tasks.deploy.confirm ":tasks.deploy.profile.start" "$profile";
		fi
	fi
	
	# clean up
	unset type;
	unset host;
	unset url;
	unset directory;
	unset profile_commands;
	
	# cleanup npm specific variable
	unset package;
	unset npm_package_name;
	unset npm_package_version;
}

:tasks.deploy.env.print() {
	local k v;
	for k in ${!doc_*}
		do
			variable.get "$k";
			v="$_result";
			printf "%s=%s\n" "$k" "$v";
	done
	for k in ${!env_*}
		do
			variable.get "$k";
			v="$_result";
			printf "%s=%s\n" "$k" "$v";
	done
}

# run pre-deployment local commands
:tasks.deploy.run.pre() {
	if "${skip["local.pre"]}"; then
		return 0;
	fi
	if [ "${#global_commands[@]:-0}" ]; then
		:tasks.deploy.run "pre" "commands.local.pre" true;
	fi
	:tasks.deploy.run "pre" "commands.local.pre";
}

# run post-deployment local commands
:tasks.deploy.run.post() {
	if "${skip["local.post"]}"; then
		return 0;
	fi
	if [ "${#global_commands[@]:-0}" ]; then
		:tasks.deploy.run "post" "commands.local.post" true;
	fi	
	:tasks.deploy.run "post" "commands.local.post";
}

# run a set of local commands
:tasks.deploy.run() {
	local phase="$1"
	local varname="$2";
	local use_global_commands="${3:-false}";
	local cmd list arr exe opt exit_code;
	
	# shortcut out for empty command maps	
	local length=0;
	if $use_global_commands; then
		length="${global_commands["${varname}.length"]:-0}";
	else
		length="${profile_commands["${varname}.length"]:-0}";
	fi
	if [ $length -eq 0 ]; then
		return 0;
	fi
	
	# ensure working directory is correct for local
	# command execution
	cd "${setup[wd]}" \
		|| :tasks.deploy.fail "could not enter %s" "${setup[wd]}";
	
	:tasks.deploy.out.info "exec local ${phase}-deployment commands (%s)" "$length";
	:tasks.deploy.out.info "working directory %s" "$PWD";
	
	# build list of commands to execute
	list=();
	:tasks.deploy.run.list;
	for cmd in "${list[@]:-}"
		do
			# echo "cmd is : ${cmd}";
			local IFS=$'\n';
			arr=( ${cmd} );
			unset IFS;
			if [ ${#arr[@]} -gt 0 ]; then
				#echo "arr length is :: ${#arr[@]}";
				exe="${arr[0]}";
				local IFS=$'\n';
				opt=( "${arr[@]:1}" );
				unset IFS;
				:tasks.deploy.out.info "exec %s %s" "${exe}" "${opt[*]:-}";
				
				# echo "run command : ${exe} : ${opt[@]:-}";
				
				# validate the executable being executed
				executable.validate --test "${exe}";
				if [ -z "${executables[$exe]}" ]; then
					:tasks.deploy.fail "executable %s is not available" "$exe";
				fi
				
				#echo "run command (after validation) : ${exe} : ${opt[@]:-} : length:  ${#opt[@]}";
				
				# execute the command
				if ! $noop; then
					if ! $logging; then
						if $quote; then
							( ${exe} "${opt[@]:-}" ); exit_code=$?;
						else
							( ${exe} ${opt[@]:-} ); exit_code=$?;
						fi
					else
						if $quote; then
							( ${exe} "${opt[@]:-}" >> "${log}" 2>&1 );
							exit_code=$?;
						else
							( ${exe} ${opt[@]:-} >> "${log}" 2>&1 );
							exit_code=$?;
						fi
					fi
					if [ $exit_code -gt 0 ]; then
						:tasks.deploy.fail "execution error %s %s" "$exe" "${opt[*]:-}";
					fi
				fi
			fi
	done
}

# fetch the command type subset 
# as an ordered array of commands
:tasks.deploy.run.list() {
	local k v keys i;
	local re="${varname//\./\\.}";
	re="^$re\.([0-9]+)";
	if $use_global_commands; then
		for k in "${!global_commands[@]}"
			do
				v="${global_commands[$k]}";
				:tasks.deploy.run.list.add;
		done
	else
		for k in "${!profile_commands[@]}"
			do
				v="${profile_commands[$k]}";
				:tasks.deploy.run.list.add;
		done		
	fi
}

# add a command to the list of
# commands to be processed
:tasks.deploy.run.list.add() {
	if [[ "$k" =~ $re ]]; then
		i="${BASH_REMATCH[1]}";
		list[$i]="$v";
	fi
}

# read in commands
:tasks.deploy.commands.read() {
	local prefix="${1:-}";
	local use_global_commands=false;
	if [ -z "$prefix" ]; then
		prefix="commands";
		use_global_commands=true;
	else
		prefix="${prefix}.commands";
	fi
	
	local local_pre_length="${json_doc[${prefix}.local.pre.length]:-0}";
	local local_post_length="${json_doc[${prefix}.local.post.length]:-0}";
	local remote_pre_length="${json_doc[${prefix}.remote.pre.length]:-0}";
	local remote_post_length="${json_doc[${prefix}.remote.post.length]:-0}";
	
	# echo "testing $prefix for remote pre: ${remote_pre_length}";
	# echo "testing $prefix for remote post: ${remote_post_length}";
	
	if [ $local_pre_length -gt 0 ]; then
		:tasks.deploy.commands.read.group \
			"$prefix" \
			"${prefix}.local.pre" \
			$local_pre_length \
			"commands.local.pre"
	fi
	if [ $local_post_length -gt 0 ]; then
		:tasks.deploy.commands.read.group \
			"$prefix" \
			"${prefix}.local.post" \
			$local_post_length \
			"commands.local.post"
	fi
	if [ $remote_pre_length -gt 0 ]; then
		:tasks.deploy.commands.read.group \
			"$prefix" \
			"${prefix}.remote.pre" \
			$remote_pre_length \
			"commands.remote.pre"
	fi
	if [ $remote_post_length -gt 0 ]; then
		:tasks.deploy.commands.read.group \
			"$prefix" \
			"${prefix}.remote.post" \
			$remote_post_length \
			"commands.remote.post"
	fi
}

# read in a group of commands
:tasks.deploy.commands.read.group() {
	local prefix="$1";
	local group="$2";
	local length="$3";
	local varname="$4";
	local i j jl exe opt cmd;
	
	local whitespace="[ 	]";
	
	# echo "GROUP READ !!! : $group";
	# echo "GROUP READ !!! : ${!json_doc[*]}";
	
	for((i = 0;i < $length;i++))
		do
			cmd="";
			exe="${json_doc[${group}.$i.command]:-}";
			if [ -z "$exe" ]; then
				console.error "invalid command %s in %s" "$exe" "$descriptor";
				:tasks.deploy.fail "%s may not be a blank string" "command";
			fi
			
			# echo "got exe: $exe";
			
			if [[ "$exe" =~ $whitespace ]]; then
				console.error "invalid command %s in %s" "$exe" "$descriptor";
				:tasks.deploy.fail "%s may not contain whitespace" "command";
			fi
			
			jl="${json_doc[${group}.$i.options.length]:-0}";
			
			# echo "read command at index $i : $group : $exe"
			
			if [ -n "$exe" ]; then
				cmd="${exe}";
			fi
			
			for((j = 0;j < $jl;j++))
				do
					opt="${json_doc[${group}.$i.options.$j]}";
					
					# evaluate each option so that variable
					# references can be used
					trap :tasks.deploy.unbound.variable EXIT
					eval "opt=\"${opt}\"";
					trap - EXIT
					
					cmd="${cmd}
${opt}";
			done
			
			if $use_global_commands; then
				global_commands["${varname}.$i"]="${cmd}";
			else
				profile_commands["${varname}.$i"]="${cmd}";
			fi
	done
	
	# add length properties
	if $use_global_commands; then
		global_commands["${varname}.length"]="${i}";
	else
		profile_commands["${varname}.length"]="${i}";
	fi
}

# handles the situation when a command *probably*
# references an unbound variable
:tasks.deploy.unbound.variable()
{
	# console.throw "probable reference to unbound variable";
	console.error "probable reference to unbound variable";
	:tasks.deploy.fail "invalid command %s" "${cmd//$newline/ }";
}

# either outputs configuration information
# for the profile being processed or prints
# a json document 
:tasks.deploy.info() {

	# always build up the json settings so that
	# this data can be written to a file when
	# performing a deployment
	local script_file="${script}";
	local script_shell="${shell}";
	local script_shebang="${shebang}";
	
	# variable names to inspect for
	# each profile being processed
	local var key
	
	# use all json property names
	local vars=( "${deploy_property_names[@]}" );
	# add property names set internally
	vars+=(
		deploy_name
		deploy_file_name
		deploy_target
		script_shell
		script_shebang
		script_file
		script_dir
		bundle_archive
		bundle_source
		bundle_path
		log_file
		log_dir
	);
	
	if [ "$type" == "git" ]; then
		vars+=( git_ref git_remote url );
	elif [ "$type" == "tar" ]; then
		vars+=( url );
	fi
	
	# using custom script
	if [ -n "${script_source}" ]; then
		vars+=( script_source );
	fi
	
	local value k len;
	for var in "${vars[@]}"
		do
			# replace first underscore with a dot to group
			# as object on variable names with the same prefix
			key="${var/_/.}";
			if ! array.is.array? "${var}" && ! array.is.assoc? "${var}"; then
				key="${key//_/-}";
				variable.get "${var}";
				value="${_result:-}";
				if [ -n "${value}" ]; then
					# echo "adding to json_dump $key : $value";
					json_dump["profiles.${profile}.$key"]="$value";
				fi
			else
				key="${var//_/.}";
				#echo "ADD ARRAY CONTENTS:::!!! $key : $var"
				eval "keys=( \${!$var[@]} )";
				eval len="\${#$var[@]}";
				if [ $len -gt 0 ]; then
					# echo "add with array length : ${len}";
					for k in "${keys[@]:-}"
						do
							eval value="\${$var[$k]}";
							# echo "adding array element : $k : $value"
							if [ -n "${value}" ]; then
								json_dump["profiles.${profile}.${key}.${k}"]="$value";
							fi
					done
				fi
			fi
	done
	
	# otherwise print out information to stdout
	if ! $print_json && ! $dump_script; then
		local start_time=$( date )
		
		# HEADER
		:tasks.deploy.out.info "%s (%s) on %s" "${deploy_name}" "${creator}" "${setup[platform]}";
		
		# INFO		
		:tasks.deploy.header;
		:tasks.deploy.out.info "%s" "${start_time}";
		:tasks.deploy.header;		
		if [ -n "${description:-}" ]; then
			:tasks.deploy.out.info "${description}";
		fi
		
		# BUNDLE
		:tasks.deploy.header;
		:tasks.deploy.out.info "bundle";
		:tasks.deploy.header;		
		:tasks.deploy.out.info "name %s" "${bundle_name}";
		:tasks.deploy.out.info "archive %s" "${bundle_archive}";
		:tasks.deploy.out.info "source %s" "${bundle_source}";
		:tasks.deploy.out.info "path %s" "${bundle_path}";
		:tasks.deploy.header;		
		
		# SETTINGS
		:tasks.deploy.header;
		:tasks.deploy.out.info "settings";
		:tasks.deploy.header;
		:tasks.deploy.out.info "host %s" "${host}";		
		:tasks.deploy.out.info "profile %s" "${profile}";
		:tasks.deploy.out.info "type %s" "${type}";
		:tasks.deploy.out.info "noop %s" "${noop}";
		:tasks.deploy.out.info "shell %s" "${shell}";
		:tasks.deploy.out.info "url %s" "${url}";
		
		# type specific / optional settings		
		if [ "$type" == "git" ]; then
			:tasks.deploy.out.info "git ref %s" "${git_ref}";
			:tasks.deploy.out.info "git remote %s" "${git_remote}";
		fi
		# using custom script
		if [ -n "${script_source}" ]; then
			:tasks.deploy.out.info "source script %s" "${script_source}";
		fi
		
		# PATHS
		:tasks.deploy.header;
		:tasks.deploy.out.info "paths";
		:tasks.deploy.header;
		:tasks.deploy.out.info "working directory: %s\n" "${PWD}";
		:tasks.deploy.out.info "descriptor %s" "${descriptor}";
		:tasks.deploy.out.info "directory %s" "${directory}";
		:tasks.deploy.out.info "staging %s" "${staging}";
		:tasks.deploy.out.info "script %s" "${script}";		
		:tasks.deploy.out.info "log file %s" "${log_file}";
		:tasks.deploy.header;		
		
		# FINAL TARGET
		:tasks.deploy.out.info "";		
		:tasks.deploy.out.info "\t %s" "${deploy_target}";
		:tasks.deploy.out.info "";		
		:tasks.deploy.header;		
	fi
}

# print profiles
:tasks.deploy.print.profiles() {
	:tasks.deploy.header;
	:tasks.deploy.out.info "deploy %s" "$deploy_start_time";
	:tasks.deploy.out.info "started by %s" "${deploy_user}@${localhost}";
	:tasks.deploy.out.info "";		
	local p;
	for p in "${profiles[@]}"
		do
			:tasks.deploy.out.info "\t%s" "$p";
	done
	:tasks.deploy.out.info "";
	:tasks.deploy.header;	
}

# output the header delimiter
:tasks.deploy.header() {
	if ${flags[quiet]} || $print_json || $dump_script || ${flags[print.env]}; then
		return 0;
	fi	
	
	if ! $logging; then
		console.header;
	else
		console.header "$@" >> "${log}" 2>&1;
	fi	
}

# output an info message to stdout or
# the log file if logging
:tasks.deploy.out.info() {
	if ${flags[quiet]} || $print_json || $dump_script || ${flags[print.env]}; then
		return 0;
	fi
	
	if ! $logging; then
		console.info "$@";
	else
		console.info "$@" >> "${log}" 2>&1;
	fi
}

# build up the prompt string
:tasks.deploy.prompt() {
	local replace="${1:-}";
	local ps1=$( printf "$deploy_prompt" "$replace" );
	#echo -n "${ps1}${rlx_prompt_suffix}";
	prompt="${ps1}${deploy_prompt_suffix}";
}

# interactive confirmation for
# a profile deployment
:tasks.deploy.confirm() {
	local callback="${1:-}";
	# stdin or stdout is not a tty
	# cannot interact
	if ! $interactive || [ ! -t 0 ] || [ ! -t 1 ]; then
		# invoke callback to start deployment
		$callback;
		return 0;
	fi
	
	local replace="${2:-}";
	:tasks.deploy.prompt "${replace}";

	accepted() {
		$callback;
	}

	rejected() {
		:tasks.deploy.fail "aborted %s" "${replace}";
	}

	# define a boolean prompt
	prompt.boolean confirm y n "${prompt} are you sure? (y/n)";
	# set accept/reject callback(s)
	prompt.accepts accepted;
	prompt.rejects rejected;
	prompt.show confirm;
	prompt.clean;
	
	# clean up confirmation callbacks
	method.remove accepted rejected;
}

# validate variable value does not contain
# whitespace: space or tab character
:tasks.deploy.whitespace.validate() {
	local value="${1:-}";
	local name="${2:-}";
	# staging directory cannot contain whitespace
	# so that we can perform tilde expansion
	local re="[ 	]+";
	if [[ "${value}" =~ $re ]]; then
		:tasks.deploy.fail "invalid %s value %s, cannot contain whitespace" \
			"${name}" "${value}";
	fi
}

# parse the deploy descriptor as JSON
:tasks.deploy.parse() {
	json_exit=false;
	json.parse < "${descriptor}" >> "$log" 2>&1;
	if [ $json_exit_code -gt 0 ]; then
		console.error "invalid json in %s" "$descriptor";
		:tasks.deploy.fail "stack trace in %s" "$log";
	fi	
	# fetch all profile names in to
	# the all_profiles list
	declare -A names;
	local k tk profile_re="^(profiles\.([^.]+))\.?";
	for k in "${!json_doc[@]}"
		do
			if [[ "$k" =~ $profile_re ]]; then
				names["${BASH_REMATCH[2]}"]=true;
				
				# assign the default deployment type when none
				# has been specified
				tk="${BASH_REMATCH[1]}.type";
				if [ -z "${json_doc[$tk]:-}" ]; then
					json_doc[$tk]="${default_type}";
				fi
			fi
	done
	# validate profile names in descriptor
	# match the rules for project/profile names
	for k in "${!names[@]}"
		do
			# quit on invalid profile name in the deploy descriptor
			if ! :tasks.name.valid? "${k}"; then
				:tasks.name.quit "profile" "$k";
			fi
	done
	all_profiles=( ${!names[@]} );
	
	if [ "${#all_profiles[@]:-0}" -gt 0 ]; then
		# sort profiles
		local IFS="$newline";
		local all="${all_profiles[@]}";
		local sorted_profiles=( $( echo "${all}" | sort ) );
		unset IFS;
		all_profiles=( ${sorted_profiles[@]} );
	
		if $print_profiles; then
			if [ "${#all_profiles[@]}" -eq 0 ]; then
				:tasks.deploy.fail "no profiles in %s" "$descriptor";
			else
				local IFS="$newline";
				local all="${all_profiles[@]}";
				echo "$all";
				console.success;
			fi
		fi
	fi	
}

# failure
:tasks.deploy.fail() {
	:tasks.deploy.complete.notify;
	if [ $# -gt 0 ]; then
		console.error "$@";
	fi
	console.quit 1 "deploy %s failed %s" \
			"${deploy_name}" "${characters[cross]}";
}

# attempts to notify via `growlnotify` when available
:tasks.deploy.complete.notify() {
	
	# don't send growl notifications for
	# json dumps or noop
	if $noop || ${skip[growl]}; then
		return 0;
	fi
	
	if [ -n "${executables[growlnotify]}" ]; then
		local message;
		local priority="${2:-Normal}";
		if $success; then
			message="${messages[success]}";
		else
			priority="Emergency";
			message="${messages[fail]}";
		fi
		"${executables[growlnotify]}" -m "$message" --priority "$priority";
	fi
}

# output the complete message
:tasks.deploy.complete() {
	
	if ${flags[quiet]} || ${flags[print.env]}; then
		return 0;
	fi
	
	# noop should always succeed
	if $noop; then
		success=true;
	fi
	
	# output success information
	if $success; then
		:tasks.deploy.complete.notify;
		if $print_json || $dump_script; then
			console.success;
		else
			console.success "deploy %s complete %s" \
				"${deploy_name}" "${characters[tick]}";
		fi
	else
		:tasks.deploy.fail;
	fi
}

# validate a name follows the convention
:tasks.name.valid?() {
	local name="${1:-}";
	# may not start with a hyphen
	# and must match the name regex
	if [[ "$name" =~ ^-+ ]] || [[ ! "$name" =~ $re ]]; then
		return 1;
	fi
	return 0;
}

# quit if an invalid name is encountered
:tasks.name.quit() {
	local var="$1";
	local value="$2";
	console.error "names may not start with a hyphen and must match %s" "$re";	
	console.error "invalid $var name %s" "$value";
	:tasks.deploy.fail;
}

# OPTIONS

:tasks.compression.validate() {
	local copts=( ${compression_types[$compression]} );
	compression_extension="${copts[0]}";
	unset copts[0];
	# check all binaries are available on the local machine
	executable.validate tar ${copts[@]};
	
	# require GNU tar
	tar --version | grep "GNU" > /dev/null 2>&1 \
		|| :tasks.deploy.fail "GNU tar is required";
	
	if [ "$compression" != "gz" ]; then
		# check tar version
		local tarv=$( tar --version | awk '{print $4}' || \
			:tasks.deploy.fail "could not fetch version information for %s" \
			"tar" );
		local min="22" got="" ver="";
		if [[ "${tarv}" =~ ^([0-9]+\.([0-9]+)) ]]; then
			ver="${BASH_REMATCH[1]}";
			got="${BASH_REMATCH[2]}";
			if [ -n "$got" ]; then
				if [ $got -lt $min ]; then
					:tasks.deploy.fail \
						"tar minor version >= %s is required, version is %s" \
						"$min" "$ver";
				fi
			fi
		fi
	fi
}

# parse options
:tasks.deploy.options.parse() {
	local value available;
	while test -n "${1:-}"; do
		case $1 in	
			--ok )
				interactive=false;
				;;
			--noop )
				noop=true;
				interactive=false;				
				;;
			--list )
				print_profiles=true;
				flags[quiet]=true;				
				;;				
			--staging )
				shift;
				staging="${1:-}";
				;;
			--local )
				deploy_local=true;
				;;
			--json )
				print_json=true;
				noop=true;
				dump_script=false;				
				;;
			--write-json )
				write_json=true;
				;;
			--script )
				dump_script=true;
				noop=true;
				print_json=false;
				;;
			--lint )
				lint=true;
				noop=true;				
				;;
 			--lint-run )
				lint=true;
				run_script=true;
				deploy_local=true;				
				noop=true;
				;;				
			--pretty )
				pretty=true;
				;;
			--expand )
				quote=false;
				;;
			--flat )
				flat=true;
				;;	
			--include-version )
				include_version=true;
				;;
			--all )
				deploy_all=true;
				;;				
			--no-local )
				skip["local.pre"]=true;
				skip["local.post"]=true;
				;;
			--no-local-pre )
				skip["local.pre"]=true;
				;;
			--no-local-post )
				skip["local.post"]=true;
				;;
			--no-remote )
				skip["remote.pre"]=true;
				skip["remote.post"]=true;
				;;
			--no-remote-pre )
				skip["remote.pre"]=true;
				;;
			--no-remote-post )
				skip["remote.post"]=true;
				;;
			--no-growl )
				skip["growl"]=true;
				;;
			--log )
				logging=true;
				;;
			--print-env )
				flags[print.env]=true;
				noop=true;
				;;
			--global-env )
				flags[global.env]=true;
				;;
			--bundle )
				bundling=true;
				noop=true;
				skip["local.pre"]=true;
				skip["local.post"]=true;
				skip["remote.pre"]=true;
				skip["remote.post"]=true;
				;;
			--gz )
				compression="gz";
				;;
			--bz )
				compression="bz";
				;;
			--xz )
				compression="xz";
				;;
			--lzma )
				compression="lzma";
				;;
			--timestamp )
				flags[timestamp]=true;
				;;
			--author )
				flags[author]=true;
				;;
			--no-sha )
				flags[sha]=false;
				;;
			--inspect )
				flags[bundle.inspect]=true;
				;;
			--pkg )
				flags[bundle.package]=true;
				;;
			--no-pkg )
				flags[bundle.package]=false;
				;;
			--follow-symlinks )
				flags[bundle.package.follow.symlinks]=true;
				;;
			--include-hidden )
				flags[bundle.package.include.hidden]=true;
				;;
			--quiet )
				flags[quiet]=true;
				;;
			--verbose )
				flags[verbose]=true;
				;;
			--sha )
				shift;
				value="${1:-}";
				if ! array.contains? "${value}" ${defaults[sha.algorithms]}; then
					:tasks.deploy.fail "unknown sha algorithm %s" "$value";
				fi
				setup[sha.algorithm]="${value}";
				flags[sha]=true;
				;;
			--output )
				shift;
				value="${1:-}";
				if [ ! -d "${value}" ]; then
					:tasks.deploy.fail "bundle output %s is not a directory" "$value";
				fi
				if [ ! -w "${value}" ]; then
					:tasks.deploy.fail "bundle output %s is not writable" "$value";
				fi
				bundle_output="${value}";
				;;
			--script-source )
				shift;
				value="${1:-}";
				if [ ! -f "${value}" ]; then
					:tasks.deploy.fail "script file %s does not exist" "$value";
				fi
				if [ ! -x "${value}" ]; then
					:tasks.deploy.fail "script file %s is not executable" "$value";
				fi
				script_source="${value}";
				;;
			--shell )
				shift;
				value="${1:-}";
				if [ -z "${value}" ]; then
					:tasks.deploy.fail "no shell specified";
				fi
				shell="${value}";
				;;
			--name )
				shift;
				value="${1:-}";
				if [ -z "${value}" ]; then
					:tasks.deploy.fail "no name specified";
				fi
				if ! :tasks.name.valid? "${value}"; then
					:tasks.name.quit "project" "$value";
				fi
				project_name="${value}";
				;;
			--directory )
				shift;
				value="${1:-}";
				if [ -z "${value}" ]; then
					:tasks.deploy.fail "no directory specified";
				fi
				directory="${value}";
				:tasks.deploy.directory.validate;
				overrides[directory]="${value}";
				;;
			--host )
				shift;
				value="${1:-}";
				if [ -z "${value}" ]; then
					:tasks.deploy.fail "no host specified";
				fi
				overrides[host]="${value}";
				;;
			--descriptor )
				shift;
				value="${1:-}";
				if [ -z "${value}" ]; then
					:tasks.deploy.fail "no descriptor specified";
				fi
				descriptor="${value}";
				;;
			-* | --* )
				:tasks.deploy.fail "unknown option %s" "$1";
				;;
			* )
				if ! :tasks.name.valid? "$1"; then
					:tasks.name.quit "profile" "$1";
				fi
				profiles+=( "$1" );
				;;
		esac
		shift;
	done
}