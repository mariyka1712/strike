# create the deployment bundle
:tasks.bundle.create() {
	:tasks.deploy.out.info "creating bundle %s" "$bundle_archive";
	
	local bundle_size="0KB";
	local bundle_scripts_name="scripts";
	local bundle_contents_name="contents";	
	local bundle_contents_git_ignored="gitignore.txt";
	local bundle_ignore_file=".xpmignore";
	
	# must be done here to be written to info.json
	local shafile="${bundle_name}.sha${setup[sha.algorithm]}";
	setup[sha.file]="${shafile}";
	
	# no point writing the sha data when not
	# generating a checksum
	if ! ${flags[sha]}; then
		unset setup[sha.algorithm];
		unset setup[sha.file];
	fi
	
	# always write the effective settings into the bundle
	:tasks.bundle.settings.write!	
	
	# add scripts to bundle
	:tasks.bundle.scripts;
	
	# add package contents
	:tasks.bundle.contents;
	
	# copy the descriptor
	:tasks.bundle.descriptor.copy;
	
	# create the info.json file
	:tasks.bundle.info.write!;
	
	# write the makefile wrapper
	:tasks.bundle.makefile;	
	
	# create the bundle
	:tasks.bundle.archive.create;
	
	# clean up after bundle creation
	rm -rfv "${bundle_source}" >> "${log}" 2>&1 \
		|| :tasks.deploy.fail "could not clean bundle source %s" "$bundle_source";
		
	:tasks.deploy.out.info "created bundle %s (%s)" "$bundle_archive" "$bundle_size";
	:tasks.deploy.header;
}

# include any scripts in the bundle
:tasks.bundle.scripts() {
	local global_scripts="${json_doc[bundle.scripts.length]:-0}";
	local profile_scripts="${json_doc[profiles.${profile}.bundle.scripts.length]:-0}";
	local total_scripts=$((global_scripts+profile_scripts));
	if [ $total_scripts -gt 0 ]; then
		:tasks.deploy.out.info "bundle %s script(s)" "$total_scripts";
		local scripts_path="${bundle_source}/${bundle_scripts_name}";
		mkdir -p "${scripts_path}" \
			|| :tasks.deploy.fail "could create bundle script directory %s" "$scripts_path";
			if [ $global_scripts -gt 0 ]; then
				:tasks.bundle.scripts.group $global_scripts "bundle.scripts";
			fi
			if [ $profile_scripts -gt 0 ]; then
				:tasks.bundle.scripts.group $profile_scripts "profiles.${profile}.bundle.scripts";
			fi
	fi
}

# adds bundle package contents
:tasks.bundle.contents() {
	if ${flags[bundle.package.contents]}; then
		
		local cp_opts="-p";
		if ! ${flags[bundle.package.follow]}; then
			cp_opts="${cp_opts}R";
		fi
		
		local contents_path="${bundle_source}/${bundle_contents_name}";
		mkdir -p "${contents_path}" \
			|| :tasks.deploy.fail "could create bundle contents directory %s" \
				"$contents_path";		
		
		# TODO: make the source directory for packaging configurable
		local contents="${setup[wd]}";
		
		local exclude_file="${contents}/${bundle_ignore_file}";
		local exclude_patterns=();
		
		# check if we need to obey a custom ignore file
		if [ -f "${exclude_file}" ]; then
			exclude_patterns=( $( < "${exclude_file}" ) );
			cp "${exclude_file}" "${bundle_source}";
		fi
		
		# be certain we are operating in the correct context
		cd "${contents}";
		local ignore_re="^((\.git/)+|(\.svn/)+)";
		:tasks.deploy.out.info "package contents %s" "${contents}";
		
		local file relative parent name path files symlink;
		if git.exists? && git.valid? "${contents}"; then
			files=( $( git ls-files ) );
			git ls-files \
				--others > "${bundle_source}/${bundle_contents_git_ignored}";
		else
			files=( $( find "${contents}" ) );
		fi
		
		local i length=${#files[@]:-0};
		for file in "${files[@]}"
			do
				fs.basename "${file}" "name";
				relative="${file#$contents/}";
				
				if :tasks.bundle.contents.ignore?; then
					if ${flags[verbose]}; then
						:tasks.deploy.out.info "ignore %s" "${relative}";
					fi
					continue;
				fi

				if ${flags[verbose]}; then
					:tasks.deploy.out.info "add %s" "${relative}";
				fi
				
				# can't use cp --parents on BSD :(
				fs.dirname "${relative}" "parent";
				if [ "$parent" == "." ]; then
					parent="";
				fi
				path="${contents_path}";
				if [ -n "${parent}" ]; then
					path="${contents_path}/${parent}";
				fi
				
				# echo "file is: $file";
				# echo "parent is: $parent";
				# echo "name is: $name";
				# echo "destination is: $path";
				
				# create directories as needed
				# top-level file(a) don't need a parent created
				if [ ! -d "$path" ]; then
					mkdir -p "$path";
				fi
				
				if [ -f "${file}" ]; then
					# NOTE: we copy with -R even though it is a file
					# NOTE: to preserve symbolic links
					cp ${cp_opts} "${file}" "${path}/${name}";
				elif [ -L "${file}" ]; then
					symlink=$( readlink "$file" );
					# preserve symbolic links for directories
					if ! ${flags[bundle.package.follow]}; then
						cd "$path" && ln -s "$symlink" "$name";
						cd "${contents}";
					# TODO: copy over contents of symbolic link directory
					# TODO: when following symlinks
					fi
				fi
		done
	fi
}

# determine if a packaged file is being ignored
:tasks.bundle.contents.ignore?() {
	if [[ "$relative" =~ $ignore_re ]]; then
		return 0;
	fi
	if ! ${flags[bundle.package.hidden]}; then
		if [[ "$name" =~ ^\. ]]; then
			return 0;
		fi
	fi
	if [ ${#exclude_patterns[@]} -gt 0 ]; then
		:tasks.bundle.contents.xpmignore?;
		return $?;
	fi
	return 1;
}

# test for exclusion against .xpmignore patterns
:tasks.bundle.contents.xpmignore?() {
	local ptn;
	for ptn in "${exclude_patterns[@]}"
		do
			[[ "$relative" =~ $ptn ]] && { return 0; }
			if [ $? -eq 2 ]; then
				:tasks.deploy.fail "invalid pattern %s" "$ptn";
			fi
	done
	return 1;
}

# 
:tasks.bundle.scripts.group() {
	local i k file nm dir destination;
	local length="${1:-0}";
	local prefix="${2:-}";
	for((i = 0;i < $length;i++))
		do
			destination="${scripts_path}";
			k="${prefix}.${i}";
			file="${json_doc[${k}.file]:-}";
			dir="${json_doc[${k}.dir]:-}";
			if [ -z "$file" ]; then
				:tasks.deploy.fail "script entry does not declare the %s field" "file";
			fi
			# resolve relative to the descriptor
			# otherwise treat as a relative or absolute path
			if [[ ! "$file" =~ ^(\.\.)?/ ]]; then
				file="${setup[wd]}/$file";
			fi
			if [ ! -f "$file" ]; then
				:tasks.deploy.fail "script %s does not exist" "${file}";
			fi
			if [ ! -x "$file" ]; then
				:tasks.deploy.fail "script %s is not executable" "${file}";
			fi
			fs.basename "${file}" "nm";
			if [ -f "${destination}/$nm" ]; then
				:tasks.deploy.fail "duplicate script %s, script names must be unique" "${nm}";
			fi
			
			# got a custom directory structure for the script
			if [ -n "${dir}" ]; then
				if [[ "$dir" =~ ^[./] ]]; then
					:tasks.deploy.fail "invalid script directory %s, may not begin with . or /" "${dir}";
				fi
				# echo "ADDING TO CUSTOM DIRECTORY (after): $dir";
				:tasks.deploy.out.info "create script directory %s" "$dir";
				destination="${destination}/${dir}";
				mkdir -p "${destination}" \
					|| :tasks.deploy.fail "could not creat scripts directory %s" "${destination}";
			fi
			
			cp "$file" "${destination}" \
				|| :tasks.deploy.fail "could not copy script %s" "${file}";
	done
}

# copy the descriptor to the bundle source directory
:tasks.bundle.descriptor.copy() {
	cp "${descriptor}" "${bundle_source}/descriptor.json" \
		|| :tasks.deploy.fail "could not copy bundle descriptor %s" "$bundle_path";
}

# create the bundle archive
:tasks.bundle.archive.create() {
	{
		cd "$bundle_output" \
			&& tar -cf "$bundle_archive" "$bundle_name";
	} || :tasks.deploy.fail "failed to create bundle %s" "$bundle_path";
	
	
	if ${flags[sha]}; then		
		checksum.sha "${setup[sha.algorithm]}" "$bundle_archive" >| "${shafile}" \
			|| :tasks.deploy.fail "could not generate checksum for %s" "${bundle_archive}";
		:tasks.deploy.out.info "sha file %s" "${shafile}";
	fi
	
	local size=( $( du -h "${bundle_archive}" ) );
	bundle_size="${size[0]}";
	
	if ${flags[bundle.inspect]}; then
		local inspect_opts="-t";
		if ${flags[verbose]}; then
			inspect_opts="${inspect_opts}v";
		fi
		inspect_opts="${inspect_opts}f";
		tar $inspect_opts "${bundle_archive}";
	fi
	
	# revert to the main working directory
	cd "${setup[wd]}";
}

# write the info.json file
:tasks.bundle.info.write!() {
	local info="${bundle_source}/info.json";
	json.stringify --pretty 2 <<< "setup";
	json.string > "${info}";
}

# write the deploy settings for the profile to the bundle
:tasks.bundle.settings.write!() {
	# TODO: fix json.stringify memory leak
	# TODO: probably due to the string concatenation
	
	# echo "before write json";
	json.stringify --pretty 2 <<< "json_dump";
	json.string > "${settings}";
	# echo "after write json";
}

# creates a package.json for an *npm* installation type
:tasks.bundle.npm.package.write!() {
	local npm_package_file="${bundle_source}/package.json";
	:tasks.deploy.out.info "npm name %s" "$npm_package_name";
	:tasks.deploy.out.info "npm version %s" "$npm_package_version";
	:tasks.deploy.out.info "npm package %s" "$npm_package_file";
	
	# create the npm package descriptor file
	touch ${npm_package_file} \
 		|| :tasks.deploy.fail "could not create %s" "$npm_package_file";
			
# write out the package descriptor into the bundle source directory
cat <<NPMPKG >> ${npm_package_file}
{
	"name": "${project_name}-${profile}-npm-deploy",
	"version": "0.0.1",	
	"private": "true",
	"dependencies": {
		"$npm_package_name": "${url}"
	}
}
NPMPKG
}

# perform the bundle installation
:tasks.deploy.bundle.install!() {
	
	# local deployment
	if $deploy_local; then
		:tasks.deploy.out.info "local install %s" "${bundle_archive}";
		# copy packaged bundle to staging
		cp "${bundle_path}" "${staging}" \
			|| :tasks.deploy.fail "could not copy bundle %s" "${bundle_path}";
		cd "${staging}" && tar -xf "${bundle_archive}" \
			|| :tasks.deploy.fail "could not extract bundle %s" "${staging}/${bundle_archive}";
		
		# script_name
		cd "${bundle_name}" \
			|| :tasks.deploy.fail "could not enter %s" "${staging}/${bundle_name}";
			
		# run the script
		if ! $logging; then
			"./${script_name}";
		else
			"./${script_name}" >> "${log}" 2>&1;
		fi
		if [ $? -eq 0 ]; then
			success=true;
			:tasks.deploy.complete;
		fi
		:tasks.deploy.fail;
	# remote deployment
	else
		# TODO: implement
		echo "start remote deployment ... ";
	fi
	
	# local test_staging='test -d '${staging}'; echo $?;';
	# local mk_staging='mkdir -p '${staging}'';
	# 
	# # test if the staging directory exists
	# :tasks.deploy.out.info "${executables[ssh]} %s %s" \
	# 	"${host}" "${test_staging}";
	# local exists=0;
	# if ! $noop; then
	# 	exists=$( "${executables[ssh]}" "${host}" ""${test_staging}"" );
	# fi
	# 
	# # create remote staging directory if it does not exist
	# if [ $exists -gt 0 ]; then
	# 	:tasks.deploy.out.info "${executables[ssh]} %s %s" \
	# 		"${host}" "${mk_staging}";
	# 	if ! $noop; then
	# 		( "${executables[ssh]}" "${host}" ""${mk_staging}"" ) \
	# 			|| :tasks.deploy.fail \
	# 			"could not create remote staging directory %s" \
	# 			"${staging}";
	# 	fi
	# fi
	# 
	# local remote="${host}:${staging}/${script_name}";
	# :tasks.deploy.out.info "scp -p %s %s" \
	# 	"${script}" "${remote}";
	# if ! $noop; then
	# 	echo "SCP SCRIPT";
	# fi	
}