# create the deployment bundle
:tasks.bundle.create() {
	# always write the effective settings into the bundle
	:tasks.bundle.settings.write!
	
	#local bundle_parent;
	#fs.dirname "$bundle_output" "bundle_parent";
	
	#echo "got bundle parent : $bundle_parent"; exit 0;
	
	# create the bundle
	{
		cd "$bundle_output" \
			&& tar cf "$bundle_archive" "$bundle_name" \
			&& cd "$project";
	} || :tasks.deploy.fail "failed to create bundle %s" "$bundle_path";
	
	# clean up after bundle creation
	rm -rfv "${bundle_source}" >> "${log}" 2>&1 \
		|| :tasks.deploy.fail "could not clean bundle source %s" "$bundle_path";
		
	:tasks.deploy.out.info "created bundle %s" "$bundle_archive";
	:tasks.deploy.header;
}

# write the deploy settings for the profile to the bundle
:tasks.bundle.settings.write!() {
	json.stringify --pretty 2 <<< "json_dump";
	json.string > "${settings}";
}

# creates a package.json for an *npm* installation type
:tasks.bundle.npm.package.write!() {
	local npm_package_file="${bundle_source}/package.json";
	:tasks.deploy.out.info "npm name %s" "$npm_package_name";
	:tasks.deploy.out.info "npm version %s" "$npm_package_version";
	:tasks.deploy.out.info "npm package %s" "$npm_package_file";
	
	# create the npm package descriptor file
	touch ${npm_package_file} \
 		|| :tasks.deploy.fail "could not create %s" "$npm_package_file";
			
# write out the package descriptor into the bundle source directory
cat <<NPMPKG >> ${npm_package_file}
{
	"name": "${project_name}-${profile}-deploy",
	"version": "0.0.1",	
	"private": "true",
	"dependencies": {
		"$npm_package_name": "${npm_package_version:-*}"
	}
}
NPMPKG
}