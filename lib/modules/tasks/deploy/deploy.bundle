# create the deployment bundle
:tasks.bundle.create() {
	:tasks.deploy.out.info "creating bundle %s" "$bundle_archive";
	
	# always write the effective settings into the bundle
	:tasks.bundle.settings.write!	
	
	# copy the descriptor
	:tasks.bundle.descriptor.copy;
	
	# create the bundle
	:tasks.bundle.archive.create;
	
	# clean up after bundle creation
	rm -rfv "${bundle_source}" >> "${log}" 2>&1 \
		|| :tasks.deploy.fail "could not clean bundle source %s" "$bundle_source";
		
	:tasks.deploy.out.info "created bundle %s" "$bundle_archive";
	:tasks.deploy.header;
}

# copy the descriptor to the bundle source directory
:tasks.bundle.descriptor.copy() {
	cp "${descriptor}" "${bundle_source}/descriptor.json" \
		|| :tasks.deploy.fail "could not copy bundle descriptor %s" "$bundle_path";
}

# create the bundle archive
:tasks.bundle.archive.create() {
	{
		cd "$bundle_output" \
			&& tar -cf "$bundle_archive" "$bundle_name" \
			&& cd "$project";
	} || :tasks.deploy.fail "failed to create bundle %s" "$bundle_path";
}

# write the deploy settings for the profile to the bundle
:tasks.bundle.settings.write!() {
	# TODO: fix json.stringify memory leak
	# TODO: probably due to the string concatenation
	
	# echo "before write json";
	json.stringify --pretty 2 <<< "json_dump";
	json.string > "${settings}";
	# echo "after write json";
}

# creates a package.json for an *npm* installation type
:tasks.bundle.npm.package.write!() {
	local npm_package_file="${bundle_source}/package.json";
	:tasks.deploy.out.info "npm name %s" "$npm_package_name";
	:tasks.deploy.out.info "npm version %s" "$npm_package_version";
	:tasks.deploy.out.info "npm package %s" "$npm_package_file";
	
	# create the npm package descriptor file
	touch ${npm_package_file} \
 		|| :tasks.deploy.fail "could not create %s" "$npm_package_file";
			
# write out the package descriptor into the bundle source directory
cat <<NPMPKG >> ${npm_package_file}
{
	"name": "${project_name}-${profile}-deploy",
	"version": "0.0.1",	
	"private": "true",
	"dependencies": {
		"$npm_package_name": "${npm_package_version:-*}"
	}
}
NPMPKG
}

# perform the bundle installation
:tasks.deploy.bundle.install!() {
	
	# local deployment
	if $deploy_local; then
		:tasks.deploy.out.info "local install %s" "${bundle_archive}";
		# copy packaged bundle to staging
		cp "${bundle_path}" "${staging}" \
			|| :tasks.deploy.fail "could not copy bundle %s" "${bundle_path}";
		cd "${staging}" && tar -xf "${bundle_archive}" \
			|| :tasks.deploy.fail "could not extract bundle %s" "${staging}/${bundle_archive}";
		
		# script_name
		cd "${bundle_name}" \
			|| :tasks.deploy.fail "could not enter %s" "${staging}/${bundle_name}";
			
		# run the script
		if ! $logging; then
			"./${script_name}";
		else
			"./${script_name}" >> "${log}" 2>&1;
		fi
		if [ $? -eq 0 ]; then
			success=true;
			:tasks.deploy.complete;
		fi
		:tasks.deploy.fail;
	# remote deployment
	else
		# TODO: implement
		echo "start remote deployment ... ";
	fi
	
	# local test_staging='test -d '${staging}'; echo $?;';
	# local mk_staging='mkdir -p '${staging}'';
	# 
	# # test if the staging directory exists
	# :tasks.deploy.out.info "${executables[ssh]} %s %s" \
	# 	"${host}" "${test_staging}";
	# local exists=0;
	# if ! $noop; then
	# 	exists=$( "${executables[ssh]}" "${host}" ""${test_staging}"" );
	# fi
	# 
	# # create remote staging directory if it does not exist
	# if [ $exists -gt 0 ]; then
	# 	:tasks.deploy.out.info "${executables[ssh]} %s %s" \
	# 		"${host}" "${mk_staging}";
	# 	if ! $noop; then
	# 		( "${executables[ssh]}" "${host}" ""${mk_staging}"" ) \
	# 			|| :tasks.deploy.fail \
	# 			"could not create remote staging directory %s" \
	# 			"${staging}";
	# 	fi
	# fi
	# 
	# local remote="${host}:${staging}/${script_name}";
	# :tasks.deploy.out.info "scp -p %s %s" \
	# 	"${script}" "${remote}";
	# if ! $noop; then
	# 	echo "SCP SCRIPT";
	# fi	
}