: <<'ronn:markdown'
task-deploy(7) -- deploy task(s) for bake(1)
=============================================

## SYNOPSIS

Deploy task(s) for bake(1).

## DESCRIPTION

Performs a deployment for a project.

## REQUIRE

You do not need to require(3) this task as it is a builtin task.

## USAGE

	bake deploy [options...] [profiles...]
	
## PROFILES

You may specify one or more profiles to deploy after any options. If no profiles are specified then a deploy is attempted using the *default* profile.

## DEFAULT PROFILE

The default profile uses a *git* deployment type and the current branch and git remote URL for deployment on the remote host.

## STRICT

The deployment process is strict. Failure is always assumed and when deploying multiple profiles, failure of a profile to deploy will prevent any subsequent profiles from being processed.

## FILES

A *deploy.json* file must be present in the root of the project and must be valid JSON. This file may just contain '{}' if you wish to use the *default* profile and configure deployment parameters via environment variables.

## ENVIRONMENT

* `bake_deploy_remote`:

The remote host used for deployment when none is specified in *deploy.json*.

* `bake_deploy_shell`:

The shell used on the remote server, defaults to `/bin/sh` if none is specified.

* `bake_deploy_staging`:

The directory used on the remote server for staging deployment scripts, default is `~/.deploy`.

## OPTIONS

* `--staging [path]`:

Sets the path to the staging directory.

* `--local`:

Perform a deployment locally.

* `--json`:

Dump all profile configuration settings that would be used by a deployment as a JSON document. This implies `--noop` and no deployment is performed. This is useful to determine what settings would be used when running a deployment.

* `--noop`:

Print commands but do not execute them.

## NOTIFICATIONS

If the *growlnotify* executable is available then a success or failure notification will be sent using *growlnotify*.

## JSON FORMAT

The format of the *deploy.json* document is described in the task-deploy-json(7) man page, to view this man page run:

	bake help deploy-json

## EXAMPLES

Deploy using the default profile:

	bake deploy
	
Inspect deployment commands with `--noop`:

	bake deploy --noop
	
Deploy the profile *stage*:

	bake deploy stage
		
Deploy the profiles *test*, *stage* and *production*:

	bake deploy test stage production

## BUGS

**task-deploy** is written in bash and depends upon `bash` >= 4.2.

## COPYRIGHT

**task-deploy** is copyright (c) 2012 muji <http://xpm.io>

## SEE ALSO

bake(1), task-deploy-json(7)
ronn:markdown

require.once 'json';
require.once 'git';

# deploy delegate
tasks.deploy() {
	executable.validate scp ssh;

	local deploy_descriptor="${root}/deploy.json";
	if [ ! -f "${deploy_descriptor}" ]; then
		console.quit 1 "no deploy descriptor %s" "${deploy_descriptor}";
	fi	

	executable.validate --test growlnotify;
	
	# non-operation
	local noop=false;

	# valid deployment types
	local types=( git tar );

	:tasks.deploy.parse;
	
	local profiles=();
	
	# determine if we are deploying locally
	local local_deploy=false;
	
	# determines whether we are generating json
	local print_json=false;
	# array used to store properties to be
	# dumped as json
	declare -A json_dump;

	# default to git deployment
	local deploy_type="git";
	local shell=${bake_deploy_shell:-};
	local host="${bake_deploy_remote:-}";
	local staging="${bake_deploy_staging:-~/.deploy}";
	# human readable name using @ delimiter
	local deploy_name="${project_name}@${project_version}";
	# file name using a - delimiter
	local deploy_file_name="${project_name}-${project_version}";
	local script_name="${deploy_file_name}-deploy.sh";
	local script="${target}/${script_name}";
	local log_name="${deploy_file_name}-deploy.log";
	local log_dir="${staging}/log";
	local log_file="${log_dir}/${log_name}";
	local profile="${1:-default}";
	local directory="${2:-~/}";
	local git_remote_url git_branch_current;
	git.remote.url;
	git.branch.current;

	local shell_options=();
	if [ "${shell}" == "bash" ]; then
		shell_options+=( --posix );
	fi

	# validate whitespace on the project name
	:tasks.whitespace.validate "${project_name}" "project name";
	# validate whitespace on the staging property
	:tasks.whitespace.validate "${staging}" "staging";

	# assume failure
	local success=false;

	# messages
	declare -A messages;
	# messages sent via `growlnotify`
	messages[success]="deploy ${deploy_name} complete";
	messages[fail]="deploy ${deploy_name} failed";
	
	# parse options
	:tasks.deploy.options.parse "$@";
	
	# override variables from user defined deploy.json
	:tasks.deploy.json.read;

	# TODO: reinstate this test for each profile
	# verify deployment type is valid
	# if ! array.contains? "${deploy_type:-}" "${types[@]}"; then
	# 	console.quit 1 "invalid deployment type %s" "${deploy_type:-}";
	# fi

	if ! $local_deploy && [ -z "${host}" ]; then
		console.quit 1 "no remote host information available for deploy";
	fi

	local default_profile="default";
	# attempt to deploy the default profile
	if [ ${#profiles[*]} -eq 0 ]; then
		profiles+=( "${default_profile}" "default" );
	fi
	
	:tasks.deploy.profiles.uniq!;
	
	# deploy all profiles
	:tasks.deploy.profiles;

	# show the complete message
	:tasks.deploy.complete;
}

# DEPLOY PRIVATE COMMANDS

# make profile list unique
:tasks.deploy.profiles.uniq!() {
	local IFS=$'\n';
	local lines=( ${profiles[@]} );	
	unset IFS;
	profiles=( $( printf "${lines[@]}" | sort | uniq ) );
}

# deploy a series of profiles
:tasks.deploy.profiles() {
	local profile;
	for profile in "${profiles[@]}"
		do
			if [ "${profile}" != "${default_profile}" ]; then
				if ! :tasks.profile.valid?; then
					console.warn "skipping invalid profile %s" "${profile}";
					continue;
				fi
			fi
			:tasks.deploy.profile;
	done
	# dump json information
	if $print_json; then
		json.stringify <<< "json_dump";
		json.string;
	fi
}

# test whether a profile name is valid
# validity is determined by the existence of a
# host property for the profile
:tasks.profile.valid?() {
	local key="profiles.${profile}.host";
	local value="${json_doc[$key]:-}";
	test -n "${value}";
}

# deploy a single profile
:tasks.deploy.profile() {
	:tasks.deploy.info;
	
	# write the deploy script file
	# :tasks.deploy.script.write!;

	# local debug testing
	# :tasks.script.debug;
	#exit 0;

	# scp the script to the remote server
	# :tasks.deploy.script.push!;
}

# either outputs configuration information
# for the profile being processed or prints
# a json document 
:tasks.deploy.info() {
	local shell_info="${shell:-sh}";
	if $print_json; then
		# variable names to stash for
		# each profile being processed
		local var key vars=(
			deploy_name
			profile
			noop
			shell_info
			script			
			directory			
			staging
			log_file						
			git_remote_url			
			git_branch_current			
			host			
		);
		for var in "${vars[@]}"
			do
				key="${var//_/-}";
				# echo "processing json var $var : $key"
				variable.get "$var";
				# echo "value: $_result";
				json_dump["profiles.${profile}.$key"]="$_result";
		done
	else
		console.info "deploy %s" "${deploy_name}";	
		console.info "profile %s" "${profile}";	
		console.info "noop %s" "${noop}";
		console.info "shell %s" "${shell_info}";
		console.info "script %s" "${script}";
		console.info "remote working directory %s" "${directory}";
		console.info "remote staging directory %s" "${staging}";
		console.info "remote log file %s" "${log_file}";
		console.info "git remote %s" "${git_remote_url}";
		console.info "git branch %s" "${git_branch_current}";
		console.info "host %s" "${host}";
	fi
}

# validate variable value does not contain
# whitespace: space or tab character
:tasks.whitespace.validate() {
	local value="${1:-}";
	local name="${2:-}";
	# staging directory cannot contain whitespace
	# so that we can perform tilde expansion
	local re="[ 	]+";
	if [[ "${value}" =~ $re ]]; then
		console.quit 1 "invalid %s value %s, cannot contain whitespace" \
			"${name}" "${value}";
	fi
}

:tasks.deploy.parse() {
	json.parse < "${deploy_descriptor}";
}

# reads in the json data overrriding
# default values where appropriate
:tasks.deploy.json.read() {
	# always prefer the default host in deploy.json
	if [ -n "${json_doc[host]:-}" ]; then
		host="${json_doc[host]}";
	fi

	# try a host specified in a profile
	if [ -n "${json_doc[profiles.${profile}.host]:-}" ];then
		host="${json_doc[profiles.${profile}.host]}";
	fi

	# lookup any custom working directory
	if [ -n "${json_doc[directory]:-}" ]; then
		directory="${json_doc[directory]}";
	fi

	# try a directory specified in a profile
	if [ -n "${json_doc[profiles.${profile}.directory]:-}" ];then
		directory="${json_doc[profiles.${profile}.directory]}";
	fi

	# lookup any custom deployment type
	if [ -n "${json_doc[type]:-}" ]; then
		deploy_type="${json_doc[type]}";
	fi

	# try a deploy type specified in the profile
	if [ -n "${json_doc[profiles.${profile}.type]:-}" ];then
		deploy_type="${json_doc[profiles.${profile}.type]}";
	fi
}

:tasks.deploy.script.write!() {
	# delete any existing deploy script
	if [ -f "${script}" ]; then
		rm "${script}" \
			|| console.quit 1 "could not delete %s" "${script}";
	fi

	touch "${script}" \
		|| console.quit 1 "could not create %s" "${script}";

	local shebang="#!/bin/sh";
	if [ -n "${shell}" ]; then
		shebang="#!/usr/bin/env ${shell} ${shell_options[@]:-}";
	fi

# write the script file
cat <<EOF >> "${script}"
${shebang}

set +e;

log_dir="${log_dir}"; export log_dir;
log_file="${log_file}"; export log_file;
deploy_log() {
	echo "\$log_dir";
	echo "\$log_file";
	# create the log directory
	if ! test -d $log_dir; then
		printf "creating %s\n" "$log_dir";
		mkdir -p ${log_dir} \
			|| { echo "could not create $log_dir"; exit 1; }
	fi
	if test -f $log_file; then
		rm $log_file \
			|| { echo "could not remove log file $log_file"; exit 1; }
	fi
	# create the log file
	printf "creating %s\n" "$log_file";
	touch $log_file \
		|| { echo "could not create log file $log_file"; exit 1; }
}
deploy() {
	deploy_log;
}
deploy "\$@";
EOF

	chmod +x "${script}" \
		|| console.quit 1 "could not set permissions on %s" "${script}";
}

# runs script locally for debugging
:tasks.script.debug() {
	# output sscipt contents
	cat "${script}";
	# utility to verify the script is not bash only
	checkbashisms "${script}";
	# run script locally
	"${script}";
}

# write the script to the remote server
:tasks.deploy.script.push!() {
	local test_staging='test -d '${staging}'; echo $?;';
	local mk_staging='mkdir -p '${staging}'';

	# test if the staging directory exists
	console.info "${executables[ssh]} %s %s" "${host}" "${test_staging}";
	local exists=0;
	if ! $noop; then
		exists=$( "${executables[ssh]}" "${host}" ""${test_staging}"" );
	fi

	# create remote staging directory if it does not exist
	if [ $exists -gt 0 ]; then
		console.info "${executables[ssh]} %s %s" "${host}" "${mk_staging}";
		if ! $noop; then
			( "${executables[ssh]}" "${host}" ""${mk_staging}"" ) \
				|| :tasks.deploy.fail "could not create remote staging directory %s" \
					"${staging}";
		fi
	fi

	local remote="${host}:${staging}/${script_name}";
	console.info "scp -p %s %s" "${script}" "${remote}";
	if ! $noop; then
		echo "SCP SCRIPT";
	fi	
}

# failure
:tasks.deploy.fail() {
	:tasks.deploy.complete.notify;
	if [ $# -gt 0 ]; then
		console.error "$@";
	fi
	console.quit 1 "deploy %s failed %s" \
			"${deploy_name}" "${characters[cross]}";
}

# attempts to notify via `growlnotify` when available
:tasks.deploy.complete.notify() {
	
	# don't send growl notifications for
	# json dumps or noop
	if $noop; then
		return 0;
	fi
	
	if [ -n "${executables[growlnotify]}" ]; then
		local message;
		local priority="${2:-Normal}";
		if $success; then
			message="${messages[success]}";
		else
			priority="Emergency";
			message="${messages[fail]}";
		fi
		"${executables[growlnotify]}" -m "$message" --priority "$priority";
	fi
}

# output the complete message
:tasks.deploy.complete() {
	
	# noop should always succeed
	if $noop; then
		success=true;
	fi
	
	# output success information
	if $success; then
		:tasks.deploy.complete.notify;
		if $print_json; then
			console.success;
		else
			console.success "deploy %s complete %s" \
				"${deploy_name}" "${characters[tick]}";
		fi
	else
		:tasks.deploy.fail;
	fi
}

# parse options
:tasks.deploy.options.parse() {
	local value;
	while test -n "${1:-}"; do
		case $1 in
			--noop )
				noop=true;
				;;
			--staging )
				shift;
				staging="${1:-}";
				;;
			--local )
				local_deploy=true;
				;;
			--json )
				print_json=true;
				noop=true;
				;;
			* )
				profiles+=( "$1" );
				;;
		esac
		shift;
	done
}