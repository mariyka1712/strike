: <<'ronn:markdown'
task-deploy(7) -- deploy task(s) for bake(1)
=============================================

## SYNOPSIS

Deploy task(s) for bake(1).

## DESCRIPTION

Performs a deployment for a project.

## REQUIRE

You do not need to require(3) this task as it is a builtin task.

## USAGE

	bake deploy [options...] [profiles...]
	
## TYPES

The deploy tasks support the *git* and *tar* deployment types.

### GIT

This deployment type will clone if the deployment directory does not exist and fetch the specified branch from the remote repository.

### TAR

This deployment type will fetch a tarball from a filesystem path or remote URL and extract the contents to the target directory.
	
## PROFILES

You may specify one or more profiles to deploy after any options. If no profiles are specified then a deploy is attempted using the *default* profile.

Note that a profile must declare at a minimum the *type* property for it to be recognised, for example the following is invalid:

	{
		"profiles": {
			"stage": {}
		}
	}
	
Therefore the profile will not be available. You `must` specify at least the profile *type*:

	{
		"profiles": {
			"stage": {
				"type": "git"
			}
		}
	}

## DEFAULT PROFILE

The default profile uses a *git* deployment type and the current branch and git remote URL for deployment on the remote host.

## PROFILE NAMES

Profile names may not start with a hyphen and should match the pattern ^[-a-zA-Z0-9]+.

## STRICT

The deployment process is strict. Failure is always assumed and when deploying multiple profiles, failure of a profile to deploy will prevent any subsequent profiles from being processed.

## FILES

A *deploy.json* file must be present in the root of the project and must be valid JSON. This file may just contain '{}' if you wish to use the *default* profile and configure deployment parameters via environment variables.

## ENVIRONMENT

* `bake_deploy_remote`:

The remote host used for deployment when none is specified in *deploy.json*.

* `bake_deploy_shell`:

The shell used on the remote server, defaults to `/bin/sh` if none is specified.

* `bake_deploy_staging`:

The directory used on the remote server for staging deployment scripts, default is `~/.deploy`.

## OPTIONS

* `--directory [directory]`:

The deployment directory. When this option is specified it overrides any directory values specified in *deploy.json* for *all* profiles.

* `--descriptor [file]`:

Sets the *deploy.json* descriptor to use for this deployment.

* `--staging [directory]`:

Sets the path to the staging directory.

* `--local`:

Perform a deployment locally.

* `--json`:

Dump all profile configuration settings that would be used by a deployment as a JSON document. This implies `--noop` and no deployment is performed. This is useful to determine what settings would be used when running a deployment.

* `--pretty`:

Use in conjunction with the `--json` option to pretty print the JSON document.

* `--noop`:

Print commands but do not execute them.

## NOTIFICATIONS

If the *growlnotify* executable is available then a success or failure notification will be sent using *growlnotify*.

## JSON FORMAT

The format of the *deploy.json* document is described in the task-deploy-json(7) man page, to view this man page run:

	bake help deploy-json

## EXAMPLES

Deploy using the default profile:

	bake deploy
	
Inspect deployment commands with `--noop`:

	bake deploy --noop
	
Deploy the profile *stage*:

	bake deploy stage
		
Deploy the profiles *test*, *stage* and *production*:

	bake deploy test stage production

## BUGS

**task-deploy** is written in bash and depends upon `bash` >= 4.2.

## COPYRIGHT

**task-deploy** is copyright (c) 2012 muji <http://xpm.io>

## SEE ALSO

bake(1), task-deploy-json(7)
ronn:markdown

require.once 'json';
require.once 'git';

# deploy delegate
tasks.deploy() {
	executable.validate scp ssh;

	local descriptor="${root}/deploy.json";

	executable.validate --test growlnotify;
	
	# non-operation
	local noop=false;

	# valid deployment types
	local types=( git tar );

	:tasks.deploy.parse;
	
	local profiles=();
	
	# determine if we are deploying locally
	local deploy_local=false;

	# default to git deployment
	local deploy_type="git";
	local profile="default";
	local shell="${bake_deploy_shell:-}";
	local host="${bake_deploy_remote:-}";
	local staging="${bake_deploy_staging:-~/.deploy}";
	# human readable name using @ delimiter
	local deploy_name="${project_name}@${project_version}";
	# file name using a - delimiter	
	local deploy_file_name="${project_name}-${project_version}";
	local script_name="${deploy_file_name}-${profile}.sh";
	local script="${target}/${script_name}";
	local log_name="${deploy_file_name}-${profile}.log";
	local log_dir="${staging}/log";
	local log_file="${log_dir}/${log_name}";
	local directory="${2:-~/}";
	local git_remote_url git_branch;
	git.remote.url;
	git.branch.current "git_branch";
	
	# JSON PROPERTIES
	# determines whether we are generating json
	local print_json=false;
	local pretty=false;
	# array used to store properties to be
	# dumped as json
	declare -A json_dump;
	json_dump["project-version"]="${project_version}";

	# SHELL PROPERTIES
	local shell_options=();
	if [ "${shell}" == "bash" ]; then
		shell_options+=( --posix );
	fi

	# validate whitespace on the project name
	:tasks.whitespace.validate "${project_name}" "project name";
	# validate whitespace on the staging property
	:tasks.whitespace.validate "${staging}" "staging";

	# assume failure
	local success=false;

	# messages
	declare -A messages;
	# messages sent via `growlnotify`
	messages[success]="deploy ${deploy_name} complete";
	messages[fail]="deploy ${deploy_name} failed";
	
	
	# override default settings from user defined deploy.json
	:tasks.deploy.json.read;	
	
	# parse options
	:tasks.deploy.options.parse "$@";
	
	# validate the descriptor after option parsing
	:tasks.deploy.descriptor.validate;	

	# TODO: reinstate this test for each profile
	# verify deployment type is valid
	# if ! array.contains? "${deploy_type:-}" "${types[@]}"; then
	# 	console.quit 1 "invalid deployment type %s" "${deploy_type:-}";
	# fi

	if ! $deploy_local && [ -z "${host}" ]; then
		console.quit 1 "no remote host information available for deploy";
	fi

	local default_profile="default";
	# attempt to deploy the default profile
	if [ ${#profiles[*]} -eq 0 ]; then
		profiles+=( "${default_profile}" );
	fi
	
	:tasks.deploy.profiles.uniq!;
	
	# update some json dump properties after option parsing
	json_dump["project-name"]="${project_name}";	
	json_dump["descriptor"]="${descriptor}";
	json_dump["noop"]="${noop}";
	json_dump["local"]="${deploy_local}";
	local i;
	for i in ${!profiles[@]}
		do
			json_dump["targets.$i"]="${profiles[$i]}";
	done
	
	# deploy all profiles
	:tasks.deploy.profiles;

	# show the complete message
	:tasks.deploy.complete;
}

# DEPLOY PRIVATE COMMANDS

# validate a descriptor file
:tasks.deploy.descriptor.validate() {
	if [[ ! "${descriptor}" =~ \.json$ ]]; then
		console.quit 1 "descriptor %s does not have a .json file extension" \
			"${descriptor}";
	fi
	if [ ! -f "${descriptor}" ]; then
		console.quit 1 "no deploy descriptor %s" "${descriptor}";
	fi
}

# make profile list unique
:tasks.deploy.profiles.uniq!() {
	local IFS=$'\n';
	local lines=( ${profiles[*]} );
	unset IFS;
	profiles=( $( printf "${lines[*]}" | sort | uniq ) );
}

# deploy a series of profiles
:tasks.deploy.profiles() {
	local profile;
	for profile in "${profiles[@]}"
		do
			if [ "${profile}" != "${default_profile}" ]; then
				if ! :tasks.profile.valid?; then
					console.warn "profile %s does not exist" "${profile}";
					continue;
				fi
			fi
			:tasks.deploy.profile;
	done
	# dump json information
	if $print_json; then
		if ! $pretty; then
			json.stringify <<< "json_dump";
		else
			json.stringify --pretty 2 <<< "json_dump";
		fi
		json.string;
		printf "\n";
	fi
}

# test whether a profile name is valid
# validity is determined by the existence of a
# host property for the profile
:tasks.profile.valid?() {
	local key="profiles.${profile}.type";
	local value="${json_doc[$key]:-}";
	test -n "${value}";
}

# deploy a single profile
:tasks.deploy.profile() {
	local deploy_target="${directory}/${project_name}";	
	
	:tasks.deploy.info;
	
	# write the deploy script file
	# :tasks.deploy.script.write!;

	# local debug testing
	# :tasks.script.debug;
	#exit 0;

	# scp the script to the remote server
	# :tasks.deploy.script.push!;
}

# either outputs configuration information
# for the profile being processed or prints
# a json document 
:tasks.deploy.info() {
	
	local shell_info="${shell:-sh}";
	if $print_json; then
		# variable names to stash for
		# each profile being processed
		local var key vars=(
			deploy_name
			deploy_file_name
			deploy_type
			deploy_target
			shell_info
			script			
			directory			
			staging
			log_file
			log_dir								
			git_remote_url			
			git_branch			
			host			
		);
		for var in "${vars[@]}"
			do
				# replace first underscore with a dot to group
				# as object on variable names with the same prefix
				key="${var/_/.}";
				key="${key//_/-}";
				# echo "processing json var $var : $key"
				variable.get "$var";
				# echo "value: $_result";
				json_dump["profiles.${profile}.$key"]="$_result";
		done
	else
		console.info "deploy %s" "${deploy_name}";	
		console.info "profile %s" "${profile}";	
		console.info "noop %s" "${noop}";
		console.info "shell %s" "${shell_info}";
		console.info "script %s" "${script}";
		console.info "remote working directory %s" "${directory}";
		console.info "remote staging directory %s" "${staging}";
		console.info "remote log file %s" "${log_file}";
		console.info "git remote %s" "${git_remote_url}";
		console.info "git branch %s" "${git_branch}";
		console.info "host %s" "${host}";
	fi
}

# validate variable value does not contain
# whitespace: space or tab character
:tasks.whitespace.validate() {
	local value="${1:-}";
	local name="${2:-}";
	# staging directory cannot contain whitespace
	# so that we can perform tilde expansion
	local re="[ 	]+";
	if [[ "${value}" =~ $re ]]; then
		console.quit 1 "invalid %s value %s, cannot contain whitespace" \
			"${name}" "${value}";
	fi
}

:tasks.deploy.parse() {
	json.parse < "${descriptor}";
}

# reads in the json data overrriding
# default values where appropriate
:tasks.deploy.json.read() {
	# always prefer the default host in deploy.json
	if [ -n "${json_doc[host]:-}" ]; then
		host="${json_doc[host]}";
	fi

	# try a host specified in a profile
	if [ -n "${json_doc[profiles.${profile}.host]:-}" ];then
		host="${json_doc[profiles.${profile}.host]}";
	fi

	# lookup any custom working directory
	if [ -n "${json_doc[directory]:-}" ]; then
		directory="${json_doc[directory]}";
	fi

	# try a directory specified in a profile
	if [ -n "${json_doc[profiles.${profile}.directory]:-}" ];then
		directory="${json_doc[profiles.${profile}.directory]}";
	fi

	# lookup any custom deployment type
	if [ -n "${json_doc[type]:-}" ]; then
		deploy_type="${json_doc[type]}";
	fi

	# try a deploy type specified in the profile
	if [ -n "${json_doc[profiles.${profile}.type]:-}" ];then
		deploy_type="${json_doc[profiles.${profile}.type]}";
	fi
}

:tasks.deploy.script.write!() {
	# delete any existing deploy script
	if [ -f "${script}" ]; then
		rm "${script}" \
			|| console.quit 1 "could not delete %s" "${script}";
	fi

	touch "${script}" \
		|| console.quit 1 "could not create %s" "${script}";

	local shebang="#!/bin/sh";
	if [ -n "${shell}" ]; then
		shebang="#!/usr/bin/env ${shell} ${shell_options[@]:-}";
	fi

# write the script file
cat <<EOF >> "${script}"
${shebang}

set +e;

log_dir="${log_dir}"; export log_dir;
log_file="${log_file}"; export log_file;
deploy_log() {
	echo "\$log_dir";
	echo "\$log_file";
	# create the log directory
	if ! test -d $log_dir; then
		printf "creating %s\n" "$log_dir";
		mkdir -p ${log_dir} \
			|| { echo "could not create $log_dir"; exit 1; }
	fi
	if test -f $log_file; then
		rm $log_file \
			|| { echo "could not remove log file $log_file"; exit 1; }
	fi
	# create the log file
	printf "creating %s\n" "$log_file";
	touch $log_file \
		|| { echo "could not create log file $log_file"; exit 1; }
}
deploy() {
	deploy_log;
}
deploy "\$@";
EOF

	chmod +x "${script}" \
		|| console.quit 1 "could not set permissions on %s" "${script}";
}

# runs script locally for debugging
:tasks.script.debug() {
	# output sscipt contents
	cat "${script}";
	# utility to verify the script is not bash only
	checkbashisms "${script}";
	# run script locally
	"${script}";
}

# write the script to the remote server
:tasks.deploy.script.push!() {
	local test_staging='test -d '${staging}'; echo $?;';
	local mk_staging='mkdir -p '${staging}'';

	# test if the staging directory exists
	console.info "${executables[ssh]} %s %s" "${host}" "${test_staging}";
	local exists=0;
	if ! $noop; then
		exists=$( "${executables[ssh]}" "${host}" ""${test_staging}"" );
	fi

	# create remote staging directory if it does not exist
	if [ $exists -gt 0 ]; then
		console.info "${executables[ssh]} %s %s" "${host}" "${mk_staging}";
		if ! $noop; then
			( "${executables[ssh]}" "${host}" ""${mk_staging}"" ) \
				|| :tasks.deploy.fail "could not create remote staging directory %s" \
					"${staging}";
		fi
	fi

	local remote="${host}:${staging}/${script_name}";
	console.info "scp -p %s %s" "${script}" "${remote}";
	if ! $noop; then
		echo "SCP SCRIPT";
	fi	
}

# failure
:tasks.deploy.fail() {
	:tasks.deploy.complete.notify;
	if [ $# -gt 0 ]; then
		console.error "$@";
	fi
	console.quit 1 "deploy %s failed %s" \
			"${deploy_name}" "${characters[cross]}";
}

# attempts to notify via `growlnotify` when available
:tasks.deploy.complete.notify() {
	
	# don't send growl notifications for
	# json dumps or noop
	if $noop; then
		return 0;
	fi
	
	if [ -n "${executables[growlnotify]}" ]; then
		local message;
		local priority="${2:-Normal}";
		if $success; then
			message="${messages[success]}";
		else
			priority="Emergency";
			message="${messages[fail]}";
		fi
		"${executables[growlnotify]}" -m "$message" --priority "$priority";
	fi
}

# output the complete message
:tasks.deploy.complete() {
	
	# noop should always succeed
	if $noop; then
		success=true;
	fi
	
	# output success information
	if $success; then
		:tasks.deploy.complete.notify;
		if $print_json; then
			console.success;
		else
			console.success "deploy %s complete %s" \
				"${deploy_name}" "${characters[tick]}";
		fi
	else
		:tasks.deploy.fail;
	fi
}

# parse options
:tasks.deploy.options.parse() {
	local value re="^[-a-zA-Z0-9]+$";
	while test -n "${1:-}"; do
		case $1 in
			--noop )
				noop=true;
				;;
			--staging )
				shift;
				staging="${1:-}";
				;;
			--local )
				deploy_local=true;
				;;
			--json )
				print_json=true;
				noop=true;
				;;
			--pretty )
				pretty=true;
				;;
			--name )
				shift;
				value="${1:-}";
				if [ -z "${value}" ]; then
					console.quit 1 "no name specified";
				fi
				if [[ ! "$value" =~ $re ]]; then
					console.quit 1 "invalid project name %s must match %s" "$value" "$re";
				fi
				project_name="${value}";
				;;
			--directory )
				shift;
				value="${1:-}";
				if [ -z "${value}" ]; then
					console.quit 1 "no directory specified";
				fi
				directory="${value}";
				;;
			--descriptor )
				shift;
				value="${1:-}";
				if [ -z "${value}" ]; then
					console.quit 1 "no descriptor specified";
				fi
				descriptor="${value}";		
				;;
			-* | --* )
				console.quit 1 "invalid option %s" "$1";
				;;
			* )
				if [[ ! "$1" =~ $re ]]; then
					console.quit 1 "invalid profile name %s must match %s" "$1" "$re";
				fi
				profiles+=( "$1" );
				;;
		esac
		shift;
	done
}