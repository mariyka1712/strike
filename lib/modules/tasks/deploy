: <<'ronn:markdown'
task-deploy(7) -- deploy task(s) for bake(1)
=============================================

## SYNOPSIS

Deploy task(s) for bake(1).

## DESCRIPTION

Performs a deployment for a project.

## REQUIRE

You do not need to require(3) this task as it is a builtin task.

## USAGE

	bake deploy

## ENVIRONMENT

* `bake_deploy_remote`:

The remote host used for deployment when none is specified in *deploy.json*.

* `bake_deploy_shell`:

The shell used on the remote server, defaults to `bash` if none is specified.

* `bake_deploy_staging`:

The directory used on the remote server for staging deployment scripts, default is `~/.deploy`.

## BUGS

**task-deploy** is written in bash and depends upon `bash` >= 4.2.

## COPYRIGHT

**task-deploy** is copyright (c) 2012 muji <http://xpm.io>

## SEE ALSO

bake(1)
ronn:markdown

require.once 'json';
require.once 'git';

# deploy delegate
tasks.deploy() {
	executable.validate scp ssh;

	local deploy_descriptor="${root}/deploy.json";

	executable.validate --test growlnotify;

	# valid deployment types
	local types=( git tar );

	:tasks.deploy.parse;

	# default to git deployment
	local deploy_type="git";
	local shell=${bake_deploy_shell:-};
	local host="${bake_deploy_remote:-}";
	local staging="${bake_deploy_staging:-~/.deploy}";
	# human readable name using @ delimiter
	local deploy_name="${project_name}@${project_version}";
	# file name using a - delimiter
	local deploy_file_name="${project_name}-${project_version}";
	local script_name="${deploy_file_name}-deploy.sh";
	local script="${target}/${script_name}";
	local log_name="${deploy_file_name}-deploy.log";
	local log_dir="${staging}/log";
	local log_file="${log_dir}/${log_name}";
	local profile="${1:-default}";
	local directory="${2:-~/}";
	local git_remote_url git_branch_current;
	git.remote.url;
	git.branch.current;

	local shell_options=();
	if [ "${shell}" == "bash" ]; then
		shell_options+=( --posix );
	fi

	# validate whitespace on the project name
	:tasks.whitepace.validate "${project_name}" "project name";
	# validate whitespace on the staging property
	:tasks.whitespace.validate "${staging}" "staging";

	# override variables from user defined deploy.json
	:tasks.deploy.json.read;

	# verify deployment type is valid
	if ! array.contains? "${deploy_type:-}" "${types[@]}"; then
		console.quit 1 "invalid deployment type %s" "${deploy_type:-}";
	fi

	if [ -z "${host}" ]; then
		console.quit 1 "no remote host information available for deploy";
	fi

	# assume failure
	local success=false;

	# messages
	declare -A messages;
	# messages sent via `growlnotify`
	messages[success]="deploy ${deploy_name} complete";
	messages[fail]="deploy ${deploy_name} failed";

	console.info "deploy %s" "${project_name}@${project_version}";
	console.info "shell %s" "${shell}";
	console.info "script %s" "${script}";
	console.info "profile %s" "${profile}";
	console.info "remote working directory %s" "${directory}";
	console.info "remote staging directory %s" "${staging}";
	console.info "remote log file %s" "${log_file}";
	console.info "git remote %s" "${git_remote_url}";
	console.info "git branch %s" "${git_branch_current}";
	console.info "host %s" "${host}";

	# write the deploy script file
	:tasks.deploy.script.write!;

	# local debug testing
	:tasks.script.debug;
	#exit 0;

	# scp the script to the remote server
	:tasks.deploy.script.push!;

	# show the complete message
	:tasks.deploy.complete;
}

# DEPLOY PRIVATE COMMANDS

# validate variable value does not contain
# whitespace: space or tab character
:tasks.whitespace.validate() {
	local value="${1:-}";
	local name="${2:-}";
	# staging directory cannot contain whitespace
	# so that we can perform tilde expansion
	local re="[ 	]+";
	if [[ "${value}" =~ $re ]]; then
		console.quit 1 "invalid %s value %s, cannot contain whitespace" \
			"${name}" "${value}";
	fi
}

:tasks.deploy.parse() {
	if [ ! -f "${deploy_descriptor}" ]; then
		console.quit 1 "no deploy descriptor %s" "${deploy_descriptor}";
	fi

	json.parse < "${deploy_descriptor}";
}

# reads in the json data overrriding
# default values where appropriate
:tasks.deploy.json.read() {
	# always prefer the default host in deploy.json
	if [ -n "${json_doc[host]:-}" ]; then
		host="${json_doc[host]}";
	fi

	# try a host specified in a profile
	if [ -n "${json_doc[profiles.${profile}.host]:-}" ];then
		host="${json_doc[profiles.${profile}.host]}";
	fi

	# lookup any custom working directory
	if [ -n "${json_doc[directory]:-}" ]; then
		directory="${json_doc[directory]}";
	fi

	# try a directory specified in a profile
	if [ -n "${json_doc[profiles.${profile}.directory]:-}" ];then
		directory="${json_doc[profiles.${profile}.directory]}";
	fi

	# lookup any custom deployment type
	if [ -n "${json_doc[type]:-}" ]; then
		deploy_type="${json_doc[type]}";
	fi

	# try a deploy type specified in the profile
	if [ -n "${json_doc[profiles.${profile}.type]:-}" ];then
		deploy_type="${json_doc[profiles.${profile}.type]}";
	fi
}

:tasks.deploy.script.write!() {
	# delete any existing deploy script
	if [ -f "${script}" ]; then
		rm "${script}" \
			|| console.quit 1 "could not delete %s" "${script}";
	fi

	touch "${script}" \
		|| console.quit 1 "could not create %s" "${script}";

	local shebang="#!/bin/sh";
	if [ -n "${shell}" ]; then
		shebang="#!/usr/bin/env ${shell} ${shell_options[@]:-}";
	fi

# write the script file
cat <<EOF >> "${script}"
${shebang}

set +e;

log_dir="${log_dir}"; export log_dir;
log_file="${log_file}"; export log_file;
deploy_log() {
	echo "\$log_dir";
	echo "\$log_file";
	# create the log directory
	if ! test -d $log_dir; then
		printf "creating %s\n" "$log_dir";
		mkdir -p ${log_dir} \
			|| { echo "could not create $log_dir"; exit 1; }
	fi
	if test -f $log_file; then
		rm $log_file \
			|| { echo "could not remove log file $log_file"; exit 1; }
	fi
	# create the log file
	printf "creating %s\n" "$log_file";
	touch $log_file \
		|| { echo "could not create log file $log_file"; exit 1; }
}
deploy() {
	deploy_log;
}
deploy "\$@";
EOF

	chmod +x "${script}" \
		|| console.quit 1 "could not set permissions on %s" "${script}";
}

# runs script locally for debugging
:tasks.script.debug() {
	# output sscipt contents
	cat "${script}";
	# utility to verify the script is not bash only
	checkbashisms "${script}";
	# run script locally
	"${script}";
}

# write the script to the remote server
:tasks.deploy.script.push!() {
	local test_staging='test -d '${staging}'; echo $?;';
	local mk_staging='mkdir -p '${staging}'';

	# test if the staging directory exists
	console.info "${executables[ssh]} %s %s" "${host}" "${test_staging}";
	local exists=$( "${executables[ssh]}" "${host}" ""${test_staging}"" );

	# create remote staging directory if it does not exist
	if [ $exists -gt 0 ]; then
		console.info "${executables[ssh]} %s %s" "${host}" "${mk_staging}";
		( "${executables[ssh]}" "${host}" ""${mk_staging}"" ) \
			|| :tasks.deploy.fail "could not create remote staging directory %s" \
				"${staging}";
	fi

	local remote="${host}:${staging}/${script_name}";
	console.info "scp -p %s %s" "${script}" "${remote}";
}

# failure
:tasks.deploy.fail() {
	:tasks.deploy.complete.notify;
	if [ $# -gt 0 ]; then
		console.error "$@";
	fi
	console.quit 1 "deploy %s failed %s" \
			"${deploy_name}" "${characters[cross]}";
}

# attempts to notify via `growlnotify` when available
:tasks.deploy.complete.notify() {
	if [ -n "${executables[growlnotify]}" ]; then
		local message;
		local priority="${2:-Normal}";
		if $success; then
			message="${messages[success]}";
		else
			priority="Emergency";
			message="${messages[fail]}";
		fi
		"${executables[growlnotify]}" -m "$message" --priority "$priority";
	fi
}

# output the complete message
:tasks.deploy.complete() {
	if $success; then
		:tasks.deploy.complete.notify;
		console.success "deploy %s complete %s" \
			"${deploy_name}" "${characters[tick]}";
	else
		:tasks.deploy.fail;
	fi
}
