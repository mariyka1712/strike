: <<'ronn:markdown'
task-deploy(7) -- deploy task(s) for bake(1)
=============================================

## SYNOPSIS

Deploy task(s) for bake(1).

## DESCRIPTION

Performs a deployment for a project.

## REQUIRE

You do not need to require(3) this task as it is a builtin task.

## USAGE

	bake deploy [options...] [profiles...]
	
## TYPES

The deploy tasks support the *git* and *tar* deployment types.

### GIT

This deployment type will clone if the deployment directory does not exist and fetch the specified branch from the remote repository.

### TAR

This deployment type will fetch a tarball from a filesystem path or remote URL and extract the contents to the target directory.

## JSON FORMAT

The format of the *deploy.json* descriptor is described in the task-deploy-json(7) man page, to view this man page run:

	bake help deploy-json
	
## TARGET

The final deploy target is a combination of the *directory*, *name* and *profile* by default. Assuming a *directory* of `~/www` and the project name `project` with a deployment profile of `stage` the target used for deployment is:

	~/www/project/stage
	
If you do not wish to include the profile name in the target directory specify the `--flat` option which results in:

	~/www/project
	
It depends upon your deployment requirements as to which strategy you wish to use. Generally, if you are deploying to the same host then it makes sense to separate the deployment profiles, whereas if each deployment profile is using a different host then it is more consistent to have the same directory structure across the different hosts.

You may also create separate deployment targets based on the project version using the `--include-version` option. Continuing the above example with a version of `0.0.1` and the default behaviour (no `--flat` option specified) then the target becomes:

	~/www/project-0.0.1/stage
	
Or alternatively in conjunction with the `--flat` option the target directory becomes:

	~/www/project-0.0.1
	
## PROFILES

You may specify one or more profiles to deploy after any options. If no profiles are specified then a deploy is attempted using the *default* profile.

Note that a profile must declare at a minimum the *type* property for it to be recognised, for example the following is invalid:

	{
		"profiles": {
			"stage": {}
		}
	}
	
Therefore the profile will not be available. You `must` specify at least the deployment *type*:

	{
		"profiles": {
			"stage": {
				"type": "git"
			}
		}
	}

## DEFAULT PROFILE

The default profile uses a *git* deployment type and the current branch and git remote URL for deployment to the target host.

## NAMES

Profile and project names may not start with a hyphen and should match the pattern ^[-a-zA-Z0-9]+.

## STRICT

The deployment process is strict. Failure is always assumed and when deploying multiple profiles, failure of a profile to deploy will prevent any subsequent profiles from being processed.

## FILES

A *deploy.json* file must be present in the root of the project and must be valid JSON. This file may just contain '{}' if you wish to use the *default* profile and configure deployment parameters via environment variables or command line options.

## ENVIRONMENT

* `bake_deploy_remote`:

The remote host used for deployment when none is specified in *deploy.json*.

* `bake_deploy_shell`:

The shell used on the remote server, defaults to `/bin/sh` if none is specified.

* `bake_deploy_staging`:

The directory used on the remote server for staging deployment scripts, default is `~/.deploy`.

## OPTIONS

* `--directory [directory]`:

The deployment directory. When this option is specified it overrides any directory values specified in *deploy.json* for all profiles.

* `--host [user@host]`:

The scp(1) and ssh(1) *user@host* specification. When this option is specified it overrides any host properties in *deploy.json*. This is useful if you wish to deploy everything using the profile(s) in *deploy.json* to a different host.

* `--descriptor [file]`:

Use *file* as the deployment descriptor.

* `--staging [directory]`:

Use *directory* as the staging directory.

* `--shell [shell]`:

Use *shell* for the script shebang. Must be one of *sh*, *bash*, *zsh* or *dash*.

* `--log`:

Redirect *stdout* message to `target/deploy.log`. Note that when using with the `--json` option that the JSON document is always sent to *stdout*.

* `--flat`:

Do not include the profile name in the deployment target directory.

* `--include-version`:

Include version information in the target directory.

* `--local`:

Perform a deployment locally.

* `--json`:

Dump all profile configuration settings that would be used by a deployment as a JSON document. This implies `--noop` and no deployment is performed. This is useful to determine the settings that would be used when running a deployment.

If this option is used in conjunction with `--script` the last option will take preference.

* `--pretty`:

Use in conjunction with the `--json` option to pretty print the JSON document.

* `--script`:

Dump script(s) to *stdout*, implies `--noop`. If this option is used in conjunction with `--json` the last option will take preference.

* `--noop`:

Print commands but do not execute them.

## NOTIFICATIONS

If the *growlnotify* executable is available then a success or failure notification will be sent using *growlnotify*. Note that *growlnotify* notifications are not sent when the `--json` or `--noop` options are specified.

## FILES

When the `--log` option is specified *stdout* is redirected to `target/deploy.log`.

The script file is written to `target` using the following naming strategy:

	${name}-${version}-${profile}.sh

## EXIT CODES

A >0 exit code indicates failure while a 0 exit code indicates success.

## EXAMPLES

Deploy using the default profile:

	bake deploy
	
Deploy using the default profile locally:

	bake deploy --local
	
Inspect deployment commands:

	bake deploy --noop
	
Deploy the profile *stage*:

	bake deploy stage
		
Deploy the profiles *test*, *stage* and *production*:

	bake deploy test stage production
	
Inspect the settings used for a *default* deployment:

	bake deploy --json --pretty \\
		--staging ~/project-staging \\
		--name project \\
		--directory ~/www

## BUGS

**task-deploy** is written in bash and depends upon `bash` >= 4.2.

## COPYRIGHT

**task-deploy** is copyright (c) 2012 muji <http://xpm.io>

## SEE ALSO

bake(1), task-deploy-json(7)
ronn:markdown

require.once 'json';
require.once 'git';

# deploy delegate
tasks.deploy() {
	executable.validate scp ssh;

	local descriptor="${root}/deploy.json";

	executable.validate --test growlnotify;
	
	# name validation regex
	local re="^[-a-zA-Z0-9]+$";
	
	local log="${target}/deploy.log";
	local logging=false;
	
	# non-operation
	local noop=false;

	# valid deployment types
	local types=( git tar );
	
	local profiles=();
	
	# determine if we are deploying locally
	local deploy_local=false;
	
	# include version information in the target
	local deploy_version=false;
	
	# dump script contents to stdout
	local dump_script=false;

	# strategy used to determine the target
	# directory. the default is to include
	# the profile name in the target directory
	# structure
	local flat=false;
	
	# command line options that override
	# properties set in deploy.json
	declare -A overrides;
	
	# list of supported shells
	local shells=( sh bash zsh dash );

	# default to git deployment
	local deploy_type="git";
	local profile="default";
	local directory="";
	local shell="${bake_deploy_shell:-sh}";
	local host="${bake_deploy_remote:-}";
	local staging="${bake_deploy_staging:-~/.deploy}";
	local git_url git_branch;
	git.remote.url "git_url";
	git.branch.current "git_branch";
	
	# JSON PROPERTIES
	# determines whether we are generating json
	local dump_json=false;
	local pretty=false;
	# array used to store properties to be
	# dumped as json
	declare -A json_dump;
	json_dump["project-version"]="${project_version}";

	# assume failure
	local success=false;
	
	# parse options
	:tasks.deploy.options.parse "$@";
	
	# human readable name using @ delimiter
	# must be set after option parsing in case a --name
	# option has been specified
	local deploy_name="${project_name}@${project_version}";
	# file name using a - delimiter	
	local deploy_file_name="${project_name}-${project_version}";
	local script_name="${deploy_file_name}-${profile}.sh";
	local script="${target}/${script_name}";
	local log_name="${deploy_file_name}-${profile}.log";
	local log_dir="${staging}/log";
	local log_file="${log_dir}/${log_name}";	
	
	# validate the descriptor after option parsing
	:tasks.deploy.descriptor.validate;	

	# TODO: reinstate this test for each profile
	# verify deployment type is valid
	# if ! array.contains? "${deploy_type:-}" "${types[@]}"; then
	# 	console.quit 1 "invalid deployment type %s" "${deploy_type:-}";
	# fi

	local default_profile="default";
	# attempt to deploy the default profile
	if [ ${#profiles[*]} -eq 0 ]; then
		profiles+=( "${default_profile}" );
	fi
	
	:tasks.deploy.profiles.uniq!;
	
	:tasks.deploy.parse;	
	
	# update some json dump properties after option parsing
	json_dump["project-name"]="${project_name}";	
	json_dump["descriptor"]="${descriptor}";
	json_dump["noop"]="${noop}";
	json_dump["local"]="${deploy_local}";
	local i;
	for i in ${!profiles[@]}
		do
			json_dump["targets.$i"]="${profiles[$i]}";
	done
	
	# messages
	declare -A messages;
	# messages sent via `growlnotify`
	messages[success]="deploy ${deploy_name} complete";
	messages[fail]="deploy ${deploy_name} failed";	
	
	# validate whitespace on the project name
	:tasks.deploy.whitespace.validate "${project_name}" "project name";
	# validate whitespace on the staging property
	:tasks.deploy.whitespace.validate "${staging}" "staging";
	
	# validate the shell in use
	if ! array.contains? "$shell" "${shells[@]}"; then
		console.quit 1 "shell %s is not supported" "$shell";
	fi
	
	# configure the shebang
	local shebang="#!/bin/sh";
	if [ "${shell}" != "sh" ]; then
		shebang="#!/usr/bin/env ${shell}";
	fi
	
	# deploy all profiles
	:tasks.deploy.profiles;

	# show the complete message
	:tasks.deploy.complete;
}

# DEPLOY PRIVATE COMMANDS

# validate a descriptor file
:tasks.deploy.descriptor.validate() {
	if [[ ! "${descriptor}" =~ \.json$ ]]; then
		console.quit 1 "descriptor %s does not have a .json file extension" \
			"${descriptor}";
	fi
	if [ ! -f "${descriptor}" ]; then
		console.quit 1 "no deploy descriptor %s" "${descriptor}";
	fi
}

# make profile list unique
:tasks.deploy.profiles.uniq!() {
	local IFS=$'\n';
	local lines=( ${profiles[*]} );
	unset IFS;
	profiles=( $( printf "${lines[*]}" | sort | uniq ) );
}

# deploy a series of profiles
:tasks.deploy.profiles() {
	local profile;
	for profile in "${profiles[@]}"
		do
			if [ "${profile}" != "${default_profile}" ]; then
				if ! :tasks.profile.valid?; then
					console.warn "profile %s does not exist" "${profile}";
					continue;
				fi
			fi
			# quit on invalid profile name in the deploy descriptor
			if ! :tasks.name.valid? "${profile}"; then
				:tasks.name.quit "profile" "$1";
			fi
			:tasks.deploy.profile;
	done
	# dump json information
	if $dump_json; then
		if ! $pretty; then
			json.stringify <<< "json_dump";
		else
			json.stringify --pretty 2 <<< "json_dump";
		fi
		json.string;
		printf "\n";
	fi
}

# test whether a profile name is valid
# validity is determined by the existence of a
# host property for the profile
:tasks.profile.valid?() {
	local key="profiles.${profile}.type";
	local value="${json_doc[$key]:-}";
	test -n "${value}";
}

# deploy a single profile
:tasks.deploy.profile() {
	# override default settings from user defined deploy.json
	:tasks.deploy.json.read;
	
	local start_time=$( date )
	
	:tasks.deploy.out.info "%s" "${start_time}";
	
	
	# commands to execute on local and remote
	declare -A local_commands;
	declare -A remote_commands;
		
	local script_name="${deploy_file_name}-${profile}.sh";
	local script="${target}/${script_name}";
	local log_name="${deploy_file_name}-${profile}.log";
	local log_dir="${staging}/log";
	local log_file="${log_dir}/${log_name}";
	
	# TODO: allow for the version to be included in the target directory
	local target_name="${project_name}";
	if $deploy_version; then
		target_name="${deploy_file_name}";
	fi
	# set up the full deployment target directory
	local deploy_target="${directory}/${target_name}";
	if ! $flat; then
		deploy_target="${deploy_target}/${profile}";
	fi
	
	# validate required data
	if ! $deploy_local && [ -z "${host}" ]; then
		console.quit 1 "no remote host information available for deploy";
	fi
	
	# ready to start, output useful settings information
	:tasks.deploy.info;	
	
	# write the deploy script file
	:tasks.deploy.script.write!;
	
	if ! $dump_script && ! $dump_json; then
		echo "perform deployment !!!";
		# local debug testing
		# :tasks.script.debug;
		#exit 0;

		# scp the script to the remote server
		# :tasks.deploy.script.push!;		
	fi
	
	# clean up
	unset host;
	unset directory;
	unset local_commands;
	unset remote_commands;
}

# reads in the json data overrriding
# default values where appropriate
:tasks.deploy.json.read() {
	
	# USE DOCUMENT ROOT SETTINGS
	
	# always prefer the default host in deploy.json
	if [ -n "${json_doc[host]:-}" ]; then
		host="${json_doc[host]}";
	fi
	
	# lookup any custom working directory
	if [ -n "${json_doc[directory]:-}" ]; then
		directory="${json_doc[directory]}";
	fi	
	
	# USE PROFILE SPECIFIC SETTINGS
	
	# try a host specified in a profile
	if [ -n "${json_doc[profiles.${profile}.host]:-}" ];then
		host="${json_doc[profiles.${profile}.host]}";
	fi

	# try a directory specified in a profile
	if [ -n "${json_doc[profiles.${profile}.directory]:-}" ];then
		directory="${json_doc[profiles.${profile}.directory]}";
	fi

	# try a deploy type specified in the profile
	if [ -n "${json_doc[profiles.${profile}.type]:-}" ];then
		deploy_type="${json_doc[profiles.${profile}.type]}";
	fi
	
	# USE COMMNAD LINE OPTIONS
	
	# command line options that override deploy.json settings
	if [ -n "${overrides[host]:-}" ]; then
		host="${overrides[host]}";
	fi
	if [ -n "${overrides[directory]:-}" ]; then
		directory="${overrides[directory]}";
	fi
	if [ -n "${overrides[noop]:-}" ]; then
		noop="${overrides[noop]}";
	fi
}

# either outputs configuration information
# for the profile being processed or prints
# a json document 
:tasks.deploy.info() {
	if $dump_json; then
		
		local script_file="${script}";
		local script_shell="${shell}";		
		local script_shebang="${shebang}";	
		
		# variable names to inspect for
		# each profile being processed
		local var key vars=(
			deploy_name
			deploy_file_name
			deploy_type
			deploy_target
			script_shell
			script_shebang			
			script_file
			directory
			staging
			log_file
			log_dir
			git_url
			git_branch
			host
		);
		for var in "${vars[@]}"
			do
				# replace first underscore with a dot to group
				# as object on variable names with the same prefix
				key="${var/_/.}";
				key="${key//_/-}";
				variable.get "$var";
				json_dump["profiles.${profile}.$key"]="$_result";
		done
	# otherwise print out information to stdout
	else
		:tasks.deploy.out.info "deploy %s" "${deploy_name}";	
		:tasks.deploy.out.info "profile %s" "${profile}";	
		:tasks.deploy.out.info "noop %s" "${noop}";
		:tasks.deploy.out.info "shell %s" "${shell}";
		:tasks.deploy.out.info "script %s" "${script}";
		:tasks.deploy.out.info "remote working directory %s" "${directory}";
		:tasks.deploy.out.info "remote staging directory %s" "${staging}";
		:tasks.deploy.out.info "remote log file %s" "${log_file}";
		:tasks.deploy.out.info "git url %s" "${git_url}";
		:tasks.deploy.out.info "git branch %s" "${git_branch}";
		:tasks.deploy.out.info "host %s" "${host}";
	fi
}

# output an info message to stdout or
# the log file if logging
:tasks.deploy.out.info() {
	if $dump_json || $dump_script; then
		return 0;
	fi
	
	if ! $logging; then
		console.info "$@";
	else
		console.info "$@" >> "${log}" 2>&1;
	fi
}

# validate variable value does not contain
# whitespace: space or tab character
:tasks.deploy.whitespace.validate() {
	local value="${1:-}";
	local name="${2:-}";
	# staging directory cannot contain whitespace
	# so that we can perform tilde expansion
	local re="[ 	]+";
	if [[ "${value}" =~ $re ]]; then
		console.quit 1 "invalid %s value %s, cannot contain whitespace" \
			"${name}" "${value}";
	fi
}

:tasks.deploy.parse() {
	json.parse < "${descriptor}";	
}

:tasks.deploy.script.write!() {
	# delete any existing deploy script
	if [ -f "${script}" ]; then
		rm "${script}" \
			|| console.quit 1 "could not delete %s" "${script}";
	fi

	touch "${script}" \
		|| console.quit 1 "could not create %s" "${script}";

# write the script file
cat <<EOF >> "${script}"
${shebang}

# generated by task-deploy(7)
# do not edit this file manually
# use bake(1) with task-deploy(7)

# script: ${script_name}
# file: ${script}

set +e;

log_dir="${log_dir}"; export log_dir;
log_file="${log_file}"; export log_file;
deploy_log() {
	echo "\$log_dir";
	echo "\$log_file";
	# create the log directory
	if ! test -d $log_dir; then
		printf "creating %s\n" "$log_dir";
		mkdir -p ${log_dir} \\
			|| { echo "could not create $log_dir"; exit 1; }
	fi
	if test -f $log_file; then
		rm $log_file \\
			|| { echo "could not remove log file $log_file"; exit 1; }
	fi
	# create the log file
	printf "creating %s\n" "$log_file";
	touch $log_file \\
		|| { echo "could not create log file $log_file"; exit 1; }
}
deploy() {
	deploy_log;
}
deploy "\$@";
EOF

	chmod +x "${script}" \
		|| console.quit 1 "could not set permissions on %s" "${script}";	
	if $dump_script; then
		cat "${script}";
	fi
}

# runs script locally for debugging
:tasks.script.debug() {
	# output sscipt contents
	cat "${script}";
	# utility to verify the script is not bash only
	checkbashisms "${script}";
	# run script locally
	"${script}";
}

# write the script to the remote server
:tasks.deploy.script.push!() {
	local test_staging='test -d '${staging}'; echo $?;';
	local mk_staging='mkdir -p '${staging}'';

	# test if the staging directory exists
	:tasks.deploy.out.info "${executables[ssh]} %s %s" \
		"${host}" "${test_staging}";
	local exists=0;
	if ! $noop; then
		exists=$( "${executables[ssh]}" "${host}" ""${test_staging}"" );
	fi

	# create remote staging directory if it does not exist
	if [ $exists -gt 0 ]; then
		:tasks.deploy.out.info "${executables[ssh]} %s %s" \
			"${host}" "${mk_staging}";
		if ! $noop; then
			( "${executables[ssh]}" "${host}" ""${mk_staging}"" ) \
				|| :tasks.deploy.fail \
				"could not create remote staging directory %s" \
				"${staging}";
		fi
	fi

	local remote="${host}:${staging}/${script_name}";
	:tasks.deploy.out.info "scp -p %s %s" \
		"${script}" "${remote}";
	if ! $noop; then
		echo "SCP SCRIPT";
	fi	
}

# failure
:tasks.deploy.fail() {
	:tasks.deploy.complete.notify;
	if [ $# -gt 0 ]; then
		console.error "$@";
	fi
	console.quit 1 "deploy %s failed %s" \
			"${deploy_name}" "${characters[cross]}";
}

# attempts to notify via `growlnotify` when available
:tasks.deploy.complete.notify() {
	
	# don't send growl notifications for
	# json dumps or noop
	if $noop; then
		return 0;
	fi
	
	if [ -n "${executables[growlnotify]}" ]; then
		local message;
		local priority="${2:-Normal}";
		if $success; then
			message="${messages[success]}";
		else
			priority="Emergency";
			message="${messages[fail]}";
		fi
		"${executables[growlnotify]}" -m "$message" --priority "$priority";
	fi
}

# output the complete message
:tasks.deploy.complete() {
	
	# noop should always succeed
	if $noop; then
		success=true;
	fi
	
	# output success information
	if $success; then
		:tasks.deploy.complete.notify;
		if $dump_json || $dump_script; then
			console.success;
		else
			console.success "deploy %s complete %s" \
				"${deploy_name}" "${characters[tick]}";
		fi
	else
		:tasks.deploy.fail;
	fi
}

# validate a name follows the convention
:tasks.name.valid?() {
	local name="${1:-}";
	# may not start with a hyphen
	# and must match the name regex
	if [[ "$name" =~ ^-+ ]] || [[ ! "$name" =~ $re ]]; then
		return 1;
	fi
	return 0;
}

# quit if an invalid name is encountered
:tasks.name.quit() {
	local var="$1";
	local value="$2";
	console.error "names may not start with a hyphen and must match %s" "$re";	
	console.error "invalid $var name %s" "$value";
	console.quit 1;
}

# parse options
:tasks.deploy.options.parse() {
	local value ;
	while test -n "${1:-}"; do
		case $1 in
			--noop )
				noop=true;
				overrides[noop]=true;				
				;;
			--staging )
				shift;
				staging="${1:-}";
				;;
			--local )
				deploy_local=true;
				;;
			--json )
				dump_json=true;
				noop=true;
				overrides[noop]=true;
				dump_script=false;				
				;;
			--script )
				dump_script=true;
				noop=true;
				overrides[noop]=true;
				dump_json=false;
				;;
			--pretty )
				pretty=true;
				;;
			--flat )
				flat=true;
				;;	
			--include-version )
				deploy_version=true;
				;;
			--log )
				logging=true;
				# clear the log file
				printf "" >| "${log}";
				;;
			--shell )
				shift;
				value="${1:-}";
				if [ -z "${value}" ]; then
					console.quit 1 "no shell specified";
				fi
				shell="${value}";
				;;
			--name )
				shift;
				value="${1:-}";
				if [ -z "${value}" ]; then
					console.quit 1 "no name specified";
				fi
				if ! :tasks.name.valid? "${value}"; then
					:tasks.name.quit "project" "$value";
				fi
				project_name="${value}";
				;;
			--directory )
				shift;
				value="${1:-}";
				if [ -z "${value}" ]; then
					console.quit 1 "no directory specified";
				fi
				overrides[directory]="${value}";
				;;
			--host )
				shift;
				value="${1:-}";
				if [ -z "${value}" ]; then
					console.quit 1 "no host specified";
				fi
				overrides[host]="${value}";
				;;
			--descriptor )
				shift;
				value="${1:-}";
				if [ -z "${value}" ]; then
					console.quit 1 "no descriptor specified";
				fi
				descriptor="${value}";		
				;;
			-* | --* )
				console.quit 1 "unknown option %s" "$1";
				;;
			* )
				if ! :tasks.name.valid? "$1"; then
					:tasks.name.quit "profile" "$1";
				fi
				profiles+=( "$1" );
				;;
		esac
		shift;
	done
}