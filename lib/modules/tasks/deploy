: <<'ronn:markdown'
task-deploy(7) -- deploy task(s) for bake(1)
=============================================

## SYNOPSIS

Deploy task(s) for bake(1).

## DESCRIPTION

Performs a deployment for a project.

## REQUIRE

You do not need to require(3) this task as it is a builtin task.

## USAGE

	bake deploy [options...] [profiles...]
	
## OPTIONS

* `--directory [directory]`:

Use *directory* for deployment. When this option is specified it overrides any directory specified in *deploy.json* for all profiles.

* `--host [user@host]`:

The scp(1) and ssh(1) *user@host* specification. When this option is specified it overrides any host properties in *deploy.json*. This is useful if you wish to deploy everything using the profile(s) in *deploy.json* to a different host.

* `--descriptor [file]`:

Use *file* as the deployment descriptor.

* `--staging [directory]`:

Use *directory* as the staging directory.

* `--shell [shell]`:

Use *shell* for the script shebang. Must be one of *sh*, *bash*, *zsh* or *dash*.

* `--log`:

Redirect *stdout* messages to `target/deploy/deploy.log`. Note that when using the `--json` option that the JSON document is always sent to *stdout*.

* `--flat`:

Do not include the profile name in the target directory.

* `--include-version`:

Include version information in the target directory.

* `--local`:

Perform a deployment on the local host.

* `--json`:

Dump all profile configuration settings that would be used by a deployment as a JSON document to *stdout*, implies `--noop`. This is useful to determine the settings that would be used when running a deployment.

If this option is used in conjunction with `--script` the last option will take preference.

* `--pretty`:

Use in conjunction with the `--json` option to pretty print the JSON document. Uses two spaces as the indentation.

* `--write-json`:

Write the deployment settings to `target/deploy/settings.json`. If used in conjunction with the `--json` option then the settings will be printed to *stdout* and written to disc. The generated document will be formatted if the `--pretty` flag has been set.

* `--script`:

Dump script(s) to *stdout*, implies `--noop`. If this option is used in conjunction with `--json` the last option will take preference. Note that when this option is used the script(s) are still written to `target/deploy`.

* `--no-local`:

Shortcut for combining `--no-local-pre` and `--no-local-post`.

* `--no-local-pre`:

Do not execute the pre-deployment commands on the local host.

* `--no-local-post`:

Do not execute the post-deployment commands on the local host.

* `--no-remote`:

Shortcut for combining `--no-remote-pre` and `--no-remote-post`.

* `--no-remote-pre`:

Do not execute the pre-deployment commands on the remote host.

* `--no-remote-post`:

Do not execute the post-deployment commands on the remote host.

* `--expand`:

Do not quote command options. When this options is set parameter expansion is performed on command options declared in a deployment descriptor.

* `--noop`:

Print commands but do not execute them.
	
## TYPES

The deploy tasks support the *git* and *tar* deployment types.

### GIT

This deployment type will clone if the deployment directory does not exist and fetch the specified branch from the remote repository.

### TAR

This deployment type will fetch a tarball from a filesystem path or remote URL and extract the contents to the target directory.

## JSON FORMAT

The format of the *deploy.json* descriptor is described in the task-deploy-json(7) man page, to view this man page run:

	bake help deploy-json
	
## TARGET

The final deploy target is a combination of the *directory*, *name* and *profile* by default. Assuming a *directory* of `~/www` and the project name `project` with a deployment profile of `stage` the target used for deployment is:

	~/www/project/stage
	
If you do not wish to include the profile name in the target directory specify the `--flat` option which results in:

	~/www/project
	
It depends upon your deployment requirements as to which strategy you wish to use. Generally, if you are deploying to the same host then it makes sense to separate the deployment profiles, whereas if each deployment profile is using a different host then it is more consistent to have the same directory structure across the different hosts.

You may also create separate deployment targets based on the project version using the `--include-version` option. Continuing the above example with a version of `0.0.1` and the default behaviour (no `--flat` option specified) then the target becomes:

	~/www/project-0.0.1/stage
	
Or alternatively in conjunction with the `--flat` option the target directory becomes:

	~/www/project-0.0.1
	
## PROFILES

You may specify one or more profiles to deploy after any options. If no profiles are specified then a deploy is attempted using the *default* profile.

Note that a profile must declare at a minimum the *type* property for it to be recognised, for example the following is invalid:

	{
		"profiles": {
			"stage": {}
		}
	}
	
Therefore the profile will not be available. You `must` specify at least the deployment *type*:

	{
		"profiles": {
			"stage": {
				"type": "git"
			}
		}
	}

## DEFAULT PROFILE

The default profile uses a *git* deployment type and the current branch and git remote URL for deployment to the target host.

## NAMES

Profile and project names may not start with a hyphen and should match the pattern ^[-a-zA-Z0-9]+.

## STRICT

The deployment process is strict. Failure is always assumed and when deploying multiple profiles, failure of a profile to deploy will prevent any subsequent profiles from being processed.

## FILES

A *deploy.json* file must be present in the root of the project and must be valid JSON. This file may just contain '{}' if you wish to use the *default* profile and configure deployment parameters via environment variables or command line options.

## ENVIRONMENT

* `bake_deploy_remote`:

The remote host used for deployment when none is specified in *deploy.json*.

* `bake_deploy_shell`:

The shell used on the remote server, defaults to `sh` if none is specified.

* `bake_deploy_staging`:

The directory used on the remote server for staging deployment scripts, default is `~/.deploy`.

## COMMAND EXECUTION

The deployment process can optionally execute arbitrary simple commands on the local and remote host. For each host, command execution is split into the pre-deployment and post-deployment execution phases.

If any command exits with an exit code *>0* then the deployment is aborted. This is useful for running tests prior to performing a deployment or other tasks such as creating a tarball package.

The general syntax for declaring commands is:

	"commands": {
		"local": {
			"pre": [
				{
					"command": "ls",
					"options": [ "-la", "lib", "man" ]
				}
			],
			"post": [
				{
					"command": "echo",
					"options": [ "deployment complete $deploy_name" ]
				}
			]
		}
	}
	
All commands are encapsulated by the *commands* object which can contain *local* and *remote* properties indicating whether the commands should be executed on the local or remote host. The *pre* and *post* properties are arrays of commands to execute for the deployment phase(s).

A *commands* object may be declared at the top-level of the JSON descriptor document, in which case the commands will be executed for *all* profiles. A *commands* object may also be declared in a profile to execute commands specific to that profile. When *commands* are declared at the top-level of the document and in a profile then they are concatenated together and all commands are executed.

### PARAMETER EXPANSION

By default parameters are not expanded - whitespace in a parameter is preserved and passed as a single argument to the command being executed. For example, imagine you wanted to list the contents of the *lib* and *man* directories, this would fail (with the default settings) if you specified both directories in a single option (`ls` would be looking for a directory named "lib man" rather than attempting to list two separate directories):

	{
		"command": "ls",
		"options": [ "-la", "lib man" ]
	}
	
You have two options to remedy this scenario. You may either decide to separate the parameters:

	{
		"command": "ls",
		"options": [ "-la", "lib", "man" ]
	}
	
So that the *lib* and *man* are passed as separate arguments to *ls*. Or you may use the `--expand` option to allow parameter expansion on command options. You should only use the `--expand` option if you are certain that you do not want to include whitespace in any options passed to command(s) being executed.

### Command Environment

Commands executing in a *local* context have access to the entire bake(1) variable scope chain which means that there are some useful variables exposed to your commands.

* `project_name`:

The name of the project.

* `project_version`:

The project version.

* `root`:

The project root directory.

* `project`:

The root directory for multi-module projects, when bake(1) is executing at the root of a multi-module project then `root` and `project` point to the same directory.

* `target`:

The `target` directory relative to `${root}` used by bake(1) for staging files.

* `profile`:

The name of the profile currently being deployed.

* `deploy_target`:

The final target directory used for the deployment, see the `TARGET` section.

* `deploy_name`:

The human readable name used by task-deploy(7). This is the project name and version delimited by @, for example: project@0.0.1.

* `deploy_file_name`:

The prefix used when defining file names. Uses - as the delimiter, for example: project-0.0.1.

* `script_name`:

The name of the script that will be used by task-deploy(7) for deployment.

* `script`:

The path to the script that will be used to perform deployment.

* `log`:

The path to the log file used by task-deploy(7).

* `logging`:

A boolean indicating whether output is being redirected to the file defined by the *log* variable.

* `deploy_type`:

The type of deployment being performed, see the `TYPES` section.

* `noop`:

A boolean indicating if this deployment is a non-operation, will be *true* if the `--noop` option has been specified.

* `flat`:

A boolean indicating if a flat directory structure is being used, see the `TARGET` section.

* `include_version`:

A boolean indicating if version information is being included in the directory structure, see the `TARGET` section.

### Example

An example that uses npm(1) to create a tarball, moves it to the `target` directory and copies the tarball to a remote host:

	"commands": {
		"local": {
			"pre": [
				{
					"command": "npm",
					"options": [ "pack" ]
				},
				{
					"command": "mv",
					"options": [ "$project_name-$project_version.tgz", "target" ]
				},
				{
					"command": "scp",
					"options": [ "target/$project_name-$project_version.tgz", "user@example.com:~/" ]
				}
			]
		}
	}
	
### Command Errors

Commands (declared by the *command* property) may not contain any whitespace (space, tab or newline). It is a JSON error to declare literal whitespace characters such as \\n or \\t, if these are specified using the escaped values (allowed by JSON) the program will exit with a whitespace error.

If you reference a variable that is unbound in a command the program will exit immediately with a >0 exit code and an error message.

## NOTIFICATIONS

If the *growlnotify* executable is available then a success or failure notification will be sent using *growlnotify*. Note that *growlnotify* notifications are not sent for a `noop` which is the case if the `--noop`, `--json` or `--script` options are specified.

## FILES

All generated files are written to `target/deploy`.

When the `--log` option is specified *stdout* messages are redirected to `target/deploy/deploy.log`.

The generated script file(s) are written to `target/deploy` using the following naming strategy:

	${name}-${version}-${profile}.sh
	
If the `--write-json` option is specified then the deployment settings are written to `target/deploy/settings.json`.

## EXIT CODES

A >0 exit code indicates failure while a 0 exit code indicates success.

## EXAMPLES

Deploy using the default profile:

	bake deploy
	
Deploy using the default profile locally:

	bake deploy --local
	
Inspect deployment commands:

	bake deploy --noop
	
Deploy the profile *stage*:

	bake deploy stage
		
Deploy the profiles *test*, *stage* and *production*:

	bake deploy test stage production
	
Inspect the settings used for a *default* deployment:

	bake deploy --json --pretty \\
		--staging ~/project-staging \\
		--name project \\
		--directory ~/www

## BUGS

**task-deploy** is written in bash and depends upon `bash` >= 4.2.

## COPYRIGHT

**task-deploy** is copyright (c) 2012 muji <http://xpm.io>

## SEE ALSO

bake(1), task-deploy-json(7)
ronn:markdown

require.once 'json';
require.once 'git';

# deploy delegate
tasks.deploy() {
	
	# the prefix used for deployment
	# interactive prompts
	local deploy_prompt_prefix="\033[1m[deploy]\033[0m";
	local deploy_prompt="${deploy_prompt_prefix} \033[4m%s\033[0m";
	local deploy_prompt_suffix=" ⚡";
	
	# start time for the entire deployment
	local deploy_start_time=$( date );
	local deploy_local_host_name=$( hostname );
	local deploy_user=$( id -nu );
	
	executable.validate scp ssh;

	local descriptor="${root}/deploy.json";
	local newline=$'\n';

	executable.validate --test growlnotify;
	
	# name validation regex
	local re="^[-a-zA-Z0-9]+$";
	
	local deploy_target_directory="${target}/deploy";
	if [ ! -d "${deploy_target_directory}" ]; then
		mkdir -p "${deploy_target_directory}" \
			|| console.quit 1 "could not create %s" "${deploy_target_directory}";
	fi
	
	local log="${deploy_target_directory}/deploy.log";
	local logging=false;
	# clear the log file
	printf "" >| "${log}";	
	
	# non-operation
	local noop=false;
	
	# quote command options by default
	local quote=true;
	
	# stores flags used to skip command
	# execution phases
	declare -A skip;
	skip["local.pre"]=false;
	skip["local.post"]=false;
	skip["remote.pre"]=false;
	skip["remote.post"]=false;

	# valid deployment types
	local types=( git tar );
	
	local profiles=();
	
	# determine if we are deploying locally
	local deploy_local=false;
	
	# include version information in the target
	local include_version=false;
	
	# dump script contents to stdout
	local dump_script=false;

	# strategy used to determine the target
	# directory. the default is to include
	# the profile name in the target directory
	# structure
	local flat=false;
	
	# command line options that override
	# properties set in deploy.json
	declare -A overrides;
	
	# list of supported shells
	local shells=( sh bash zsh dash );

	# default to git deployment
	local deploy_type="git";
	local profile="default";
	local directory="";
	local shell="${bake_deploy_shell:-sh}";
	local host="${bake_deploy_remote:-}";
	local staging="${bake_deploy_staging:-~/.deploy}";
	local git_url git_branch;
	git.remote.url "git_url";
	git.branch.current "git_branch";
	
	# JSON PROPERTIES
	# determines whether we are generating json
	local dump_json=false;
	local write_json=false;
	local json_settings_file="${deploy_target_directory}/settings.json";
	local pretty=false;
	# array used to store properties to be
	# dumped as json
	declare -A json_dump;
	json_dump["project-version"]="${project_version}";

	# assume failure
	local success=false;
	
	# parse options
	:tasks.deploy.options.parse "$@";	
	
	# human readable name using @ delimiter
	# must be set after option parsing in case a --name
	# option has been specified
	local deploy_name="${project_name}@${project_version}";
	# file name using a - delimiter	
	local deploy_file_name="${project_name}-${project_version}";
	local script_name="${deploy_file_name}-${profile}.sh";
	local script="${target}/${script_name}";
	local log_name="${deploy_file_name}-${profile}.log";
	local log_dir="${staging}/log";
	local log_file="${log_dir}/${log_name}";
	
	# messages
	declare -A messages;
	# messages sent via `growlnotify`
	messages[success]="deploy ${deploy_name} complete";
	messages[fail]="deploy ${deploy_name} failed";
	
	# validate the descriptor after option parsing
	:tasks.deploy.descriptor.validate;

	local default_profile="default";
	# attempt to deploy the default profile
	if [ ${#profiles[*]} -eq 0 ]; then
		profiles+=( "${default_profile}" );
	fi
	
	:tasks.deploy.profiles.uniq!;
	
	:tasks.deploy.parse;	
	
	# update some json dump properties after option parsing
	json_dump["project-name"]="${project_name}";	
	json_dump["descriptor"]="${descriptor}";
	json_dump["noop"]="${noop}";
	json_dump["local"]="${deploy_local}";
	local i;
	for i in ${!profiles[@]}
		do
			json_dump["targets.$i"]="${profiles[$i]}";
	done
	
	# validate whitespace on the project name
	:tasks.deploy.whitespace.validate "${project_name}" "project name";
	# validate whitespace on the staging property
	:tasks.deploy.whitespace.validate "${staging}" "staging";
	
	# validate the shell in use
	if ! array.contains? "$shell" "${shells[@]}"; then
		console.quit 1 "shell %s is not supported" "$shell";
	fi
	
	# configure the shebang
	local shebang="#!/bin/sh";
	if [ "${shell}" != "sh" ]; then
		shebang="#!/usr/bin/env ${shell}";
	fi
	
	echo "got target profiles : ${profiles[@]}";
	
	# deploy all profiles
	:tasks.deploy.profiles;

	# show the complete message
	:tasks.deploy.complete;
}

# DEPLOY PRIVATE COMMANDS

# validate a descriptor file
:tasks.deploy.descriptor.validate() {
	if [[ ! "${descriptor}" =~ \.json$ ]]; then
		console.quit 1 "descriptor %s does not have a .json file extension" \
			"${descriptor}";
	fi
	if [ ! -f "${descriptor}" ]; then
		console.quit 1 "no deploy descriptor %s" "${descriptor}";
	fi
}

# make profile list unique
:tasks.deploy.profiles.uniq!() {
	local IFS=$'\n';
	local lines=( ${profiles[*]} );
	unset IFS;
	profiles=( $( printf "${lines[*]}" | sort | uniq ) );
}

# deploy a series of profiles
:tasks.deploy.profiles() {
	local profile;

	# print profiles being processed	
	:tasks.deploy.print.profiles;
	
	for profile in "${profiles[@]}"
		do
			if [ "${profile}" != "${default_profile}" ]; then
				if ! :tasks.profile.valid?; then
					console.warn "profile %s does not exist" "${profile}";
					continue;
				fi
			fi
			# quit on invalid profile name in the deploy descriptor
			if ! :tasks.name.valid? "${profile}"; then
				:tasks.name.quit "profile" "$1";
			fi
			:tasks.deploy.profile;
	done
	# dump/write json information
	if $dump_json || $write_json; then
		if ! $pretty; then
			json.stringify <<< "json_dump";
		else
			json.stringify --pretty 2 <<< "json_dump";
		fi
		if $dump_json; then
			json.string;
			printf "\n";
		fi
		if $write_json; then
			printf "" >| "$json_settings_file";
			json.string >> "$json_settings_file";
			printf "\n" >> "$json_settings_file";
		fi
	fi
}

# test whether a profile name is valid
# validity is determined by the existence of a
# host property for the profile
:tasks.profile.valid?() {
	local key="profiles.${profile}.type";
	local value="${json_doc[$key]:-}";
	test -n "${value}";
}

# deploy a single profile
:tasks.deploy.profile() {
	
	# stores command to execute
	# for all profiles
	declare -A global_commands;
	
	# stores command to execute
	# for a profile
	declare -A profile_commands;
	
	local start_time=$( date )
	
	:tasks.deploy.out.info "%s" "${start_time}";
		
	local script_name="${deploy_file_name}-${profile}.sh";
	local script_dir="${deploy_target_directory}";
	local script="${script_dir}/${script_name}";
	local log_name="${deploy_file_name}-${profile}.log";
	local log_dir="${staging}/log";
	local log_file="${log_dir}/${log_name}";
	
	# TODO: allow for the version to be included in the target directory
	local target_name="${project_name}";
	if $include_version; then
		target_name="${deploy_file_name}";
	fi
	# the full deployment target directory
	local deploy_target;
	
	# override default settings from user defined deploy.json
	:tasks.deploy.json.read;	
	
	# validate required data
	if ! $deploy_local && [ -z "${host}" ]; then
		console.quit 1 "no remote host information available for deploy";
	fi
	
	# ready to start, output useful settings information
	:tasks.deploy.info;	
	
	# verify deployment type is valid
	if ! array.contains? "${deploy_type:-}" "${types[@]}"; then
		console.quit 1 "invalid deployment type %s" "${deploy_type:-}";
	fi
	
	if ! $dump_json; then
		# write the deploy script file
		:tasks.deploy.script.write!;
	fi

	if ! $dump_script && ! $dump_json; then
	
		# prompt for confirmation when possible
		:tasks.deploy.confirm ":tasks.deploy.profile.start" "$profile";
	fi
	
	# clean up
	unset deploy_type;
	unset host;
	unset directory;
	unset profile_commands;
}

# start execution of a profile
:tasks.deploy.profile.start() {
	
	# run local pre-deployment command execution
	:tasks.deploy.run.pre;
	
	echo "start deployment !!!";
	
	# local debug testing
	# :tasks.script.debug;
	#exit 0;

	# scp the script to the remote server
	# :tasks.deploy.script.push!;		
	
	# run local post-deployment command execution
	:tasks.deploy.run.post;	
}

# reads in the json data overrriding
# default values where appropriate
:tasks.deploy.json.read() {
	
	# USE DOCUMENT ROOT SETTINGS
	
	if [ -n "${json_doc[host]:-}" ]; then
		host="${json_doc[host]}";
	fi
	if [ -n "${json_doc[directory]:-}" ]; then
		directory="${json_doc[directory]}";
	fi
	
	# USE PROFILE SPECIFIC SETTINGS
	
	if [ -n "${json_doc[profiles.${profile}.host]:-}" ];then
		host="${json_doc[profiles.${profile}.host]}";
	fi
	if [ -n "${json_doc[profiles.${profile}.directory]:-}" ];then
		directory="${json_doc[profiles.${profile}.directory]}";
	fi
	if [ -n "${json_doc[profiles.${profile}.type]:-}" ];then
		deploy_type="${json_doc[profiles.${profile}.type]}";
	fi
	
	# USE COMMAND LINE OPTION OVERRIDES
	
	# command line options that override deploy.json settings
	if [ -n "${overrides[host]:-}" ]; then
		host="${overrides[host]}";
	fi
	if [ -n "${overrides[directory]:-}" ]; then
		directory="${overrides[directory]}";
	fi
	
	# set up the full deployment target directory
	deploy_target="${directory}/${target_name}";
	if ! $flat; then
		deploy_target="${deploy_target}/${profile}";
	fi
	
	# NOTE: this reading commands should be done
	# NOTE: after setting all relevant variables
	# NOTE: so that all variables are available to commands being
	# NOTE: declared in the deploy.json descriptor	
	
	# read in global commands
	:tasks.deploy.commands.read;
	
	# read in profile specific commands
	:tasks.deploy.commands.read "profiles.${profile}";
}

# run pre-deployment local commands
:tasks.deploy.run.pre() {
	if "${skip["local.pre"]}"; then
		return 0;
	fi
	if [ "${#global_commands[@]:-0}" ]; then
		:tasks.deploy.run "commands.local.pre" true;
	fi
	:tasks.deploy.run "commands.local.pre";
}

# run post-deployment local commands
:tasks.deploy.run.post() {
	if "${skip["local.post"]}"; then
		return 0;
	fi
	if [ "${#global_commands[@]:-0}" ]; then
		:tasks.deploy.run "commands.local.post" true;
	fi	
	:tasks.deploy.run "commands.local.post";
}

# run a set of local commands
:tasks.deploy.run() {
	local varname="$1";
	local use_global_commands="${2:-false}";
	local cmd list arr exe opt exit_code;
	
	# shortcut out for empty command maps	
	local length=0;
	if $use_global_commands; then
		length="${global_commands["${varname}.length"]:-0}";
	else
		length="${profile_commands["${varname}.length"]:-0}";
	fi
	if [ $length -eq 0 ]; then
		return 0;
	fi
	
	# build list of commands to execute
	list=();
	:tasks.deploy.run.list;
	for cmd in "${list[@]:-}"
		do
			# echo "cmd is : ${cmd}";
			local IFS=$'\n';
			arr=( ${cmd} );
			unset IFS;
			if [ ${#arr[@]} -gt 0 ]; then
				#echo "arr length is :: ${#arr[@]}";
				exe="${arr[0]}";
				local IFS=$'\n';
				opt=( "${arr[@]:1}" );
				unset IFS;
				:tasks.deploy.out.info "exec %s %s" "${exe}" "${opt[*]:-}";
				
				# echo "run command : ${exe} : ${opt[@]:-}";
				
				# validate the executable being executed
				executable.validate --test "${exe}";
				if [ -z "${executables[$exe]}" ]; then
					:tasks.deploy.fail "executable %s is not available" "$exe";
				fi
				
				#echo "run command (after validation) : ${exe} : ${opt[@]:-} : length:  ${#opt[@]}";
				
				# execute the command
				if ! $noop; then
					if ! $logging; then
						if $quote; then
							( ${exe} "${opt[@]:-}" ); exit_code=$?;
						else
							( ${exe} ${opt[@]:-} ); exit_code=$?;
						fi
					else
						if $quote; then
							( ${exe} "${opt[@]:-}" >> "${log}" 2>&1 );
							exit_code=$?;
						else
							( ${exe} ${opt[@]:-} >> "${log}" 2>&1 );
							exit_code=$?;
						fi
					fi
					if [ $exit_code -gt 0 ]; then
						:tasks.deploy.fail "execution error %s %s" "$exe" "${opt[*]:-}";
					fi
				fi
			fi
	done
}

# fetch the command type subset 
# as an ordered array of commands
:tasks.deploy.run.list() {
	local k v keys i;
	local re="${varname//\./\\.}";
	re="^$re\.([0-9]+)";
	if $use_global_commands; then
		for k in "${!global_commands[@]}"
			do
				v="${global_commands[$k]}";
				:tasks.deploy.run.list.add;
		done
	else
		for k in "${!profile_commands[@]}"
			do
				v="${profile_commands[$k]}";
				:tasks.deploy.run.list.add;
		done		
	fi
}

# add a command to the list of
# commands to be processed
:tasks.deploy.run.list.add() {
	if [[ "$k" =~ $re ]]; then
		i="${BASH_REMATCH[1]}";
		list[$i]="$v";
	fi
}

# read in commands
:tasks.deploy.commands.read() {
	local prefix="${1:-}";
	local use_global_commands=false;
	if [ -z "$prefix" ]; then
		prefix="commands";
		use_global_commands=true;
	else
		prefix="${prefix}.commands";
	fi
	
	local local_pre_length="${json_doc[${prefix}.local.pre.length]:-0}";
	local local_post_length="${json_doc[${prefix}.local.post.length]:-0}";
	local remote_pre_length="${json_doc[${prefix}.remote.pre.length]:-0}";
	local remote_post_length="${json_doc[${prefix}.remote.post.length]:-0}";
	if [ $local_pre_length -gt 0 ]; then
		:tasks.deploy.commands.read.group \
			"$prefix" \
			"${prefix}.local.pre" \
			$local_pre_length \
			"commands.local.pre"
	fi
	if [ $local_post_length -gt 0 ]; then
		:tasks.deploy.commands.read.group \
			"$prefix" \
			"${prefix}.local.post" \
			$local_post_length \
			"commands.local.post"
	fi
	if [ $remote_pre_length -gt 0 ]; then
		:tasks.deploy.commands.read.group \
			"$prefix" \
			"${prefix}.remote.pre" \
			$remote_pre_length \
			"commands.remote.pre"
	fi
	if [ $remote_post_length -gt 0 ]; then
		:tasks.deploy.commands.read.group \
			"$prefix" \
			"${prefix}.remote.post" \
			$remote_post_length \
			"commands.remote.post"
	fi
}

# read in a group of commands
:tasks.deploy.commands.read.group() {
	local prefix="$1";
	local group="$2";
	local length="$3";
	local varname="$4";
	local i j jl exe opt cmd;
	
	local whitespace="[ 	]";
	
	# echo "GROUP READ !!! : $group";
	# echo "GROUP READ !!! : ${!json_doc[*]}";
	
	for((i = 0;i < $length;i++))
		do
			cmd="";
			exe="${json_doc[${group}.$i.command]:-}";
			if [ -z "$exe" ]; then
				console.error "invalid command %s in %s" "$exe" "$descriptor";
				:tasks.deploy.fail "%s may not be a blank string" "command";
			fi
			
			# echo "got exe: $exe";
			
			if [[ "$exe" =~ $whitespace ]]; then
				console.error "invalid command %s in %s" "$exe" "$descriptor";
				:tasks.deploy.fail "%s may not contain whitespace" "command";
			fi
			
			jl="${json_doc[${group}.$i.options.length]:-0}";
			
			# echo "read command at index $i : $group : $exe"
			
			if [ -n "$exe" ]; then
				cmd="${exe}";
			fi
			
			for((j = 0;j < $jl;j++))
				do
					opt="${json_doc[${group}.$i.options.$j]}";
					
					# evaluate each option so that variable
					# references can be used
					trap :tasks.deploy.unbound.variable EXIT
					eval "opt=\"${opt}\"";
					trap - EXIT
					
					cmd="${cmd}
${opt}";
			done
			
			if $use_global_commands; then
				global_commands["${varname}.$i"]="${cmd}";
			else
				profile_commands["${varname}.$i"]="${cmd}";
			fi
	done
	
	# add length properties
	if $use_global_commands; then
		global_commands["${varname}.length"]="${i}";
	else
		profile_commands["${varname}.length"]="${i}";
	fi
}

# handles the situation when a command *probably*
# references an unbound variable
:tasks.deploy.unbound.variable()
{
	# console.throw "probable reference to unbound variable";
	console.error "probable reference to unbound variable";
	:tasks.deploy.fail "invalid command %s" "${cmd//$newline/ }";
}

# either outputs configuration information
# for the profile being processed or prints
# a json document 
:tasks.deploy.info() {

	# always build up the json settings so that
	# this data can be written to a file when
	# performing a deployment
	local script_file="${script}";
	local script_shell="${shell}";
	local script_shebang="${shebang}";
	
	# variable names to inspect for
	# each profile being processed
	local var key vars=(
		deploy_name
		deploy_file_name
		deploy_type
		deploy_target
		script_shell
		script_shebang			
		script_file
		script_dir
		directory
		staging
		log_file
		log_dir
		git_url
		git_branch
		host
	);
	local value k len;
	for var in "${vars[@]}"
		do
			# replace first underscore with a dot to group
			# as object on variable names with the same prefix
			key="${var/_/.}";
			if ! array.is.array? "${var}" && ! array.is.assoc? "${var}"; then
				key="${key//_/-}";
				variable.get "${var}";
				value="${_result:-}";
				if [ -n "${value}" ]; then
					json_dump["profiles.${profile}.$key"]="$value";
				fi
			else
				key="${var//_/.}";
				#echo "ADD ARRAY CONTENTS:::!!! $key : $var"
				eval "keys=( \${!$var[@]} )";
				eval len="\${#$var[@]}";
				if [ $len -gt 0 ]; then
					# echo "add with array length : ${len}";
					for k in "${keys[@]:-}"
						do
							eval value="\${$var[$k]}";
							# echo "adding array element : $k : $value"
							if [ -n "${value}" ]; then
								json_dump["profiles.${profile}.${key}.${k}"]="$value";
							fi
					done
				fi
			fi
	done
	
	# otherwise print out information to stdout
	if ! $dump_json && ! $dump_script; then
		:tasks.deploy.out.info "deploy %s" "${deploy_name}";	
		:tasks.deploy.out.info "profile %s" "${profile}";	
		:tasks.deploy.out.info "noop %s" "${noop}";
		:tasks.deploy.out.info "shell %s" "${shell}";
		:tasks.deploy.out.info "script %s" "${script}";
		:tasks.deploy.out.info "working directory %s" "${directory}";
		:tasks.deploy.out.info "staging directory %s" "${staging}";
		:tasks.deploy.out.info "target %s" "${deploy_target}";
		:tasks.deploy.out.info "log file %s" "${log_file}";
		:tasks.deploy.out.info "git url %s" "${git_url}";
		:tasks.deploy.out.info "git branch %s" "${git_branch}";
		:tasks.deploy.out.info "host %s" "${host}";
	fi
}

# print profiles
:tasks.deploy.print.profiles() {
	:tasks.deploy.out.info "deploy %s" "$deploy_start_time";
	:tasks.deploy.out.info "started by %s" "${deploy_user}@${deploy_local_host_name}";
	:tasks.deploy.out.info "";		
	local p;
	for p in "${profiles[@]}"
		do
			:tasks.deploy.out.info "\t%s" "$p";
	done
	:tasks.deploy.out.info "";
}

# output an info message to stdout or
# the log file if logging
:tasks.deploy.out.info() {
	if $dump_json || $dump_script; then
		return 0;
	fi
	
	if ! $logging; then
		console.info "$@";
	else
		console.info "$@" >> "${log}" 2>&1;
	fi
}

# build up the prompt string
:tasks.deploy.prompt() {
	local replace="${1:-}";
	local ps1=$( printf "$deploy_prompt" "$replace" );
	#echo -n "${ps1}${rlx_prompt_suffix}";
	prompt="${ps1}${deploy_prompt_suffix}";
}

# interactive confirmation for
# a profile deployment
:tasks.deploy.confirm() {
	local callback="${1:-}";
	# stdin or stdout is not a tty
	# cannot interact
	if [ ! -t 0 ] || [ ! -t 1 ]; then
		# invoke callback to start deployment
		$callback;
		return 0;
	fi
	
	local replace="${2:-}";
	:tasks.deploy.prompt "${replace}";

	accepted() {
		$callback;
	}

	rejected() {
		:tasks.deploy.fail "aborted %s" "${replace}";
	}

	# define a boolean prompt
	prompt.boolean confirm y n "${prompt} are you sure? (y/n)";
	# set accept/reject callback(s)
	prompt.accepts accepted;
	prompt.rejects rejected;
	prompt.show confirm;
	prompt.clean;
	
	# clean up confirmation callbacks
	method.remove accepted rejected;
}

# validate variable value does not contain
# whitespace: space or tab character
:tasks.deploy.whitespace.validate() {
	local value="${1:-}";
	local name="${2:-}";
	# staging directory cannot contain whitespace
	# so that we can perform tilde expansion
	local re="[ 	]+";
	if [[ "${value}" =~ $re ]]; then
		console.quit 1 "invalid %s value %s, cannot contain whitespace" \
			"${name}" "${value}";
	fi
}

# parse the deploy descriptor as JSON
:tasks.deploy.parse() {
	json_exit=false;
	json.parse < "${descriptor}" >> "$log" 2>&1;
	if [ $json_exit_code -gt 0 ]; then
		console.error "invalid json in %s" "$descriptor";
		:tasks.deploy.fail "stack trace in %s" "$log";
	fi
}

:tasks.deploy.script.write!() {
	# delete any existing deploy script
	if [ -f "${script}" ]; then
		rm "${script}" \
			|| console.quit 1 "could not delete %s" "${script}";
	fi

	touch "${script}" \
		|| console.quit 1 "could not create %s" "${script}";

# write the script file
cat <<EOF >> "${script}"
${shebang}

# generated by task-deploy(7)
# do not edit this file manually
# use bake(1) with task-deploy(7)

# date: $( date )
# script: ${script_name}
# file: ${script}
# name: ${project_name}
# version: ${project_version}
# profile: ${profile}
# type: ${deploy_type}
# local: ${deploy_local}
# flat: ${flat}
# include version: ${include_version}
# staging: ${staging}
# directory: ${directory}
# target: ${deploy_target}

set +e;

log_dir="${log_dir}"; export log_dir;
log_file="${log_file}"; export log_file;
deploy_log() {
	echo "\$log_dir";
	echo "\$log_file";
	# create the log directory
	if ! test -d $log_dir; then
		printf "creating %s\n" "$log_dir";
		mkdir -p ${log_dir} \\
			|| { echo "could not create $log_dir"; exit 1; }
	fi
	if test -f $log_file; then
		rm $log_file \\
			|| { echo "could not remove log file $log_file"; exit 1; }
	fi
	# create the log file
	printf "creating %s\n" "$log_file";
	touch $log_file \\
		|| { echo "could not create log file $log_file"; exit 1; }
}
deploy() {
	deploy_log;
}
deploy "\$@";
EOF

	chmod +x "${script}" \
		|| console.quit 1 "could not set permissions on %s" "${script}";	
	if $dump_script; then
		cat "${script}";
	fi
}

# runs script locally for debugging
:tasks.script.debug() {
	# output sscipt contents
	cat "${script}";
	# utility to verify the script is not bash only
	checkbashisms "${script}";
	# run script locally
	"${script}";
}

# write the script to the remote server
:tasks.deploy.script.push!() {
	local test_staging='test -d '${staging}'; echo $?;';
	local mk_staging='mkdir -p '${staging}'';

	# test if the staging directory exists
	:tasks.deploy.out.info "${executables[ssh]} %s %s" \
		"${host}" "${test_staging}";
	local exists=0;
	if ! $noop; then
		exists=$( "${executables[ssh]}" "${host}" ""${test_staging}"" );
	fi

	# create remote staging directory if it does not exist
	if [ $exists -gt 0 ]; then
		:tasks.deploy.out.info "${executables[ssh]} %s %s" \
			"${host}" "${mk_staging}";
		if ! $noop; then
			( "${executables[ssh]}" "${host}" ""${mk_staging}"" ) \
				|| :tasks.deploy.fail \
				"could not create remote staging directory %s" \
				"${staging}";
		fi
	fi

	local remote="${host}:${staging}/${script_name}";
	:tasks.deploy.out.info "scp -p %s %s" \
		"${script}" "${remote}";
	if ! $noop; then
		echo "SCP SCRIPT";
	fi	
}

# failure
:tasks.deploy.fail() {
	:tasks.deploy.complete.notify;
	if [ $# -gt 0 ]; then
		console.error "$@";
	fi
	console.quit 1 "deploy %s failed %s" \
			"${deploy_name}" "${characters[cross]}";
}

# attempts to notify via `growlnotify` when available
:tasks.deploy.complete.notify() {
	
	# don't send growl notifications for
	# json dumps or noop
	if $noop; then
		return 0;
	fi
	
	if [ -n "${executables[growlnotify]}" ]; then
		local message;
		local priority="${2:-Normal}";
		if $success; then
			message="${messages[success]}";
		else
			priority="Emergency";
			message="${messages[fail]}";
		fi
		"${executables[growlnotify]}" -m "$message" --priority "$priority";
	fi
}

# output the complete message
:tasks.deploy.complete() {
	
	# noop should always succeed
	if $noop; then
		success=true;
	fi
	
	# output success information
	if $success; then
		:tasks.deploy.complete.notify;
		if $dump_json || $dump_script; then
			console.success;
		else
			console.success "deploy %s complete %s" \
				"${deploy_name}" "${characters[tick]}";
		fi
	else
		:tasks.deploy.fail;
	fi
}

# validate a name follows the convention
:tasks.name.valid?() {
	local name="${1:-}";
	# may not start with a hyphen
	# and must match the name regex
	if [[ "$name" =~ ^-+ ]] || [[ ! "$name" =~ $re ]]; then
		return 1;
	fi
	return 0;
}

# quit if an invalid name is encountered
:tasks.name.quit() {
	local var="$1";
	local value="$2";
	console.error "names may not start with a hyphen and must match %s" "$re";	
	console.error "invalid $var name %s" "$value";
	console.quit 1;
}

# parse options
:tasks.deploy.options.parse() {
	local value ;
	while test -n "${1:-}"; do
		case $1 in
			--noop )
				noop=true;
				;;
			--staging )
				shift;
				staging="${1:-}";
				;;
			--local )
				deploy_local=true;
				;;
			--json )
				dump_json=true;
				noop=true;
				dump_script=false;				
				;;
			--write-json )
				write_json=true;
				;;
			--script )
				dump_script=true;
				noop=true;
				dump_json=false;
				;;
			--pretty )
				pretty=true;
				;;
			--expand )
				quote=false;
				;;
			--flat )
				flat=true;
				;;	
			--include-version )
				include_version=true;
				;;
			--no-local )
				skip["local.pre"]=true;
				skip["local.post"]=true;
				;;
			--no-local-pre )
				skip["local.pre"]=true;
				;;
			--no-local-post )
				skip["local.post"]=true;
				;;
			--no-remote )
				skip["remote.pre"]=true;
				skip["remote.post"]=true;
				;;
			--no-remote-pre )
				skip["remote.pre"]=true;
				;;
			--no-remote-post )
				skip["remote.post"]=true;
				;;
			--log )
				logging=true;
				;;
			--shell )
				shift;
				value="${1:-}";
				if [ -z "${value}" ]; then
					console.quit 1 "no shell specified";
				fi
				shell="${value}";
				;;
			--name )
				shift;
				value="${1:-}";
				if [ -z "${value}" ]; then
					console.quit 1 "no name specified";
				fi
				if ! :tasks.name.valid? "${value}"; then
					:tasks.name.quit "project" "$value";
				fi
				project_name="${value}";
				;;
			--directory )
				shift;
				value="${1:-}";
				if [ -z "${value}" ]; then
					console.quit 1 "no directory specified";
				fi
				overrides[directory]="${value}";
				;;
			--host )
				shift;
				value="${1:-}";
				if [ -z "${value}" ]; then
					console.quit 1 "no host specified";
				fi
				overrides[host]="${value}";
				;;
			--descriptor )
				shift;
				value="${1:-}";
				if [ -z "${value}" ]; then
					console.quit 1 "no descriptor specified";
				fi
				descriptor="${value}";		
				;;
			-* | --* )
				console.quit 1 "unknown option %s" "$1";
				;;
			* )
				if ! :tasks.name.valid? "$1"; then
					:tasks.name.quit "profile" "$1";
				fi
				profiles+=( "$1" );
				;;
		esac
		shift;
	done
}