# script generation commands for task-deploy(7)

# write out the script file
:tasks.deploy.script.write!() {
	# delete any existing deploy script
	if [ -f "${script}" ]; then
		rm "${script}" \
			|| :tasks.deploy.fail "could not delete %s" "${script}";
	fi

	touch "${script}" \
		|| :tasks.deploy.fail "could not create %s" "${script}";
		
	# target parent directory and final name
	local deploy_parent deploy_final_name;
	fs.dirname "${deploy_target}" "deploy_parent";
	fs.basename "${deploy_target}" "deploy_final_name";
	
	# echo "got package: $package : $npm_package_name : $npm_package_version";
	# exit 0;
	
	# NOTE: there is still a race condition albeit
	# NOTE: highly unlikely in a real world scenario
	# timestamp has to be done here
	# otherwise tilde ~ expansion will not work	
	local timestamp=$( date +%s );
	local creator_host=$( uname -a | fmt );

	# setup a deployment staging sandbox
	local sandbox="${staging}/${deploy_file_name}-${profile}-${timestamp}";
		
	# escape spaces in paths
	printf -v staging "%q" "${staging}";
	printf -v log_file "%q" "${log_file}";
	printf -v log_dir "%q" "${log_dir}";
	printf -v deploy_target "%q" "${deploy_target}";
	printf -v directory "%q" "${directory}";
	printf -v sandbox "%q" "${sandbox}";
	
	# custom script file specified
	if [ -n "${script_source}" ]; then
		cat "${script_source}" >| "${script}";
	else
		:tasks.deploy.script.header.write!;
		:tasks.deploy.script.common.write!;
		
		# we've already validated on deployment type
		# this is an additional sanity check
		local method=":tasks.deploy.script.${type}.write!"		
		if ! method.exists? "$method"; then
			:tasks.deploy.fail "unsupported type %s" "${type}";
		fi
		
		# call the deployment type specific
		# script write command
		$method;
		
		:tasks.deploy.script.footer.write!;
	fi

	chmod +x "${script}" \
		|| :tasks.deploy.fail "could not set permissions on %s" "${script}";	
	if $dump_script; then
		cat "${script}";
	fi
}

# run script through *checkbashisms*
:tasks.deploy.script.lint() {
	executable.validate checkbashisms;
	
	console.info "lint %s" "${script}";
	
	local valid=1;
	# utility to verify the script is not bash only
	checkbashisms "${script}";
	valid=$?;
	if [ $valid -eq 0 ]; then
 		console.info "lint %s %s" "$script" "${characters[tick]}";
		# run script (locally) from target
		# staging directory, used for testing and debugging
		if $run_script; then
			local exit_code=1;
			console.info "exec %s" "${script}";
			# make the working directory
			# the bundle source directory
			cd "${bundle_source}";
			"${script}";
			exit_code=$?;
			console.info "%s exited with %s" "${script}" "${exit_code}";
			exit $exit_code;
		fi
	else
 		:tasks.deploy.fail "lint %s %s" "$script" "${characters[cross]}";
	fi
	console.success;
}

# write the script header
:tasks.deploy.script.header.write!() {
cat <<EOF >> "${script}"
${shebang}

# generated by task-deploy(7)
# do not edit this file manually
# use bake(1) with task-deploy(7)

# date: $( date )
# script: ${script_name}
# file: ${script}
# name: ${project_name}
# version: ${project_version}
# profile: ${profile}
# type: ${type}
# local: ${deploy_local}
# flat: ${flat}
# include version: ${include_version}
# staging: ${staging}
# directory: ${directory}
# target: ${deploy_target}

set -e;
set -u;

# global variables
header="${header}";
success=false;
start_time=\$( date );
profile="${profile}";
noop="${noop}";
shell="${shell}";
script_source="${script_source}";
script="${script}";
description="${description:-}";
host="${host}";
deploy_name="${deploy_name}";
deploy_final_name="${deploy_final_name}";
deploy_type="${type}";
timestamp="${timestamp}";
creator="${creator}";
creator_host="${creator_host}";

project_name="${project_name}";
project_version="${project_version}";
deploy_file_name="${deploy_file_name}";

# NOTE: directories and files are literal
# NOTE: to allow tilde ~ expansion
sandbox=${sandbox}-\$\$;
backup=\${sandbox}/backup;
log_dir=${log_dir};
log_file=${log_file};
directory=${directory};
staging=${staging};
deploy_target=${deploy_target};
deploy_parent=${deploy_parent};

# clean temporary files
cleanup() {
	# attempt to rollback on exit if the deployment failed
	if ! \$success && test -d \${backup}; then
		rollback;
	fi
	
	if test -d \$sandbox; then
		info "rm -rfv %s\n" "\$sandbox";
		rm -rfv \$sandbox >> \$log_file 2>&1;
	fi
}

trap 'cleanup' EXIT HUP INT QUIT TERM

EOF
}

# write the script commands shared by all
# deployment types
:tasks.deploy.script.common.write!() {
cat <<EOF >> "${script}"

# completed successfully
complete() {
	success=true;
	exit 0;
}

# quit on failure
quit() {
	if [ $# -gt 0 ]; then
		printf "\$@";
	fi
	exit 1;
}

# info message
info() {
	printf "\$@";
}

# print delimiter
delimiter() {
	printf "\${header}\n";
}

# set up the log file
log() {
	# create the log directory
	if ! test -d $log_dir; then
		mkdir -p $log_dir \\
			|| { quit "could not create %s\n" "\$log_dir"; }
	fi
	if test -f $log_file; then
		rm $log_file \\
			|| { quit "could not remove log file %s\n" "\$log_file"; }
	fi
	touch $log_file \\
		|| { quit "could not create log file %s\n" "\$log_file"; }
}

# create a backup that we roll back to on failure
backup() {
	info "backup %s\n" "\${deploy_target}";	
	info "mv %s %s\n" "\${deploy_target}" "\${backup}";
	mv \${deploy_target} \${backup} \\
		|| quit "could not create backup %s from %s\n" "\$backup" "\$deploy_target";
}

# rollback from the backup on error whenever possible
# if there is any presence of the target directory it is removed
rollback() {
	info "rollback %s\n" "\${deploy_target}";
	
	# backup exists but target also exists
	# possible partial deployment so remove the deploy target
	# prior to restoring from a backup, this gives the rollback
	# the best change of succeeding on a failed partial deployment
	if test -d \${backup} && test -d \${deploy_target}; then
		info "rm -rfv %s\n" "\${deploy_target}";
		rm -rfv \${deploy_target} >> \$log_file 2>&1;
	fi
	
	info "mv %s %s\n" "\${backup}" "\${deploy_target}";	
	mv \${backup} \${deploy_target} \\
		|| quit "could not rollback %s from %s\n" "\$deploy_target" "\$backup";
}

# setup the directory structure
setup() {
	# create the parent directory
	if ! test -d \$deploy_parent; then
		info "mkdir -p %s\n" "\${deploy_parent}";
		mkdir -p \$deploy_parent \\
			|| { quit "could not create %s\n" "\$deploy_parent"; }
	fi
	
	# create the sandbox
	if ! test -d \$sandbox; then
		info "mkdir -p %s\n" "\${sandbox}";
		mkdir -p \$sandbox \\
			|| { quit "could not create %s\n" "\$sandbox"; }
	fi
	
	# if the target exist, move to a backup
	if test -d \$deploy_target; then
		backup;
	fi
}

# print the settings
settings() {
	delimiter;
	info "%s (%s)\n" "\${deploy_name}" "\${creator}";
	delimiter;
	info "%s\n" "\${start_time}";
	delimiter;	
	if test -n "\${description:-}"; then
		info "%s\n" "\${description}";
	fi
	delimiter;	
	info "%s\n" "\${creator_host}";
	delimiter;
	info "info\n";
	delimiter;
	info "host: %s\n" "\${host}";	
	info "timestamp: %s\n" "\${timestamp}";
	info "pid: %s\n" "\$\$";
	info "profile: %s\n" "\${profile}";
	info "type: %s\n" "\${deploy_type}";
	info "noop: %s\n" "\${noop}";
	info "shell: %s\n" "\${shell}";
	delimiter;
	info "paths\n";
	delimiter;	
	info "directory: %s\n" "\${directory}";
	info "staging: %s\n" "\${staging}";	
	info "sandbox: %s\n" "\${sandbox}";	
	info "script: %s\n" "\${script}";
	info "log file: %s\n" "\${log_file}";
	delimiter;
	info "start ($type) %s\n" "`date`";
	delimiter;	
	info "\n";
	info "\t%s\n" "\${deploy_target}";
	info "\n";
	delimiter;
}

EOF
}

# :tasks.deploy.out.info "git url %s" "${git_url}";
# :tasks.deploy.out.info "git branch %s" "${git_branch}";

# git specific commands
:tasks.deploy.script.git.write!() {
cat <<EOF >> "${script}"
git_url="${git_url}";
git_ref="${git_ref}";
git_remote="${git_remote}";
deploy() {
	info "git remote %s\n" "\$git_remote";
	info "git ref %s\n" "\$git_ref";
	info "git url %s\n" "\$git_url";
	echo "deploy git ! \$git_url : \$git_ref : \$git_remote";
	

}
EOF
}

# tar specific commands
:tasks.deploy.script.tar.write!() {
cat <<EOF >> "${script}"
deploy() {
	echo "deploy tar !";
}
EOF
}

# npm specific commands
:tasks.deploy.script.npm.write!() {	
cat <<EOF >> "${script}"
npm_package_name="${npm_package_name}";
npm_package_version="${npm_package_version}";
npm_install_target="./node_modules/\$npm_package_name";
npm_install_final="./node_modules/\$deploy_final_name";
deploy() {
	info "npm name %s\n" "\$npm_package_name";
	info "npm version %s\n" "\$npm_package_version";
	# now perform the npm installation
	npm install >> \$log_file 2>&1 \\
		&& mv \$npm_install_target \$npm_install_final \\
		&& mv \$npm_install_final \$deploy_parent \\
		&& complete;
}

EOF
}

# write the script footer
:tasks.deploy.script.footer.write!() {
cat <<EOF >> "${script}"
# check for an executable that
# matches the deployment type
binary=\$( command -v "$type" );
if [ -z "\$binary" ]; then
	quit "%s is not installed\n" "\$binary";
fi

init() {
	log;
	# info command is available
	# after calling *log*
	setup;
}

start() {	
	settings;
	init;
	deploy;
	
	# assume failure, the deploy command
	# must explicitly exit 0
	quit;
}
start "\$@";
EOF
}