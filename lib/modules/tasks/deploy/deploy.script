# script generation commands for task-deploy(7)

# write out the script file
:tasks.deploy.script.write!() {
	# delete any existing deploy script
	if [ -f "${script}" ]; then
		rm "${script}" \
			|| :tasks.deploy.fail "could not delete %s" "${script}";
	fi

	touch "${script}" \
		|| :tasks.deploy.fail "could not create %s" "${script}";
		
	# target parent directory and final name
	local deploy_parent deploy_final_name;
	fs.dirname "${deploy_target}" "deploy_parent";
	fs.basename "${deploy_target}" "deploy_final_name";
	
	local creator="${deploy_user}@${deploy_local_host_name}";
	
	# echo "got package: $package : $npm_package_name : $npm_package_version";
	# exit 0;
	
	# NOTE: there is still a race condition albeit
	# NOTE: highly unlikely in a real world scenario
	# timestamp has to be done here
	# otherwise tilde ~ expansion will not work	
	local timestamp=$( date +%s );

	# setup a deployment staging sandbox
	local sandbox="${staging}/${deploy_file_name}-${profile}-${timestamp}";
	
	# where a npm package.json file would be written
	local npm_package_file="${sandbox}/package.json";
		
	# escape spaces in paths
	printf -v staging "%q" "${staging}";
	printf -v log_file "%q" "${log_file}";
	printf -v log_dir "%q" "${log_dir}";
	printf -v deploy_target "%q" "${deploy_target}";
	printf -v directory "%q" "${directory}";
	printf -v sandbox "%q" "${sandbox}";
	printf -v npm_package_file "%q" "${npm_package_file}";
	
	# custom script file specified
	if [ -n "${script_source}" ]; then
		cat "${script_source}" >| "${script}";
	else
		:tasks.deploy.script.header.write!;
		:tasks.deploy.script.common.write!;
		
		# we've already validated on deployment type
		# this is an additional sanity check
		local method=":tasks.deploy.script.${type}.write!"		
		if ! method.exists? "$method"; then
			:tasks.deploy.fail "unsupported type %s" "${type}";
		fi
		
		# call the deployment type specific
		# script write command
		$method;
		
		:tasks.deploy.script.footer.write!;
	fi

	chmod +x "${script}" \
		|| :tasks.deploy.fail "could not set permissions on %s" "${script}";	
	if $dump_script; then
		cat "${script}";
	fi
}

# run script through *checkbashisms*
:tasks.deploy.script.lint() {
	executable.validate checkbashisms;
	
	console.info "lint %s" "${script}";
	
	local valid=1;
	# utility to verify the script is not bash only
	checkbashisms "${script}";
	valid=$?;
	if [ $valid -eq 0 ]; then
 		console.info "lint %s %s" "$script" "${characters[tick]}";
		# run script (locally) from target
		# staging directory, used for testing and debugging
		if $run_script; then
			local exit_code=1;
			console.info "exec %s" "${script}";
			"${script}";
			exit_code=$?;
			console.info "%s exited with %s" "${script}" "${exit_code}";
			exit $exit_code;
		fi
	else
 		:tasks.deploy.fail "lint %s %s" "$script" "${characters[cross]}";
	fi
	console.success;
}

# write the script header
:tasks.deploy.script.header.write!() {
cat <<EOF >> "${script}"
${shebang}

# generated by task-deploy(7)
# do not edit this file manually
# use bake(1) with task-deploy(7)

# date: $( date )
# script: ${script_name}
# file: ${script}
# name: ${project_name}
# description: ${description}
# version: ${project_version}
# profile: ${profile}
# type: ${type}
# local: ${deploy_local}
# flat: ${flat}
# include version: ${include_version}
# staging: ${staging}
# directory: ${directory}
# target: ${deploy_target}

set -e;
set -u;

# global variables
success=false; export success;
start_time=\$( date ); export start_time;
profile="${profile}"; export profile;
noop="${noop}"; export noop;
shell="${shell}"; export shell;
script_source="${script_source}"; export script_source;
script="${script}"; export script;
description="${description}"; export description;
host="${host}"; export host;
deploy_name="${deploy_name}"; export deploy_name;
deploy_final_name="${deploy_final_name}"; export deploy_final_name;
deploy_type="${type}"; export deploy_type;
timestamp="${timestamp}"; export timestamp;
creator="${creator}"; export creator;

project_name="${project_name}"; export project_name;
project_version="${project_version}"; export project_version;
deploy_file_name="${deploy_file_name}"; export deploy_file_name;

# NOTE: directories and files are literal
# NOTE: to allow tilde ~ expansion
sandbox=${sandbox}-\$\$; export sandbox;
backup=\${sandbox}/backup; export backup;
log_dir=${log_dir}; export log_dir;
log_file=${log_file}; export log_file;
directory=${directory}; export directory;
staging=${staging}; export staging;
deploy_target=${deploy_target}; export deploy_target;
deploy_parent=${deploy_parent}; export deploy_parent;

# clean temporary files
cleanup() {
	if test -d \$sandbox; then
		info "rm -rfv %s\n" "\$sandbox";
		# rm -rfv \$sandbox >> \$log_file 2>&1;
	fi
}

trap 'cleanup' EXIT HUP INT QUIT TERM

EOF
}

# write the script commands shared by all
# deployment types
:tasks.deploy.script.common.write!() {
cat <<EOF >> "${script}"

# completed successfully
complete() {
	sucess=true;
	exit 0;
}

# quit on failure
quit() {
	if [ $# -gt 0 ]; then
		printf "\$@";
	fi
	exit 1;
}

# info message
info() {
	printf "\$@";
}

# set up the log file
log() {
	# create the log directory
	if ! test -d $log_dir; then
		mkdir -p $log_dir \\
			|| { quit "could not create %s\n" "\$log_dir"; }
	fi
	if test -f $log_file; then
		rm $log_file \\
			|| { quit "could not remove log file %s\n" "\$log_file"; }
	fi
	touch $log_file \\
		|| { quit "could not create log file %s\n" "\$log_file"; }
}

# create a backup that we roll back to on failure
backup() {
	info "mv %s %s\n" "\${deploy_target}" "\${backup}";
	mv \${deploy_target} \${backup} \\
		|| quit "could not create backup %s from %s\n" "\$backup" "\$deploy_target";
}

# setup the directory structure
setup() {
	# create the parent directory
	if ! test -d \$deploy_parent; then
		info "mkdir -p %s\n" "\${deploy_parent}";
		mkdir -p \$deploy_parent \\
			|| { quit "could not create %s\n" "\$deploy_parent"; }
	fi
	
	# create the sandbox
	if ! test -d \$sandbox; then
		info "mkdir -p %s\n" "\${sandbox}";
		mkdir -p \$sandbox \\
			|| { quit "could not create %s\n" "\$sandbox"; }
	fi
	
	# if the target exist, move to a backup
	if test -d \$deploy_target; then
		backup;
	fi
}

# print the settings
settings() {
	info "deploy %s\n" "\${deploy_name}";
	if test -n "\${description:-}"; then
		info "description %s\n" "\${description}";
	fi	
	info "creator %s\n" "\${creator}";
	info "date %s\n" "\${start_time}";
	info "timestamp %s\n" "\${timestamp}";
	info "sandbox %s\n" "\${sandbox}";
	info "profile %s\n" "\${profile}";
	info "type %s\n" "\${deploy_type}";
	info "noop %s\n" "\${noop}";
	info "shell %s\n" "\${shell}";
	info "script %s\n" "\${script}";
	info "directory %s\n" "\${directory}";
	info "staging %s\n" "\${staging}";
	info "target %s\n" "\${deploy_target}";
	info "log file %s\n" "\${log_file}";
	info "host %s\n" "\${host}";
}

EOF
}

# :tasks.deploy.out.info "git url %s" "${git_url}";
# :tasks.deploy.out.info "git branch %s" "${git_branch}";

# git specific commands
:tasks.deploy.script.git.write!() {
cat <<EOF >> "${script}"
deploy() {
	echo "deploy git !";
}
EOF
}

# tar specific commands
:tasks.deploy.script.tar.write!() {
cat <<EOF >> "${script}"
deploy() {
	echo "deploy tar !";
}
EOF
}

# npm specific commands
:tasks.deploy.script.npm.write!() {	
cat <<EOF >> "${script}"
npm_package_name="${npm_package_name}"; export npm_package_name;
npm_package_version="${npm_package_version}"; export npm_package_version;
npm_package_file=\${sandbox}/package.json; export npm_package_file;
npm_install_target="\${sandbox}/node_modules/$npm_package_name"; export npm_install_target;
npm_install_final="\${sandbox}/node_modules/$deploy_final_name"; export npm_install_final;
deploy() {
	info "npm name %s\n" "\$npm_package_name";
	info "npm version %s\n" "\$npm_package_version";
	info "npm package %s\n" "\$npm_package_file";
	touch \${npm_package_file} \\
		|| { quit "could not create %s\n" "\$npm_package_file"; }
cat <<NPMPKG >> \${npm_package_file}
{
	"name": "${project_name}-${profile}-deploy",
	"version": "0.0.1",	
	"private": "true",
	"dependencies": {
		"$npm_package_name": "${npm_package_version:-*}"
	}
}
NPMPKG

	# now perform the npm installation in the sandbox
	(
		{ cd \${sandbox} \\
			&& npm install >> \$log_file 2>&1 \\
			&& mv \$npm_install_target \$npm_install_final \\
			&& mv \$npm_install_final \$deploy_parent; } \\
		|| false;
		if [ $? -eq 0 ]; then
			# if we made it this far everything is ok
			complete;
		fi
	)
}

EOF
}

# write the script footer
:tasks.deploy.script.footer.write!() {
cat <<EOF >> "${script}"
# check for an executable that
# matches the deployment type
binary=\$( command -v "$type" );
if [ -z "\$binary" ]; then
	quit "%s is not installed\n" "\$binary";
fi

init() {
	log;
	# info command is available
	# after calling *log*
	setup;
}

start() {	
	settings;
	init;
	deploy;
	
	# assume failure, the deploy command
	# must explicitly exit 0
	quit;
}
start "\$@";
EOF
}