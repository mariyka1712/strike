# script generation commands for task-deploy(7)

# write out the script file
:tasks.deploy.script.write!() {
	# delete any existing deploy script
	if [ -f "${script}" ]; then
		rm "${script}" \
			|| :tasks.deploy.fail "could not delete %s" "${script}";
	fi

	touch "${script}" \
		|| :tasks.deploy.fail "could not create %s" "${script}";
		
	# TODO: add list of compression executables and custom binary
	# TODO: dependencies to validate
		
	# target parent directory and final name
	local deploy_parent deploy_final_name;
	fs.dirname "${deploy_target}" "deploy_parent";
	fs.basename "${deploy_target}" "deploy_final_name";
		
	# escape spaces in paths
	printf -v log_file "%q" "${log_file}";
	printf -v log_dir "%q" "${log_dir}";
	printf -v deploy_target "%q" "${deploy_target}";
	
	# custom script file specified
	if [ -n "${sources[script]}" ]; then
		cat "${sources[script]}" >| "${script}";
	else
		:tasks.deploy.script.header.write!;
		
		# calculate if there are remote
		# commands to execute
		local script_commands_global_pre="${global_commands[commands.remote.pre.length]:-0}";
		local script_commands_global_post="${global_commands[commands.remote.post.length]:-0}";
		local script_commands_profile_pre="${profile_commands[commands.remote.pre.length]:-0}";
		local script_commands_profile_post="${profile_commands[commands.remote.post.length]:-0}";
		local script_commands_pre=$(($script_commands_global_pre+$script_commands_profile_pre));
		local script_commands_post=$(($script_commands_global_post+$script_commands_profile_post));
		
		# echo "creating script with: $script_commands_global_pre";
		# echo "creating script with: $script_commands_global_post";	
		# echo "creating script with: $script_commands_profile_pre";
		# echo "creating script with: $script_commands_profile_post";
		
		# write pre/post commands
		:tasks.deploy.script.commands.write "pre";
		:tasks.deploy.script.commands.write "post";
		
		:tasks.deploy.script.common.write!;
		
		:tasks.deploy.script.directories.write!;
		
		# we've already validated on deployment type
		# this is an additional sanity check
		local method=":tasks.deploy.script.${type}.write!"		
		if ! method.exists? "$method"; then
			:tasks.deploy.fail "unsupported type %s" "${type}";
		fi
		
		# call the deployment type specific
		# script write command
		$method;
		
		:tasks.deploy.script.footer.write!;
	fi

	chmod +x "${script}" \
		|| :tasks.deploy.fail "could not set permissions on %s" "${script}";	
	if $dump_script; then
		cat "${script}";
	fi
}

# run script through *checkbashisms*
:tasks.deploy.script.lint() {
	executable.validate checkbashisms;
	
	:tasks.deploy.out.info "lint %s" "${script}";
	
	local valid=1;
	# utility to verify the script is not bash only
	checkbashisms "${script}";
	valid=$?;
	if [ $valid -eq 0 ]; then
 		:tasks.deploy.out.info "lint %s %s" "$script" "${characters[tick]}";
		# run script (locally) from target
		# staging directory, used for testing and debugging
		if $run_script; then
			local exit_code=1;
			:tasks.deploy.out.info "exec %s" "${script}";
			# make the working directory
			# the bundle source directory
			cd "${bundle_source}";
			"${script}";
			exit_code=$?;
			:tasks.deploy.out.info "%s exit code (%s)" "`basename "${script}"`" "${exit_code}";
			if [ $exit_code -gt 0 ]; then
				:tasks.deploy.fail "%s failed" "${script}";
			fi
			:tasks.deploy.complete;
		fi
	else
 		:tasks.deploy.fail "lint %s %s" "$script" "${characters[cross]}";
	fi
	# don't call complete as we are just
	# verifying the script, nothing was deployed
	console.success;
}

# write the script header
:tasks.deploy.script.header.write!() {
cat <<EOF >> "${script}"
${shebang}

# generated by task-deploy(7)
# do not edit this file manually
# use bake(1) with task-deploy(7)

# date: $( date )
# script: ${script_name}
# file: ${script}
# name: ${project_name}
# version: ${project_version}
# profile: ${profile}
# type: ${type}
# local: ${deploy_local}
# flat: ${flat}
# include version: ${include_version}
# staging: ${staging}
# directory: ${directory}
# target: ${deploy_target}

set -e;
set -u;

# global variables
platform=\$( uname | tr '[:upper:]' '[:lower:]' );
timestamp=\$( date +%s );
header="${header}";
success=false;
start_time=\$( date );
profile="${profile}";
type="${type}";
noop="${noop}";
shell="${shell}";
script="${script}";
description="${description:-}";
host="${host}";
deploy_name="${deploy_name}";
deploy_final_name="${deploy_final_name}";
deploy_type="${type}";
timestamp="${timestamp}";
creator="${creator}";
url="${url}";
creator_host="${creator_host}";

project_name="${project_name}";
project_version="${project_version}";
deploy_file_name="${deploy_file_name}";

# NOTE: directories and files are literal
# NOTE: to allow tilde ~ expansion
staging=${staging};

bundle_name="${bundle_name}";
bundle_archive="${bundle_archive}";
bundle_source="${bundle_source}";
bundle_path="${bundle_path}";
bundle_destination="\${staging}/\${bundle_name}";

log_dir=${log_dir};
log_file=${log_file};
directory=${directory};
deploy_target=${deploy_target};
deploy_parent=${deploy_parent};

# NOTE: there is still a race condition albeit
# NOTE: highly unlikely in a real world scenario
# staging should have tilde expansion done
sandbox=\${staging}/\${deploy_file_name}-\${profile}-\${timestamp}-\$\$;
backup=\${sandbox}/backup;

# ls -la .; pwd; exit 0;

# clean temporary files
cleanup() {
	# attempt to rollback on exit if the deployment failed
	if ! \$success; then
		rollback;
	fi
	
	# debug
	# cat \$log_file;
	
	# TODO: test this logic
	if test -f \$sandbox/npm-debug.log; then
		cat \$sandbox/npm-debug.log >> \$log_file;
	fi
	
	if test -d \$sandbox; then
		delimiter;
		info "clean %s\n" "\$sandbox";
		delimiter;
		info "rm -rfv %s\n" "\$sandbox";
		rm -rfv \$sandbox >> \$log_file 2>&1;
		delimiter;
	fi
}

trap 'cleanup' EXIT HUP INT QUIT TERM

EOF
}

# write the command used to create directories
# post-deployment
:tasks.deploy.script.directories.write!() {
# open command
cat <<EOF >> "${script}"
directories() {
EOF

	local globals="${json_doc[bundle.dirs.length]:-0}";
	local profiles="${json_doc[profiles.${profile}.bundle.dirs.length]:-0}";
	local total=$(($globals+$profiles));
	
	# no directories to write out
	if [ $total -eq 0 ]; then
cat <<EOF >> "${script}"
	info "no directories to create\n";
EOF
	else
		
cat <<EOF >> "${script}"
	# ensure context is correct for creating dirs
	if test -d \$deploy_target; then
		cd "\$deploy_target";
EOF
		:tasks.deploy.script.directories.group.write! $globals "bundle.dirs";
		:tasks.deploy.script.directories.group.write! $profiles "profiles.${profile}.bundle.dirs";
cat <<EOF >> "${script}"
	fi
EOF
	fi

# close command
cat <<EOF >> "${script}"
}

EOF
}

:tasks.deploy.script.directories.group.write!() {
	local length="$1";
	local prefix="$2";
	local i k path perm;
	for((i = 0;i < $length;i++))
		do
			k="${prefix}.$i";
			path="${json_doc[${k}.path]:-}";
			perm="${json_doc[${k}.perm]:-}";
			if [ -z "${path:-}" ]; then
				:tasks.deploy.fail "empty path for directory %s" "$k";
			fi
			
cat <<EOF >> "${script}"
		if ! test -d $path; then
			info "mkdir -p %s\n" "$path";
			mkdir -p $path \\
				|| quit "could not create directory %s\n" "$path";
EOF

			if [ -n "$perm" ]; then
cat <<EOF >> "${script}"
			info "chmod %s %s\n" "$perm" "$path";
			chmod $perm $path \\
				|| quit "could not set permissions %s on %s\n" "$perm" "$path";
EOF
			fi
cat <<EOF >> "${script}"
		fi
EOF
	done
	
# cat <<EOF >> "${script}"
# 
# EOF
}

# write pre / post deployment commands
:tasks.deploy.script.commands.write() {
	local phase="$1";
	
	# echo "writing remote commands for phase ... $phase";
	
	if ! ${skip[remote.${phase}]} && [ "$phase" == pre ] \
		&& [ $script_commands_pre -gt 0 ]; then
# open command
cat <<EOF >> "${script}"
pre() {
	# if we have a final target this is always the
	# working directory for remote pre-deployment commands
	if test -d \$deploy_target; then
		cd "\$deploy_target";
	# otherwise it's the sandbox
	else
		cd "\$sandbox";
	fi

	wd=\$( pwd );
	delimiter;
	info "exec pre-deployment commands ($script_commands_pre)\n";
	info "working directory \$wd\n";
	delimiter;
EOF
		:tasks.deploy.script.commands.embed;
# close command
cat <<EOF >> "${script}"

	cd \$owd;
	wd=\$( pwd );
	delimiter;	
	info "pre-deployment commands ($script_commands_pre) complete\n";
	info "working directory \$wd\n";
	delimiter;
}

EOF
	# no commands to execute
	elif [ "$phase" == pre ]; then
cat <<EOF >> "${script}"
pre() {
	info "no pre-deployment commands for %s\n" "\$profile";
}
EOF
	fi
		
	if ! ${skip[remote.${phase}]} && [ "$phase" == post ] \
		&& [ $script_commands_post -gt 0 ]; then
# open command
cat <<EOF >> "${script}"
post() {
	
	# if we have a final target this is always the
	# working directory for remote post-deployment commands
	if test -d \$deploy_target; then
		cd \$deploy_target;
	# we should always have the final target by this point
	else
		quit "cannot execute post-deployment commands, %s does not exist" "\$deploy_target";
	fi
	
	wd=\$( pwd );
	delimiter;		
	info "exec post-deployment commands ($script_commands_post)\n";
	info "working directory \$wd\n";
	delimiter;	
EOF
		:tasks.deploy.script.commands.embed;
# close command
cat <<EOF >> "${script}"

	cd \$owd;
	wd=\$( pwd );
	delimiter;	
	info "post-deployment commands ($script_commands_pre) complete\n";
	info "working directory \$wd\n";	
	delimiter;
}

EOF
	elif [ "$phase" == post ]; then
cat <<EOF >> "${script}"
post() {
	info "no post-deployment commands for %s\n" "\$profile";
}
EOF
	fi
}

# flatten a list of commands and write to script
:tasks.deploy.script.commands.embed() {
	#echo "flattening remote commands for ${!profile_commands[@]}";
	
	printf "\t" >> "${script}";
	local written=false;	
	local k v cmds re="^commands\.remote\.$phase\.[0-9]+";
	for k in ${!global_commands[@]}
		do
			if [[ ! "$k" =~ $re ]]; then
				continue;
			fi
			v="${global_commands[$k]}";
			:tasks.deploy.script.commands.embed.group;
	done
	for k in ${!profile_commands[@]}
		do
			#echo "testing profile command $k : $re"
			if [[ ! "$k" =~ $re ]]; then
				continue;
			fi
			v="${profile_commands[$k]}";
			:tasks.deploy.script.commands.embed.group;
	done
	# terminate command list
	printf ";" >> "${script}";
}

:tasks.deploy.script.commands.embed.group() {
	local cmd;
	local IFS=$newline;
	for cmd in "${v}"
		do			
			cmds=( $v );
			# echo "appending command ${cmds[@]}";
			if $written; then
				printf " \\" >> "${script}";	
				printf "\n\t&& " >> "${script}";
			fi
			local IFS=' ';
			printf "${cmds[*]}" >> "${script}";
			written=true;
	done
}

# write the script commands shared by all
# deployment types
:tasks.deploy.script.common.write!() {
cat <<EOF >> "${script}"
# completed successfully
complete() {
	# create directories
	directories;
	# run post-deployment commands
	post;
	success=true;
	exit 0;
}

# quit on failure
quit() {
	if [ $# -gt 0 ]; then
		printf "\$@";
	fi
	exit 1;
}

# info message
info() {
	printf "\$@";
}

# print delimiter
delimiter() {
	printf "\${header}\n";
}

# set up the log file
log() {
	# create the log directory
	if ! test -d $log_dir; then
		mkdir -p $log_dir \\
			|| { quit "could not create %s\n" "\$log_dir"; }
	fi
	if test -f $log_file; then
		rm $log_file \\
			|| { quit "could not remove log file %s\n" "\$log_file"; }
	fi
	touch $log_file \\
		|| { quit "could not create log file %s\n" "\$log_file"; }
}

# create a backup that we roll back to on failure
backup() {
	info "backup %s\n" "\${deploy_target}";	
	info "mv %s %s\n" "\${deploy_target}" "\${backup}";
	mv \${deploy_target} \${backup} \\
		|| quit "could not create backup %s from %s\n" "\$backup" "\$deploy_target";
}

# rollback from the backup on error whenever possible
# if there is any presence of the target directory it is removed
rollback() {
	# we have a git revision to rollback to
	if test -n \${git_revision_hash:-} && test -d \${deploy_target}/.git; then
		info "rollback (git) %s\n" "\${deploy_target}";
		cd \${deploy_target} && git reset \$git_revision_hash >> \$log_file 2>&1;
	# plain filesytem rollback
	elif test -d \${backup}; then
		info "rollback (fs) %s\n" "\${deploy_target}";
		# backup exists but target also exists
		# possible partial deployment so remove the deploy target
		# prior to restoring from a backup, this gives the rollback
		# the best change of succeeding on a failed partial deployment
		if test -d \${deploy_target}; then
			info "rm -rfv %s\n" "\${deploy_target}";
			rm -rfv \${deploy_target} >> \$log_file 2>&1;
		fi
	
		info "mv %s %s\n" "\${backup}" "\${deploy_target}";	
		mv \${backup} \${deploy_target} \\
			|| quit "could not rollback %s from %s\n" "\$deploy_target" "\$backup";
	fi
}

# setup the directory structure
setup() {
	# create the parent directory
	if ! test -d \$deploy_parent; then
		info "mkdir -p %s\n" "\${deploy_parent}";
		mkdir -p \$deploy_parent \\
			|| { quit "could not create %s\n" "\$deploy_parent"; }
	fi
	
	# create the sandbox
	if ! test -d \$sandbox; then
		info "mkdir -p %s\n" "\${sandbox}";
		mkdir -p \$sandbox \\
			|| { quit "could not create %s\n" "\$sandbox"; }
	fi
}

# create a filesystem backup using *mv*
fsbackup() {
	# if the target exist, move to a backup
	if test -d \$deploy_target && [ "\$type" != "git" ]; then
		backup;
	fi
}

# print the settings
settings() {
	delimiter;
	info "%s (%s) on %s\n" "\${deploy_name}" "\${creator}"  "\${platform}";
	delimiter;
	info "%s\n" "\${start_time}";
	delimiter;	
	if test -n "\${description:-}"; then
		info "%s\n" "\${description}";
	fi
	delimiter;	
	info "%s\n" "\${creator_host}";
	delimiter;	
	info "bundle\n";	
	delimiter;
	info "name: %s\n" "\${bundle_name}";
	info "archive: %s\n" "\${bundle_archive}";
	info "source: %s\n" "\${bundle_source}";
	info "path: %s\n" "\${bundle_path}";
	delimiter;	
	info "settings\n";
	delimiter;
	info "host: %s\n" "\${host}";
	info "profile: %s\n" "\${profile}";	
	info "type: %s\n" "\${deploy_type}";
	info "noop: %s\n" "\${noop}";
	info "shell: %s\n" "\${shell}";	
	info "timestamp: %s\n" "\${timestamp}";
	info "pid: %s\n" "\$\$";
	delimiter;
	info "paths\n";
	delimiter;	
	info "directory: %s\n" "\${directory}";
	info "staging: %s\n" "\${staging}";
	info "sandbox: %s\n" "\${sandbox}";
	info "script: %s\n" "\${script}";
	info "log file: %s\n" "\${log_file}";
	delimiter;
	info "start ($type) %s\n" "`date`";
	delimiter;
	info "\n";
	info "\t%s\n" "\${deploy_target}";
	info "\n";
	delimiter;
}

EOF
}

# git specific commands
:tasks.deploy.script.git.write!() {
cat <<EOF >> "${script}"
git_ref="${git_ref}";
git_remote="${git_remote}";
git_revision_hash="";
deploy() {
	info "git remote %s\n" "\$git_remote";
	info "git ref %s\n" "\$git_ref";
	info "git url %s\n" "\$url";
	
	#echo "deploy git ! \$url : \$git_ref : \$git_remote";
	
	# no target directory so try a clone
	if ! test -d \${deploy_target}; then
		# TODO: pull refspec after clone
		info "git clone --origin %s %s %s\n" "\${git_remote}" "\${url}" "\${deploy_final_name}";
		cd \${deploy_parent} \\
			&& git clone --origin \${git_remote} \${url} \${deploy_final_name} >> \$log_file 2>&1;
	# target directory exists, do an update
	# using pull
	else
		# target has a .git directory
		# treat as a git repo
		if test -d \${deploy_target}/.git; then
			git_revision_hash=\$( cd \${deploy_target} && git rev-parse --verify HEAD );
			
			# echo "target repository exists: \$git_revision_hash";
			
			# something went wrong getting the revision?
			# if test -z "${git_revision_hash:-}"; then
			# 	backup;
			# fi
			
			# try to pull to update
			info "git pull %s %s\n" "\${git_remote}" "\${git_ref}";
			cd \${deploy_target} \\
				&& git pull \${git_remote} \${git_ref} >> \$log_file 2>&1;
		# otherwise try a normal backup operation
		else
			backup;
		fi
	fi
	
	# TODO: checkout refspec !!!
	
	cd \$owd && complete;
}

EOF
}

# tar specific commands
:tasks.deploy.script.tar.write!() {
cat <<EOF >> "${script}"
deploy() {
	
	# are we completely replacing the target
	# with the archive contents, this is the case
	# if the archive contains only one file and 
	# that file is a directory, otherwise all contents
	# are copied into the target
	replace_target=false;
	file="";
	
	curl=$( command -v curl );
	if test -z \$curl; then
		quit "%s is not installed\n" "curl";
	fi
	
	info "mkdir download && cd download\n";
	mkdir download >> \$log_file 2>&1 \\
		&& cd download >> \$log_file 2>&1;
	info "curl -# -OL %s\n" "\$url";
	curl -# -OL "\$url" >> \$log_file 2>&1;
	
	file=\$( ls . );
	info "downloaded %s\n" "\$file";
	
	info "mkdir archive\n";
	mkdir archive >> \$log_file 2>&1;
	info "tar -xf %s -C ./archive\n" "\$file";
	tar -xf "\$file" -C ./archive;
	count=\$( ls ./archive | wc -l | tr -s " " );
	
	if [ "\${count}" -eq 1 ]; then
		file=\$( ls ./archive );
		if test -d ./archive/\$file; then
			replace_target=true;
			file="./archive/\$file";
		fi
	fi
	
	if \$replace_target && test -n "\$file"; then
		info "copy archive directory %s\n" "\$file";
		info "mv %s %s\n" "\$file" "\$deploy_target";
		mv "\$file" "\$deploy_target" >> \$log_file 2>&1;
	else
		info "copy archive contents %s\n" "./archive";
		info "mkdir -p %s\n" "\$deploy_target";
		mkdir -p "\$deploy_target" >> \$log_file 2>&1;
		info "cp ./archive/* %s\n" "\$deploy_target";
		cp -rfv ./archive/* "\$deploy_target" >> \$log_file 2>&1;
	fi
	
	cd \$owd && complete;
}

EOF
}

# npm specific commands
:tasks.deploy.script.npm.write!() {	
cat <<EOF >> "${script}"
npm_use_package="${npm_use_package}";
npm_package_name="${npm_package_name}";
npm_package_version="${npm_package_version}";
npm_install_target="./node_modules/\$npm_package_name";
npm_install_final="./node_modules/\$deploy_final_name";
deploy() {
	info "npm package %s\n" "\$bundle_destination/package.json";
	info "npm use package %s\n" "\$npm_use_package";
	info "npm name %s\n" "\$npm_package_name";
	info "npm version %s\n" "\$npm_package_version";
	if \$npm_use_package; then
		info "npm install\n" "\${url}";
	else
		info "npm install %s\n" "\${url}";
	fi
	# now perform the npm installation
	cd \$bundle_destination;
	if \$npm_use_package; then
		npm install >> \$log_file 2>&1;	
	else
		npm install \${url} >> \$log_file 2>&1;
	fi
	rm -rfv ./node_modules/.bin >> \$log_file 2>&1;
	npm_install_target=\$( ls ./node_modules );
	npm_install_target="./node_modules/\$npm_install_target";
	mv \$npm_install_target \$deploy_parent/\$deploy_final_name;
	cd \$owd && complete;
}

EOF
}

# write the script footer
:tasks.deploy.script.footer.write!() {
cat <<EOF >> "${script}"
# check for an executable that
# matches the deployment type
binary=\$( command -v "$type" );
if [ -z "\$binary" ]; then
	quit "%s is not installed\n" "\$binary";
fi

init() {
	log;
	# info command is available
	# after calling *log*
	setup;
}

start() {
	owd=\$( pwd );
	init;
	settings;
	# run pre-deployment commands
	pre;
	
	# filesystem backup must be done after invoking
	# any pre-deployment commands as pre-deployment
	# commands need to execute in the context of the final
	# directory for re-deployments
	fsbackup;
	
	# always start execution in the context of the sandbox
	info "cd %s\n" "\$sandbox";
	cd \$sandbox;
	
	# perform the deployment
	deploy;
	
	# assume failure, the deploy command
	# must explicitly invoke *complete*
	quit;
}
start "\$@";
EOF
}