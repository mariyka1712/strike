# script generation commands for task-deploy(7)

# write out the script file
:tasks.deploy.script.write!() {
	# delete any existing deploy script
	if [ -f "${script}" ]; then
		rm "${script}" \
			|| :tasks.deploy.fail "could not delete %s" "${script}";
	fi

	touch "${script}" \
		|| :tasks.deploy.fail "could not create %s" "${script}";
		
	# target parent directory and final name
	local deploy_parent deploy_final_name;
	fs.dirname "${deploy_target}" "deploy_parent";
	fs.basename "${deploy_target}" "deploy_final_name";
	
	local creator="${deploy_user}@${deploy_local_host_name}";
	
	# NOTE: there is still a race condition albeit
	# NOTE: highly unlikely in a real world scenario
	# timestamp has to be done here
	# otherwise tilde ~ expansion will not work	
	local timestamp=$( date +%s );

	# setup a deployment staging sandbox
	local sandbox="${staging}/${deploy_file_name}-${profile}-${timestamp}";
		
	# escape spaces in paths
	printf -v staging "%q" "${staging}";
	printf -v log_file "%q" "${log_file}";
	printf -v log_dir "%q" "${log_dir}";
	printf -v deploy_target "%q" "${deploy_target}";
	printf -v directory "%q" "${directory}";
	printf -v sandbox "%q" "${sandbox}";
	
	# custom script file specified
	if [ -n "${script_source}" ]; then
		cat "${script_source}" >| "${script}";
	else
		:tasks.deploy.script.header.write!;
		:tasks.deploy.script.common.write!;
		
		# we've already validated on deployment type
		# this is an additional sanity check
		local method=":tasks.deploy.script.${type}.write!"		
		if ! method.exists? "$method"; then
			:tasks.deploy.fail "unsupported type %s" "${type}";
		fi
		
		# call the deployment type specific
		# script write command
		$method;
		
		:tasks.deploy.script.footer.write!;
	fi

	chmod +x "${script}" \
		|| :tasks.deploy.fail "could not set permissions on %s" "${script}";	
	if $dump_script; then
		cat "${script}";
	fi
}

# run script through *checkbashisms*
:tasks.deploy.script.lint() {
	executable.validate checkbashisms;
	
	console.info "lint %s" "${script}";
	
	local valid=1;
	# utility to verify the script is not bash only
	checkbashisms "${script}";
	valid=$?;
	if [ $valid -eq 0 ]; then
 		console.info "lint %s %s" "$script" "${characters[tick]}";
		# run script (locally) from target
		# staging directory, used for testing and debugging
		if $run_script; then
			local exit_code=1;
			console.info "exec %s" "${script}";
			"${script}";
			exit_code=$?;
			console.info "%s exited with %s" "${script}" "${exit_code}";
			exit $exit_code;
		fi
	else
 		:tasks.deploy.fail "lint %s %s" "$script" "${characters[cross]}";
	fi
	console.success;
}

# write the script header
:tasks.deploy.script.header.write!() {
cat <<EOF >> "${script}"
${shebang}

# generated by task-deploy(7)
# do not edit this file manually
# use bake(1) with task-deploy(7)

# date: $( date )
# script: ${script_name}
# file: ${script}
# name: ${project_name}
# description: ${description}
# version: ${project_version}
# profile: ${profile}
# type: ${type}
# local: ${deploy_local}
# flat: ${flat}
# include version: ${include_version}
# staging: ${staging}
# directory: ${directory}
# target: ${deploy_target}

# NOTE: directories and files are literal
# NOTE: to allow tilde ~ expansion

set -e;
set -u;

# global variables
start_time=\$( date ); export start_time;
log_dir="${log_dir}"; export log_dir;
log_file="${log_file}"; export log_file;
profile="${profile}"; export profile;
noop="${noop}"; export noop;
shell="${shell}"; export shell;
script_source="${script_source}"; export script_source;
script="${script}"; export script;
directory="${directory}"; export directory;
staging="${staging}"; export staging;
description="${description}"; export description;
host="${host}"; export host;
deploy_name="${deploy_name}"; export deploy_name;
deploy_target="${deploy_target}"; export deploy_target;
deploy_parent="${deploy_parent}"; export deploy_parent;
deploy_final_name="${deploy_final_name}"; export deploy_final_name;
deploy_type="${type}"; export deploy_type;
timestamp="${timestamp}"; export timestamp;
sandbox="${sandbox}"; export sandbox;
creator="${creator}"; export creator;


# clean temporary files
cleanup() {
	if test -d $sandbox-\$\$; then
		info "rm -rfv %s\n" "$sandbox-\$\$";
		rm -rfv $sandbox-\$\$;
	fi
}

trap 'cleanup >/dev/null 2>&1' EXIT HUP INT QUIT TERM

EOF
}

# write the script commands shared by all
# deployment types
:tasks.deploy.script.common.write!() {
cat <<EOF >> "${script}"
# quit on failure
quit() {
	printf "\$@";
	exit 1;
}

# info message
info() {
	printf "\$@";
}

# set up the log file
log() {
	# create the log directory
	if ! test -d $log_dir; then
		mkdir -p $log_dir \\
			|| { quit "could not create %s\n" "\$log_dir"; }
	fi
	if test -f $log_file; then
		rm $log_file \\
			|| { quit "could not remove log file %s\n" "\$log_file"; }
	fi
	touch $log_file \\
		|| { quit "could not create log file %s\n" "\$log_file"; }
}

# setup the directory structure
setup() {
	# create the parent directory
	if ! test -d $deploy_parent; then
		info "mkdir -p %s\n" "\${deploy_parent}";
		mkdir -p $deploy_parent \\
			|| { quit "could not create %s\n" "\$deploy_parent"; }
	fi
	
	# create the sandbox
	if ! test -d $sandbox-\$\$; then
		info "mkdir -p %s\n" "\${sandbox}-\$\$";
		mkdir -p $sandbox-\$\$ \\
			|| { quit "could not create %s\n" "\$sandbox-\$\$"; }
	fi
}

# print the settings
settings() {
	info "deploy %s\n" "\${deploy_name}";
	if test -n "\${description:-}"; then
		info "description %s\n" "\${description}";
	fi	
	info "creator %s\n" "\${creator}";
	info "date %s\n" "\${start_time}";
	info "timestamp %s\n" "\${timestamp}";
	info "sandbox %s\n" "\${sandbox}-\$\$";
	info "profile %s\n" "\${profile}";
	info "type %s\n" "\${deploy_type}";
	info "noop %s\n" "\${noop}";
	info "shell %s\n" "\${shell}";
	info "script %s\n" "\${script}";
	info "directory %s\n" "\${directory}";
	info "staging %s\n" "\${staging}";
	info "target %s\n" "\${deploy_target}";
	info "log file %s\n" "\${log_file}";
	info "host %s\n" "\${host}";
}

EOF
}

# :tasks.deploy.out.info "git url %s" "${git_url}";
# :tasks.deploy.out.info "git branch %s" "${git_branch}";

# git specific commands
:tasks.deploy.script.git.write!() {
cat <<EOF >> "${script}"
deploy() {
	echo "deploy git !";
}
EOF
}

# tar specific commands
:tasks.deploy.script.tar.write!() {
cat <<EOF >> "${script}"
deploy() {
	echo "deploy tar !";
}
EOF
}

# npm specific commands
:tasks.deploy.script.npm.write!() {
cat <<EOF >> "${script}"
deploy() {
	echo "deploy npm !";
}
EOF
}

# write the script footer
:tasks.deploy.script.footer.write!() {
cat <<EOF >> "${script}"

# check for an executable that
# matches the deployment type
binary=\$( command -v "$type" );
if [ -z "\$binary" ]; then
	quit "%s is not installed\n" "\$binary";
fi

init() {
	log;
	# info command is available
	# after calling *log*
	setup;
}

start() {	
	settings;
	init;
	deploy;
}
start "\$@";
EOF
}