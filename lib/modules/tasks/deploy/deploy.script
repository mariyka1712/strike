# Script generation methods for task-deploy(7)

:tasks.deploy.script.write!() {
	# delete any existing deploy script
	if [ -f "${script}" ]; then
		rm "${script}" \
			|| :tasks.deploy.fail "could not delete %s" "${script}";
	fi

	touch "${script}" \
		|| :tasks.deploy.fail "could not create %s" "${script}";
		
	# escape spaces in paths
	printf -v staging "%q" "${staging}";
	printf -v log_file "%q" "${log_file}";
	printf -v log_dir "%q" "${log_dir}";
	printf -v deploy_target "%q" "${deploy_target}";
	
	#echo "after quoting : $staging";
	
	# custom script file specified
	if [ -n "${script_source}" ]; then
		cat "${script_source}" >| "${script}";
	else
		:tasks.deploy.script.header.write!;
		:tasks.deploy.script.common.write!;
		
		# we've already validated on deployment type
		# this is an additional sanity check
		local method=":tasks.deploy.script.${type}.write!"		
		if ! method.exists? "$method"; then
			:tasks.deploy.fail "unsupported type %s" "${type}";
		fi
		
		# call the deployment type specific
		# script write command
		$method;
		
		:tasks.deploy.script.footer.write!;
	fi

	chmod +x "${script}" \
		|| :tasks.deploy.fail "could not set permissions on %s" "${script}";	
	if $dump_script; then
		cat "${script}";
	fi
}

# run script through `checkbashisms`
:tasks.deploy.script.lint() {
	executable.validate checkbashisms;
	
	console.info "lint %s" "${script}";
	
	local valid=1;
	# utility to verify the script is not bash only
	checkbashisms "${script}";
	valid=$?;
	if [ $valid -eq 0 ]; then
 		console.info "lint %s %s" "$script" "${characters[tick]}";
		# run script (locally) from target
		# staging directory, used for testing and debugging
		if $run_script; then
			local exit_code=1;
			console.info "exec %s" "${script}";
			"${script}";
			exit_code=$?;
			console.info "%s exited with %s" "${script}" "${exit_code}";
			exit $exit_code;
		fi
	else
 		:tasks.deploy.fail "lint %s %s" "$script" "${characters[cross]}";
	fi
	console.success;
}

# write the script header
:tasks.deploy.script.header.write!() {
cat <<EOF >> "${script}"
${shebang}

# generated by task-deploy(7)
# do not edit this file manually
# use bake(1) with task-deploy(7)

# date: $( date )
# script: ${script_name}
# file: ${script}
# name: ${project_name}
# description: ${description}
# version: ${project_version}
# profile: ${profile}
# type: ${type}
# local: ${deploy_local}
# flat: ${flat}
# include version: ${include_version}
# staging: ${staging}
# directory: ${directory}
# target: ${deploy_target}

set +e;
set +u;

# global variables
start_time=\$( date ); export start_time;
log_dir="${log_dir}"; export log_dir;
log_file="${log_file}"; export log_file;
profile="${profile}"; export profile;
noop="${noop}"; export noop;
shell="${shell}"; export shell;
script_source="${script_source}"; export script_source;
script="${script}"; export script;
directory="${directory}"; export directory;
staging="${staging}"; export staging;
description="${description}"; export description;
host="${host}"; export host;
deploy_name="${deploy_name}"; export deploy_name;
deploy_target="${deploy_target}"; export deploy_target;
deploy_type="${type}"; export deploy_type;
EOF
}

# write the script commands shared by all
# deployment types
:tasks.deploy.script.common.write!() {
cat <<EOF >> "${script}"

# quit on failure
quit() {
	printf "\$@";
	exit 1;
}

# info message
info() {
	printf "\$@";
}

# set up the log file
log() {
	echo "log dir: $log_dir";
	echo "log file: $log_file";
	# NOTE: directories and files are literal
	# NOTE: to allow ~ expansion
	# create the log directory
	if ! test -d $log_dir; then
		mkdir -pv $log_dir \\
			|| { quit "could not create %s\n" "\$log_dir"; }
	fi
	if test -f $log_file; then
		rm -v $log_file \\
			|| { quit "could not remove log file %s\n" "\$log_file"; }
	fi
	touch $log_file \\
		|| { quit "could not create log file %s\n" "\$log_file"; }
}

# print the settings
settings() {
	info "date %s\n" "\${start_time}";
	info "deploy %s\n" "\${deploy_name}";
	if test -n "\${description:-}"; then
		info "description %s\n" "\${description}";
	fi
	info "profile %s\n" "\${profile}";
	info "type %s\n" "\${deploy_type}";
	info "noop %s\n" "\${noop}";
	info "shell %s\n" "\${shell}";
	info "script %s\n" "\${script}";
	info "working directory %s\n" "\${directory}";
	info "staging directory %s\n" "\${staging}";
	info "target %s\n" "\${deploy_target}";
	info "log file %s\n" "\${log_file}";
	info "host %s\n" "\${host}";
}

EOF
}

# :tasks.deploy.out.info "date %s" "${start_time}";
# :tasks.deploy.out.info "deploy %s" "${deploy_name}";
# if [ -n "${description:-}" ]; then
# 	:tasks.deploy.out.info "description %s" "${description}";
# fi
# :tasks.deploy.out.info "profile %s" "${profile}";
# :tasks.deploy.out.info "type %s" "${type}";
# :tasks.deploy.out.info "noop %s" "${noop}";
# :tasks.deploy.out.info "shell %s" "${shell}";
# # using custom script
# if [ -n "${script_source}" ]; then
# 	:tasks.deploy.out.info "source script %s" "${script_source}";
# fi		
# :tasks.deploy.out.info "script %s" "${script}";
# :tasks.deploy.out.info "working directory %s" "${directory}";
# :tasks.deploy.out.info "staging directory %s" "${staging}";
# :tasks.deploy.out.info "target %s" "${deploy_target}";
# :tasks.deploy.out.info "log file %s" "${log_file}";
# :tasks.deploy.out.info "git url %s" "${git_url}";
# :tasks.deploy.out.info "git branch %s" "${git_branch}";
# :tasks.deploy.out.info "host %s" "${host}";

# git specific commands
:tasks.deploy.script.git.write!() {
cat <<EOF >> "${script}"
deploy() {
	echo "deploy git";
}
EOF
}

# tar specific commands
:tasks.deploy.script.tar.write!() {
cat <<EOF >> "${script}"
deploy() {
	echo "deploy tar";
}
EOF
}

# npm specific commands
:tasks.deploy.script.npm.write!() {
cat <<EOF >> "${script}"
deploy() {
	echo "deploy npm";
}
EOF
}

# write the script footer
:tasks.deploy.script.footer.write!() {
cat <<EOF >> "${script}"

# check for an executable that
# matches the deployment type
binary=\$( command -v "$type" );
if [ -z "\$binary" ]; then
	quit "%s is not installed\n" "\$binary";
fi

start() {
	log;
	settings;
}
start "\$@";
EOF
}