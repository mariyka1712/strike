: <<'ronn:markdown'
task-project(7) -- project task(s) for bake(1)
=============================================

## SYNOPSIS

Project task(s) for bake(1).

## DESCRIPTION

Maintains a list of related projects by unique identifier.

## REQUIRE

In your tasks(7) file `require` the `project` task(s) using:

	require 'tasks/project';

## USAGE

	bake project init
	bake project add id path|url [url...]
	bake project exists id
	bake project ls
	bake project count
	bake project rm id
	
## COMMANDS

* `init`:

	Creates an empty projects file. This command will exit with >0 exit code if a projects file already exists.
	
* `add`:

	Add a project, the first option to this command is the unique identifier for the project the second option is either a relative or absolute file system path to the project or a remote url. Subsequent options to `add` are related URLs for the project. Note that when specifying URLs they must be URL encoded so they do not contain any whitespace.
	
	This command will create a projects file if it does not exist.
	
	If the path specified is a filesystem path then it must point to a valid directory.
	
* `ls`:

	List projects. The output of this command is the identifier followed by the path (or url) delimited by a space.
	
* `exists`:

	Determine whether a project with the specified id exists.
	
* `count`:

	Count the number of projects. The output of this command is an integer corresponding to the number of projects in the projects file.
	
* `print`:

	Print the raw JSON information.
	
* `rm`:

	Remove a project with the specified identifier.
	
## FILES

The projects meta information is stored in a file named *projects.json* in the `${root}` of the current project.

## EXIT CODES

An exit code >0 indicates the operation failed, whilst 0 is success.

## BUGS

**task-project** is written in bash and depends upon `bash` >= 4.

## COPYRIGHT

**task-project** is copyright (c) 2012 muji <http://xpm.io>

## SEE ALSO

bake(1)
ronn:markdown

require.once 'json';

declare -g project_id_regexp="^[-a-zA-Z0-9]+$";
declare -g project_path_regexp="^([a-zA-Z]+://|/|\./|\.\./)";
declare -g project_remote_regexp="^[a-zA-Z]+://";

function tasks.project {
	__project.file;
	local prjfile="$_result";
	
	# force overwrite
	local force=false;
	
	# a project identifier
	local prj_id;
	
	# the main path or url for the project
	local prj_path;
	
	# parsed project information
	declare -A prj_doc;
	
	# do command procesing via delegation
	if [ $# -gt 0 ]; then
		local method="prj.${FUNCNAME}.${1}";
		if ! method.exists? "$method"; then
			console.quit 1 "invalid project command %s" "$1";
		else
			delegate "prj.${FUNCNAME}" "$1" ${@:2};
		fi
	else
		# no options specified list projects
		prj.tasks.project.list;
	fi
}

function prj.tasks.project.init {
	if [ -f "$prjfile" ]; then
		__project.file.exists.quit;
	fi
	__project.generator;
	__project.write!
	if [ ! -f "$prjfile" ]; then
		__project.file.missing.quit;
	fi
	console.success "project file %s created %s" "$prjfile" "✓";
}

function prj.tasks.project.exists {
	#exit 1;
	if [ ! -f "$prjfile" ]; then
		__project.file.missing.info;
		__project.file.missing.quit;
	fi
	
	if [ $# -eq 0 ]; then
		console.quit 1 "no project identifier specified";
	fi
	prj_id="${1:-}";
	__project.id.validate;
	if __project.exists?; then
		console.success "project %s %s" "$prj_id" "✓";
	else
		console.quit 1 "no project %s %s" "$prj_id" "✘";
	fi
}

function prj.tasks.project.add {
	#echo "$FUNCNAME : $# : $*";
	if [ $# -lt 2 ]; then
		quit 1 "too few options for %s" "project add";
	fi
	
	# get the id
	prj_id="${1:-}";
	shift;
	__project.id.validate;
	
	prj_path="${1:-}";
	shift;
	__project.path.validate;
	
	# echo "adding project with id $prj_id";
	# echo "adding project with path $prj_path";
	
	# related URLs
	declare -a urls;
	urls=();
	while [ $# -gt 0 ];
		do
			urls+=( "${1:-}" );
			shift;
	done
	
	# initialize a project file if it doesn't exist
	if [ ! -f "$prjfile" ]; then
		prj.tasks.project.init;
	fi
	
	if ! __project.path.remote?; then
		if [ ! -d "$prj_path" ]; then
			quit 1 "project path %s must be a directory" "$prj_path";
		fi
	fi
	
	# TODO: convert relative paths to absolute ???
	
	# now read in any existing information
	__project.file.read;
	
	# test for id existence and prompt to overwrite?
	if ! $force && __project.exists?; then
		console.quit 1 "project %s exists use %s to overwrite" "$prj_id" "--force";
	fi
	
	prj_doc["projects.$prj_id.path"]="$prj_path";
	
	if [ ${#urls[@]} -gt 0 ]; then
		local url i=0;
		for url in ${urls[@]}
			do
				prj_doc["projects.$prj_id.urls.$i"]="${url}";
				: $((i++));
		done
	fi
	
	json.stringify <<< "prj_doc";
	json.string > "$prjfile" || quit 1 "coult not write project file %s" "$prjfile";
}

function prj.tasks.project.count {
	__project.file.read;
	local prj_num=0;
	for k in ${!prj_doc[@]}
		do
			echo "got prj_doc key : $k";
	done
	# 
	console.log "$prj_num";
	console.success;
}

function prj.tasks.project.print {
	if [ ! -f "$prjfile" ]; then
		__project.file.missing.info;
		__project.file.missing.quit;
	fi
	cat "$prjfile";
}

function prj.tasks.project.ls {
	if [ ! -f "$prjfile" ]; then
		__project.file.missing.info;
		__project.file.missing.quit;
	fi
	__project.file.read;
	local k v;
	local re="^projects\.$project_id_regexp"
	for k in ${!prj_doc[@]}
		do
			if [ "$k" == "generator" ]; then
				continue;
			fi
			if [[ "$k" =~ ^projects.[^.]+\.path ]]; then
				v="${prj_doc[$k]}";
				k="${k#projects.}";
				k="${k%.path}";
				console.log "$k $v";
			fi
	done
}

######################################################################
#
#	PRIVATE METHODS
#
######################################################################

# determine if a project exists
function __project.exists? {
	if [ ! -f "$prjfile" ]; then
		return 1;
	fi
	
	local id="${1:-}";
	
	# look for current id when no specific id is
	# specified
	if [ -z "$id" ]; then
		id="$prj_id";
	fi
	
	# not document information, try to read it in
	if [ ${#prj_doc[@]} -eq 0 ]; then
		__project.file.read;
	fi
	
	local k;
	for k in ${!prj_doc[@]}
		do
			if [[ "$k" =~ ^projects.$id ]]; then
				return 0;
			fi
	done
	return 1;
}

# validate a project identifier
function __project.id.validate {
	if [[ ! "$prj_id" =~ $project_id_regexp ]]; then
		console.quit 1 "invalid project identifier %s, mush match %s" "$prj_id" "$project_id_regexp";
	fi
}

# validate a project path
function __project.path.validate {
	if [[ ! "$prj_path" =~ $project_path_regexp ]]; then
		console.quit 1 "invalid project path %s, mush match %s" "$prj_path" "$project_path_regexp";
	fi
}

# determine if a path is a remote path
function __project.path.remote? {
	if [[ "$prj_path" =~ $project_remote_regexp ]]; then
		return 0;
	fi
	return 1;
}

# retrieve the path to the projects file
function __project.file {
	_result="${root}/projects.json";
}

# read in the project file data
function __project.file.read {
	local k;	
	json.parse < "$prjfile";
	
	# clean prj_doc
	for k in ${!prj_doc[@]}
		do
			unset prj_doc["$k"];
	done
	
	# copy into prj_doc array
	for k in ${!json_doc[@]}
		do
			#echo "got key: $k";
			prj_doc["$k"]="${json_doc[$k]}";
	done
	# clean up json data
	json.clean;
}

# add generator information to project.json
function __project.generator {
	prj_doc[generator]="task-project(7), do not edit this file manually use bake(1) with task-project(7)";
}

# write an empty project file
function __project.write! {
	json.stringify <<< "prj_doc";
	json.string > "${prjfile}" || __project.file.write.quit;
}

# quit if project file exists
function __project.file.exists.quit {
	console.quit 1 "project file %s exists" "$prjfile";
}

# info on creating a project file
function __project.file.missing.info {
	console.info "use %s to create an empty projects.json file" "project init";
}

# quit if no project file is available
function __project.file.missing.quit {
	console.quit 1 "no project file %s" "$prjfile";
}

# quit if we could not write the project file
function __project.file.write.quit {
	console.quit 1 "could not write project file %s" "$prjfile";
}