: <<'ronn:markdown'
task-assert(7) -- unit test task(s) for bake(1)
=============================================

## SYNOPSIS

Unit test task(s) for bake(1).

## DESCRIPTION

Adds task methods for unit testing bash programs, unit tests are defined in files with a `.test` extension.

## REQUIRE

In your tasks(7) file `require` the `assert` task(s) using:

	require 'tasks/assert';

## USAGE

	bake assert [tests...]
	
When no unit tests are specified all tests will be executed, otherwise pass a list of specific tests to run.

## FILES

The `stdout` generated by unit tests is written to `${target}/assert.stdout.log` whilst the `stderr` output from the unit tests is written to `${target}/assert.stderr.log`.

## BUGS

**task-assert** is written in bash and depends upon `bash` >= 4.

## COPYRIGHT

**task-assert** is copyright (c) 2012 muji <http://xpm.io>

## SEE ALSO

bake(1)
ronn:markdown

function tasks.assert {
	local stdout="${target}/assert.stdout.log";
	local stderr="${target}/assert.stderr.log";
	
	# expose a `testdir` variable to the test methods
	local testdir="${program_dirs[test]}";
	fs.path.expand "$testdir";
	testdir="$_result";
	
	echo -n "" > "$stdout" || quit 1 "could not create %s" "$stdout";	
	echo -n "" > "$stderr" || quit 1 "could not create %s" "$stderr";
	
	local ttyout="";
	local ttyerr="";
	if [ -t 1 ]; then ttyout="on"; fi
	if [ -t 2 ]; then ttyerr="on"; fi
	
	if [ $# -eq 0 ]; then
		__assert_run_all;
	else
		__assert_run_units "$@";
	fi
}

# asserts that two string values are equal
function assert.equal {
	local expected="${1:-}";
	local received="${2:-}";
	if [ "$expected" == "$received" ]; then
		__assert_ok "$FUNCNAME";
	else
		__assert_err "$FUNCNAME";
	fi
}

# asserts that a string matches a regex
function assert.match {
	local expected="${1:-}";
	local received="${2:-}";
	if [[ "$received" =~ $expected ]]; then
		__assert_ok "$FUNCNAME";
	else
		__assert_err "$FUNCNAME";
	fi
}

# asserts that an integer is greater than
# an expected value
function assert.gt {
	local expected="${1:-}";
	local received="${2:-}";
	if [ "$received" -gt "$expected" ]; then
		__assert_ok "$FUNCNAME";
	else		
		__assert_err "$FUNCNAME";
	fi
}

# asserts that an integer is less than
# an expected value
function assert.lt {
	local expected="${1:-}";
	local received="${2:-}";
	if [ "$received" -lt "$expected" ]; then
		__assert_ok "$FUNCNAME";
	else
		__assert_err "$FUNCNAME";
	fi
}

# asserts that an integer is equal to
# an expected value
function assert.eq {
	local expected="${1:-}";
	local received="${2:-}";
	if [ "$received" -eq "$expected" ]; then
		__assert_ok "$FUNCNAME";
	else
		__assert_err "$FUNCNAME";
	fi
}

function __assert_ok {
	local assertion="$1";
	local stack=( $( caller 1 ) );
	local method="${stack[1]}";
	if [ ! -z "$ttyout" ]; then
		# save stdout in file descriptor #5		
		exec 5>&1;
		exec 1> /dev/tty;
	fi
	console.ok "$assertion %s" "$method";
	
	if [ ! -z "$ttyout" ]; then	
		# restore stdout and close file descriptor #5
		exec 1>&5 5>&-;
	fi
}

function __assert_err {
	local assertion="$1";
	local stack=( $( caller 1) );
	local lineno="${stack[0]}";
	local method="${stack[1]}";
	local file="${stack[2]}";
	local frame="${file}:${lineno}";
	if [ ! -z "$ttyerr" ]; then
		# save stdout in file descriptor #6	
		exec 6>&1;
		exec 2> /dev/tty;
	fi
	error "$assertion %s $frame" "$method";
	error "expected %s, got %s" "$expected" "$received";
	
	if [ ! -z "$ttyerr" ]; then
		# restore stderr and close file descriptor #6
		exec 1>&6 6>&-;
	fi
}

function __assert_run_all {
	__assert_search_paths;
	local searchpaths=( "$_result" );
	local path file;
	for path in ${searchpaths[@]}
		do
			if [ -d "$path" ]; then
				__assert_run_dir "$path";
			fi
	done
}


function __assert_run_dir {
	local dir="$1";
	if [ -d "$dir" ]; then
		for file in ${dir}/*
			do
				if [ -f "$file" ] && [[ "$file" =~ .test$ ]]; then
					__assert_run_test "$file";
				# recurse into sub-directories
				elif [ -d "$file" ]; then
					__assert_run_dir "$file";
				fi
		done
	fi
}

function __assert_run_units {
	__assert_search_paths;
	local searchpaths=( "$_result" );
	local opts=( "$@" );
	local unit path file;
	for path in ${searchpaths[@]}
		do
			for unit in ${opts[@]}
				do
					file="${path}/${unit}.test";
					if [ -f "$file" ]; then
						__assert_run_test "$file";
					fi
			done
	done	
}

function __assert_search_paths {
	local searchpaths=(
		"$exedir/test"
		"$exedir/../test"
	);
	_result="${searchpaths[@]}";
}

function __assert_run_test {
	local file="$1";
	local name="`basename $file`";
	
	# require and generate a list of method definitions
	require.methods "$file" "^test\.";
	local methods=( $_result );
	console.info "assert %s < %s" "$name" "$file";
	if [ "${#methods[@]}" -eq 0 ]; then
		console.warn "test %s does not declare any test methods" "$name";
	else
		local m;
		
		# print methods		
		for m in "${methods[@]}"
			do
				console.info "assert %s" "$m";
		done
		
		# run method assertions
		for m in "${methods[@]}"
			do
				# check that the method starts with a test prefix
				if [[ "$m" =~ ^test. ]]; then				
					# clean up
					__assert_expects="";
					console.info "run %s" "$m";
					set +o errexit;
					# execute the test method
					"$m" 1>> "$stdout" 2>> "$stderr";
					set -o errexit;

					# remove the method so that it is not
					# executed again on subsequent passes
					method.remove "$m";
				fi
		done	
	fi
}