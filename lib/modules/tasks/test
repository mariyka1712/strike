: <<'ronn:markdown'
task-test(7) -- unit test task(s) for bake(1)
=============================================

## SYNOPSIS

Unit test task(s) for bake(1).

## DESCRIPTION

Adds task methods for unit testing bash(1) programs, unit tests are defined in files with a `.test` extension.

## REQUIRE

In your tasks(7) file `require` the `test` task(s) using:

	require 'tasks/test';

## USAGE

	bake test [suite...]
	
When no test suites are specified all test suites will be executed, otherwise pass a list of specific tests to run. Note that when specifying the test suites you *do not* include the `.test` file extension.

## FILES

The `stdout` generated by unit tests is written to `${target}/assert.stdout.log` whilst the `stderr` output from the unit tests is written to `${target}/assert.stderr.log`.

## BUGS

**task-test** is written in bash and depends upon `bash` >= 4.

## COPYRIGHT

**task-test** is copyright (c) 2012 muji <http://xpm.io>

## SEE ALSO

bake(1)
ronn:markdown

# core assertion methods
require 'assert';

function tasks.test {
	local stdout="${target}/assert.stdout.log";
	local stderr="${target}/assert.stderr.log";
	
	string.repeat "+" 80;
	local header="$_result";
	
	declare -A summary;
	summary[suites]=0;
	summary[methods]=0;
	summary[executables]=0;
	summary[assertions]=0;
	summary[assertions.pass]=0;
	summary[assertions.fail]=0;
	
	declare -A failures;
	
	# expose a `testdir` variable to the test methods
	local testdir="${process_dirs[test]}";
	fs.path.expand "$testdir";
	testdir="$_result";
	
	# specific methods to test, specified using a : delimiter
	local testmethods=();
	local unit;
	
	echo -n "" > "$stdout" || quit 1 "could not create %s" "$stdout";	
	echo -n "" > "$stderr" || quit 1 "could not create %s" "$stderr";
	
	local ttyout="";
	local ttyerr="";
	if [ -t 1 ]; then ttyout="on"; fi
	if [ -t 2 ]; then ttyerr="on"; fi
	
	local testbin="${testdir}/bin";
	
	if [ $# -eq 0 ]; then
		__assert_run_all;
	else
		__assert_run_units "$@";
	fi
	
	__assert.print.summary;
}

function __assert_run_all {
	__assert_search_paths;
	local searchpaths=( "$_result" );
	local path file;
	for path in ${searchpaths[@]}
		do
			if [ -d "$path" ]; then
				__assert_run_dir "$path";
			fi
	done
}

function __assert_run_dir {
	local dir="$1";
	if [ -d "$dir" ]; then
		for file in ${dir}/*
			do
				if [ -f "$file" ] && [[ "$file" =~ .test$ ]]; then
					unit="`basename "$file"`";
					unit="${unit%.test}";
					__assert_run_test "$file";
				# recurse into sub-directories
				elif [ -d "$file" ]; then
					__assert_run_dir "$file";
				fi
		done
	fi
}

function __assert_run_units {
	__assert_search_paths;
	local searchpaths=( "$_result" );
	local opts=( "$@" );
	local path file methods;
	for path in ${searchpaths[@]}
		do
			for unit in ${opts[@]}
				do
					# handle running specific test methods
					if [[ "$unit" =~ : ]]; then
						local IFS=":";
						testmethods=( $unit );
						unset IFS;
						unit="${testmethods[0]}";
						unset testmethods[0];
					fi
					file="${path}/${unit}.test";			
					# echo "testing for file: $file";
					
					# run test suite(s) (including executables)
					if [ -f "$file" ]; then
						__assert_run_test "$file";
					# only matched executable test suites
					elif [ -x "${testbin}/${unit}" ]; then
						__assert_run_test "${testbin}/${unit}" true;
					# no test suite found
					else
						console.warn "test file %s does not exist" "$file";
					fi
			done
	done
}

function __assert_search_paths {
	local searchpaths=(
		"${root}/test"
	);
	_result="${searchpaths[@]}";
}

function __assert_run_test {
	local file="$1";
	
	# only runing binary tests
	local only_binaries="${2:-false}";
	
	fs.path.expand "$file";
	file="$_result";
	local name="`basename $file`";
	local suite=${name%%.*};
	
	((summary[suites]++));
	
	# run any binary tests first
	# these executables should perform inline assertions
	# and return a zero exit code for success and >0 for failure
	if [ -d "$testbin" ]; then
		# binary matching the suite name
		if [ -f "${testbin}/${suite}" ]; then
			__assert_run_test_executable "${testbin}/${suite}";
		fi
		local binary;
		for binary in ${testbin}/${suite}.*
			do
				if [ -f "$binary" ]; then
					__assert_run_test_executable "$binary";
				fi
		done
	fi
	
	# only running binary tests
	if $only_binaries; then
		return 0;
	fi
	
	# TODO: unload the module after the test suite has completed
	
	# require and generate a list of method definitions
	require.methods "$file" "^test\.";
	local methods=( $_result );
	console.info "test %s < %s" "$suite" "$file";
	if [ "${#methods[@]}" -eq 0 ]; then
		console.warn "test %s does not declare any test methods" "$name";
	else
		local m nm;
		
		# filter method flag
		local filter=false;
		
		
		# running specific test(s)
		if [ ${#testmethods[@]} -gt 0 ]; then
			filter=true;
		fi		
		
		# print method summary	
		for m in "${methods[@]}"
			do
				nm=${m#test.${unit}.};
				if ! $filter; then
					console.info "assert %s" "$nm";
				else
					if array.contains? "$nm" "${testmethods[@]}"; then
						console.info "assert %s" "$nm";
					fi
				fi
		done
		
		# run method assertions
		for m in "${methods[@]}"
			do
				# check that the method starts with a test prefix				
				if [[ "$m" =~ ^test. ]]; then
					nm=${m#test.${unit}.};
					if ! $filter; then
						__assert_run_test_method;
					else
						if array.contains? "$nm" "${testmethods[@]}"; then
							__assert_run_test_method;
						fi
					fi
				fi
		done	
	fi
}

function __assert_run_test_method {
	((summary[methods]++));
	console.info "run %s" "$m";
	set +o errexit;
	# execute the test method
	"$m" 1>> "$stdout" 2>> "$stderr";
	set -o errexit;

	# remove the method so that it is not
	# executed again on subsequent passes
	method.remove "$m";
}

function __assert_run_test_executable {
	local binary="${1:-}";
	if [ -n "$binary" ] && [ -x "$binary" ] ;then
		local binary_name="`basename $binary`";
		console.info "binary test %s < %s" "$binary_name" "$binary";
		((summary[executables]++));	
		# execute the binary test file
		# 1>> "$stdout" 2>> "$stderr" 
		"$binary" 1>> "$stdout" 2>> "$stderr" &
		local binary_exit_code="$?";
		wait %%;
		if [ $binary_exit_code -gt 0 ]; then
			console.warn "binary test %s exited with non-zero code %s" "$binary_name" "$binary_exit_code";
		fi
		assert.eq "0" "$binary_exit_code";
	else
		console.warn "test binary %s is not executable" "$binary";
	fi
}

function __assert.print.header {
	local output="${1:-$output}";
	if [ -z "$output" ]; then
		output="console.log";
	fi
	$output "$header";
}

function __assert.print.summary {
	
	# switch output method for summary
	# based on any assertions failing
	local output="console.info";
	
	# some assertions failed
	if [ ${summary[assertions.fail]} -gt 0 ]; then
		output="console.warn";
	fi
	
	__assert.print.header $output;
	
	$output "suites: %s" "${summary[suites]}";
	$output "methods: %s" "${summary[methods]}";
	$output "binary: %s" "${summary[executables]}";
	$output "assertions: %s" "${summary[assertions]}";
	$output "assertions (pass): %s" "${summary[assertions.pass]}";
	
	if [ ${summary[assertions.fail]} -eq 0 ]; then
		console.info "assertions (fail): %s" "${summary[assertions.fail]}";
	else
		console.warn "assertions (fail): %s" "${summary[assertions.fail]}";
	fi
	
	if [ ${summary[assertions.fail]} -eq 0 ]; then
		__assert.print.header;		
		console.ok "test(s) passed %s" "✓";
		exit 0;
	else
		
		__assert.print.header;
		console.warn "# FAILURES";
		console.warn "# STDOUT: " "$stdout";
		console.warn "# STDERR: " "$stderr";
		__assert.print.header;
		
		local debuginfo;
		for debuginfo in ${!failures[@]}
			do
				local assertion="${failures[$debuginfo]}";
				local frame=${debuginfo%:*};
				local method=${debuginfo##*:};
				console.error "$assertion %s" "$method";
				console.error "$frame";
		done
		
		__assert.print.header;		
		
		console.error "test(s) failed %s" "✘";
		exit ${summary[assertions.fail]};
	fi
}