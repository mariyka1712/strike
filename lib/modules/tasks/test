: <<'ronn:markdown'
task-test(7) -- unit test task(s) for bake(1)
=============================================

## SYNOPSIS

Unit test task(s) for bake(1).

## DESCRIPTION

Adds task methods for unit testing bash(1) programs, unit tests are defined in files with a `.test` extension.

## REQUIRE

You do not need to require(3) this task as it is a builtin task.

## USAGE

	bake test [command] [suite:test...]
	
When no test suites are specified all test suites will be executed, otherwise pass a list of specific tests to run. Note that when specifying the test suites you *do not* include the `.test` file extension.

## COMMANDS

* `run`:

	Run one or more test suites.
	
* `list`:

	List test suites and test methods (if test methods have been specified).
	
* `ant`:

	Attempts to run an ant(1) *test* target.
	
* `rake`:

	Attempts to run a rake(1) *test* task.
	
* `mvn`:

	Attempts to run a mvn(1) *test* goal.

## FILES

The `stdout` generated by unit tests is written to `${target}/test.stdout.log` whilst the `stderr` output from the unit tests is written to `${target}/test.stderr.log`.

## BUGS

**task-test** is written in bash and depends upon `bash` >= 4.

## COPYRIGHT

**task-test** is copyright (c) 2012 muji <http://xpm.io>

## SEE ALSO

bake(1)
ronn:markdown

# core assertion methods
require 'assert';

function tasks.test {
	local stdout="${target}/test.stdout.log";
	local stderr="${target}/test.stderr.log";
	
	string.repeat "+" 80;
	local header="$_result";
	
	# are we running all available tests
	local all=false;
	
	declare -A summary;
	summary[suites]=0;
	summary[methods]=0;
	summary[executables]=0;
	summary[assertions]=0;
	summary[assertions.pass]=0;
	summary[assertions.fail]=0;
	
	declare -A failures;
	
	# expose a `testdir` variable to the test methods
	local testdir="${process_dirs[test]}";
	fs.path.expand "$testdir";
	testdir="$_result";
	
	# list of test suites
	local suites=();
	# list of test suite paths
	# key is test suite name
	# value is test suite path/file
	declare -A paths;
	
	# specific methods to test, specified using a : delimiter
	local testmethods=();
	local unit;
	
	echo -n "" > "$stdout" || quit 1 "could not create %s" "$stdout";
	echo -n "" > "$stderr" || quit 1 "could not create %s" "$stderr";
	
	local ttyout="";
	local ttyerr="";
	if [ -t 1 ]; then ttyout="on"; fi
	if [ -t 2 ]; then ttyerr="on"; fi
	
	local testbin="${testdir}/bin";
	
	# do command procesing via delegation
	if [ $# -gt 0 ]; then
		local cmd="$1";		
		local method="tdd.${FUNCNAME}.${1}";
		# remove command option
		local commands=( run list );
		if array.contains? "${cmd}" "${commands[@]}"; then
			shift;
		fi
		#echo "got cmd: $cmd : $#";
		if [ "$cmd" == "run" ] && [ $# -eq 0 ]; then
			# no suites specified to run
			tdd.tasks.test.run "$@";
		else
			# look for a command method
			if ! method.exists? "$method"; then
				console.quit 1 "invalid test command %s" "$1";
			else
				delegate "tdd.${FUNCNAME}" "$cmd" $@;
			fi
		fi	
	else
		# no options specified run all tests
		tdd.tasks.test.run "$@";
	fi
}

# invoke an ant(1) *test* target
function tdd.tasks.test.ant {
	require.once 'tasks/ext/build/ant';
	tasks.ant test;
}

# invoke a rake(1) *test* task
function tdd.tasks.test.rake {
	require.once 'tasks/ext/build/rake';
	tasks.rake test;
}

# invoke a mvn(1) *test* goal
function tdd.tasks.test.mvn {
	require.once 'tasks/ext/build/mvn';
	tasks.mvn test;
}

function tdd.tasks.test.list {
	
	#echo "got list command $#";	
	
	# gather test suites
	if [ $# -eq 0 ]; then
		__assert_get_all;
	else
		__assert_get_suites "$@";
	fi
	
	#echo "got list command ${suites[@]}";
	
	if [ ${#suites[@]} -eq 0 ]; then
		console.quit 1 "no test suites found";
	fi	
	
	for unit in ${suites[@]}
		do
			path="${paths["$unit"]}";
			console.log "$unit ${paths["$unit"]}";
	done
}

function tdd.tasks.test.run {
	
	# gather test suites
	if [ $# -eq 0 ]; then
		all=true;
		__assert_get_all;
	else
		__assert_get_suites "$@";
	fi
	
	# run tests
	__assert.run;
	
	# print the summary
	__assert.print.summary;
}

# run all test suites
function __assert.run {
	local path;
	
	if [ ${#suites[@]} -eq 0 ]; then
		console.quit 1 "no test suites found";
	fi
	
	for unit in ${suites[@]}
		do
			path="${paths["$unit"]}";
			__assert_run_suite;
	done
}

function __assert.suite.add {
	# NOTE: if we are running in the context
	# NOTE: of the library code and the tast-test.test
	# NOTE: file is found when running all tests we skip it.
	# NOTE: this enables running: `bake run task-test`
	# NOTE: to verify the output when a test fails
	# NOTE: yet enable all test to pass when running `bake test`
	# NOTE: on the library code
	if process.lib? && $all && [ "$1" == "task-test" ]; then
		return 0;
	fi
	if [ -f "$2" ] ;then
		suites+=( "$1" );
		paths["$1"]="$2";
	fi
}

function __assert_get_all {
	
	# look for all .test suites
	__assert_search_paths;
	local searchpaths=( "$_result" );
	local path file;
	for path in ${searchpaths[@]}
		do
			if [ -d "$path" ]; then
				__assert_get_dir "$path";
			fi
	done
	
	# find all binary tests (last)
	__assert.get.binary;
}

function __assert_get_dir {
	local dir="$1";
	if [ -d "$dir" ]; then
		for file in ${dir}/*
			do
				if [ -f "$file" ] && [[ "$file" =~ .test$ ]]; then
					unit="`basename "$file"`";
					unit="${unit%.test}";
					__assert.suite.add "$unit" "$file";
				# recurse into sub-directories
				elif [ -d "$file" ]; then
					__assert_get_dir "$file";
				fi
		done
	fi
}

function __assert.get.binary {
	local suite="${1:-}";
	local bin binsuite;
	if [ -d "$testbin" ]; then
		# searching for binaries matching a suite name
		if [ -n "$suite" ]; then
			bin="${testbin}/${suite}";
			binsuite="${bin#${testdir}/}";
			# binary matching the suite name
			if [ -f "$bin" ] && [ -x "$bin" ]; then
				__assert.suite.add "$binsuite" "$bin";
			fi
			# looking for suite.* binaries
			for bin in ${testbin}/${suite}.*
				do					
					if [ -f "$bin" ] && [ -x "$bin" ]; then
						binsuite="${bin#${testdir}/}";
						__assert.suite.add "$binsuite" "$bin";								
					fi
			done
		else
			# looking for all binary tests
			for bin in ${testbin}/**
				do
					if [ -f "$bin" ] && [ -x "$bin" ] ; then
						binsuite="${bin#${testdir}/}";
						__assert.suite.add "$binsuite" "$bin";
					fi
			done
		fi
	fi
}

# filter by suites specified on the command line
function __assert_get_suites {
	__assert_search_paths;
	local searchpaths=( "$_result" );
	local opts=( "$@" );
	local path file methods;
	for path in ${searchpaths[@]}
		do
			for unit in ${opts[@]}
				do
					# handle running specific test methods
					if [[ "$unit" =~ : ]]; then
						echo "checking for specific method(s) to test ... ";
						local IFS=":";
						testmethods=( $unit );
						unset IFS;
						unit="${testmethods[0]}";
						unset testmethods[0];
					fi
					
					if [[ ! "$unit" =~ \.test$ ]]; then
						__assert.suite.add "$unit" "${path}/${unit}.test";
					# allow people to specify the .test extension if they
					# really want to
					else
						__assert.suite.add "$unit" "${path}/${unit}";
					fi
					
					__assert.get.binary "$unit";					
			done
	done
}

function __assert_run_suite {	
	file="$path";
	
	# run test suite(s) (including executables)
	if [ -f "$file" ]; then
		__assert_run_test "$file";
	# no test suite found
	else
		console.warn "test file %s does not exist" "$file";
	fi
}

function __assert_search_paths {
	local searchpaths=(
		"${root}/test"
	);
	_result="${searchpaths[@]}";
}

function __assert_run_test {
	local file="$1";
	
	# only runing binary tests
	local only_binaries="${2:-false}";
	
	fs.path.expand "$file";
	file="$_result";
	local name="`basename $file`";
	local suite=${name%%.*};
	
	: $((summary[suites]++));
	
	# run test as an executable
	if [ -x "$file" ]; then
		__assert_run_test_executable "${file}";
	# run test as a .test source file
	else
		# TODO: unload the module after the test suite has completed

		# require and generate a list of method definitions
		require.methods "$file" "^test\.";
		local methods=( $_result );
		console.info "test %s < %s" "$suite" "$file";
		if [ "${#methods[@]}" -eq 0 ]; then
			console.warn "test %s does not declare any test methods" "$name";
		else
			local m nm;

			# filter method flag
			local filter=false;

			# running specific test(s)
			if [ ${#testmethods[@]} -gt 0 ]; then
				filter=true;
			fi

			# print method summary	
			for m in "${methods[@]}"
				do
					nm=${m#test.${unit}.};
					if ! $filter; then
						console.info "test.%s" "$nm";
					else
						if array.contains? "$nm" "${testmethods[@]}"; then
							console.info "assert %s" "$nm";
						fi
					fi
			done

			# run method assertions
			for m in "${methods[@]}"
				do
					# check that the method starts with a test prefix				
					if [[ "$m" =~ ^test. ]]; then
						nm=${m#test.${unit}.};
						if ! $filter; then
							__assert_run_test_method;
						else
							if array.contains? "$nm" "${testmethods[@]}"; then
								__assert_run_test_method;
							fi
						fi
					fi
			done	
		fi
	fi
}

function __assert_run_test_method {
	: $((summary[methods]++));
	console.info "run %s" "$m";
	set +o errexit;
	# execute the test method
	"$m" 1>> "$stdout" 2>> "$stderr";
	set -o errexit;

	# remove the method so that it is not
	# executed again on subsequent passes
	method.remove "$m";
}

function __assert_run_test_executable {
	local binary="${1:-}";
	if [ -n "$binary" ] && [ -x "$binary" ] ;then
		local binary_name="`basename $binary`";
		console.info "binary test %s < %s" "$binary_name" "$binary";
		: $((summary[executables]++));	
		# execute the binary test file
		# 1>> "$stdout" 2>> "$stderr" 
		"$binary" 1>> "$stdout" 2>> "$stderr" &
		local binary_exit_code="$?";
		wait %%;
		if [ $binary_exit_code -gt 0 ]; then
			console.warn "binary test %s exited with non-zero code %s" "$binary_name" "$binary_exit_code";
		fi
		assert.eq "0" "$binary_exit_code";
	else
		console.warn "test binary %s is not executable" "$binary";
	fi
}

function __assert.print.header {
	local output="${1:-$output}";
	if [ -z "$output" ]; then
		output="console.log";
	fi
	$output "$header";
}

function __assert.print.summary {
	
	# switch output method for summary
	# based on any assertions failing
	local output="console.info";
	
	# some assertions failed
	if [ ${summary[assertions.fail]} -gt 0 ]; then
		output="console.warn";
	fi
	
	__assert.print.header $output;
	
	local testfiles=$(( ${summary[suites]} - ${summary[executables]} ));
	
	$output "suites (total): %s" "${summary[suites]}";
	$output "suites (binary): %s" "${summary[executables]}";
	$output "suites (test): %s" "$testfiles";
	$output "methods: %s" "${summary[methods]}";
	$output "assertions: %s" "${summary[assertions]}";
	$output "assertions (pass): %s" "${summary[assertions.pass]}";
	
	if [ ${summary[assertions.fail]} -eq 0 ]; then
		console.info "assertions (fail): %s" "${summary[assertions.fail]}";
	else
		console.warn "assertions (fail): %s" "${summary[assertions.fail]}";
	fi
	
	if [ ${summary[assertions.fail]} -eq 0 ]; then
		__assert.print.header;		
		console.ok "test(s) passed %s" "✓";
		exit 0;
	else
		
		__assert.print.header;
		console.warn "# FAILURES";
		__assert.print.header;		
		console.warn "# STDOUT: %s" "$stdout";
		console.warn "# STDERR: %s" "$stderr";
		__assert.print.header;
		
		local debuginfo;
		for debuginfo in ${!failures[@]}
			do
				local assertion="${failures[$debuginfo]}";
				local frame=${debuginfo%:*};
				local method=${debuginfo##*:};
				console.error "$assertion %s" "$method";
				console.error "$frame";
		done
		
		__assert.print.header;		
		
		console.error "test(s) failed %s" "✘";
		exit ${summary[assertions.fail]};
	fi
}