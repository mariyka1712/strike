: <<'ronn:markdown'
task-compress(7) -- compress task(s) for bake(1)
=============================================

## SYNOPSIS

Compression task(s) for bake(1).

## DESCRIPTION

Compresses file(s) using gzip(1) and gunzip(1). This task is used to compress regular files, if you wish to compress directories use task-archive(7). The primary difference between gzip(1) and task-compress(7) is that source files or compressed files are maintained on disc by default. This is useful for web applications that wish to inspect an *Accept-Encoding* header and serve the appropriate file.

## REQUIRE

In your tasks(7) file `require` the `compress` task(s) using:

	require 'tasks/compress';

## USAGE

	bake compress -c [options...] [files...]
	bake compress -x [options...] [files...]
	
## COMMANDS

* `-c | create`:

	Deflate file(s). This command creates a file with the same name as the source file appended with a `gz` file extension. By default the original file is maintained, if you wish to delete the file(s) use the `--delete` option.
	
* `-x | extract`:

	Inflate compressed file(s).
	
## OPTIONS

* `-d | --delete`:

	The default behaviour is to keep the source files, specify this flag if you wish to delete the source files. This mimics the default behaviour of gzip(1) and gunzip(1) whereby source files are deleted when deflating and compressed files are deleted when inflating.
	
* `-r | --recursive`:

	Recurse into sub-directories.
	
* `--noop`:

	Do not perform any action, print information about the source and/or compressed files. The `--debug` option has no effect when this option is specified.
	
* `--debug`:

	Print the commands being executed.

## BUGS

**task-compress** is written in bash and depends upon `bash` >= 4.2.

## COPYRIGHT

**task-compress** is copyright (c) 2012 muji <http://xpm.io>

## SEE ALSO

bake(1)
ronn:markdown

# map help for this task
require.once help;
help.man.page "compress" "task-compress.7";

#redirect the gzip outout to the file so we keep the original
#and redirect standard error output to an array
# local results=( $( { gzip -c --best --force -v "$f" 1> "$out"; } 2>&1 ) );
# info "gzip %s -> %s (%s)" "$nm" "`basename $out`" "'${results[1]}'";
# touch "$out";

function tasks.compress.initialize {
	executable.validate gzip gunzip;
}

function tasks.compress {
	
	# the extension for compressed files
	local compress_extension="gz";
	
	# whether we recurse into sub-directories
	local compress_recursive=false;	

	# whether we delete files,
	# the default is to keep files
	local compress_delete=false;
	
	# debug commands as they are executed
	local compress_debug=false;
	
	# verbose output
	local compress_verbose=false;
	
	# noop
	local compress_noop=false;
	
	# map of options to command names
	declare -A commands;
	commands=(
		[-c]="deflate"
		[-x]="inflate"
		[create]="deflate"
		[extract]="inflate"
	);
	
	# do command procesing via delegation
	if [ $# -gt 0 ]; then
		local cmd="${1:-}";
		local cmdmethod="${commands[$cmd]:-}";
		if [ -z "$cmdmethod" ]; then
			console.quit 1 "invalid compress command %s" "$1";
		fi

		# remove the command option
		shift;
		
		# parse remaining options
		__compress.parse "$@";
		local opts=( $_result );
		delegate "cmp.${FUNCNAME}" "$cmdmethod" "${opts[@]:-}";
	else
		console.quit 1 "no compress command specified";
	fi
}

function cmp.tasks.compress.inflate {
	if [ $# -eq 0 ]; then
		__compress.missing.files;
	fi
	if ! $compress_noop; then
		__compress.get.files "__compress.inflate" false "$@";
	else
		__compress.get.files "__compress.print" false "$@";
	fi
}

function cmp.tasks.compress.deflate {
	if [ $# -eq 0 ]; then
		__compress.missing.files;
	fi
	if ! $compress_noop; then
		__compress.get.files "__compress.deflate" true "$@";
	else
		__compress.get.files "__compress.print" true "$@";
	fi
}

######################################################################
#
#	PRIVATE METHODS
#
######################################################################

# iterates the list of files being processed
# and invokes a callback function for each
# file being processed
function __compress.get.files {
	local callback="${1:-}";
	shift;
	local skip="${1:-true}";
	shift;
	if [ -n "$callback" ]; then
		local file;
		for file in "$@"
			do
				# ignore .gz files when compressing
				if $skip && [[ "$file" =~ \.gz$ ]]; then
					continue;
				# ignore anything but .gz files when extracting
				elif ! $skip && [[ ! "$file" =~ \.gz$ ]]; then
					continue;
				fi
				"$callback";
		done
	fi
}

function __compress.deflate {
	local out="${file}.${compress_extension}";
	local nm name compress_options results status;
	fs.basename "$file" "nm";	
	fs.basename "$out" "name";
	compress_options=( -c --best --force -v "$file" );
	if $compress_debug; then
		console.info "${executables[gzip]} %s 1>| %s" "${compress_options[*]}" "$out";
	fi
	results=( $( { "${executables[gzip]}" "${compress_options[@]}" 1>| "$out"; } 2>&1 ) );
	status=$?;	
	if $compress_delete && [ $status -eq 0 ]; then
		rm "$file" || quit 1 "could not delete %s" "$file";
	fi
	if [ $status -gt 0 ]; then
		console.quit 1 "failed to compress %s" "$file";
	fi
	if $compress_verbose; then
		console.info "%s > %s (%s)" "$nm" "$name" "${results[${#results[@]}-1]}";
	fi
	# also touch the file to set modification time
	# in case it already exists
	if [ -f "$out" ]; then
		touch "$out";
	fi
}

function __compress.inflate {	
	local out="${file%.gz}";
	local nm name compress_options results;
	fs.basename "$file" "nm";
	fs.basename "$out" "name";
	
	compress_options=( -c -v "$file" );
	
	if $compress_debug; then
		console.info "${executables[gunzip]} %s 1>| %s" "${compress_options[*]}" "$out";
	fi
	
	results=( $( { "${executables[gunzip]}" "${compress_options[@]}" 1>| "$out"; } 2>&1 ) );
	status=$?;
	if $compress_delete && [ $status -eq 0 ]; then
		echo "got delete option on inflate !!!!! $file";
		rm "$file" || quit 1 "could not delete %s" "$file";
		if [ -f "$file" ]; then
			echo "FILE STILL EXISTS";
		fi
	fi
	if [ $status -gt 0 ]; then
		console.quit 1 "failed to extract %s" "$file";
	fi
	if $compress_verbose; then
		console.info "%s < %s (%s)" "$name" "$nm" "${results[${#results[@]}-1]}";
	fi
	# also touch the file to set modification time
	# in case it already exists
	touch "$out";
	
	# --list 
	
	# # gather result information
	# local out="${results[${#results[@]}-1]}";
	# unset results[${#results[@]}-1];
	# local ratio="${results[${#results[@]}-1]}";
	# unset results[${#results[@]}-1];
	# local osize="${results[${#results[@]}-1]}";	
	# unset results[${#results[@]}-1];
	# local csize="${results[${#results[@]}-1]}";
	# 
	# local nm name;
	# fs.basename "$file" "nm";
	# fs.basename "$out" "name";	
	# 
	# if $compress_verbose; then
	#  	console.info "%s < %s %s %s %s" "$name" "$nm" "$osize" "$csize" "$ratio";
	# fi
	
	# # also touch the file to set modification time
	# # in case it already exists
	# touch "$out";
}

# print file information
function __compress.print {
	local size="";
	if $compress_verbose && [ -f "$file" ]; then
		size=( $( du -h "$file" ) );
		size=" ${size[0]}";
	fi
	console.log "${file}%s" "$size";
}

# parse command line options
function __compress.parse {
	# unprocessed options
	local options=();
	
	local value;
	# handle other options
	while [ "${1:-}" != "" ]; do
		case $1 in
			-d | --delete )
				compress_delete=true;
				;;
			-r | --recursive )
				compress_recursive=true;
				;;
			--debug )
				compress_debug=true;
				;;				
			-v | --verbose )
				compress_verbose=true;
				;;
			--noop )
				compress_noop=true;
				;;							
			* )
				options+=( "$1" );
				;;
		esac
		if [ $# -ne 0 ]; then
			shift;
		else
			break;
		fi
	done

	# return remaining options back
	_result="${options[@]:-}";
}

function __compress.missing.files {
	console.quit 1 "no files specified";
}