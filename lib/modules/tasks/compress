: <<'ronn:markdown'
task-compress(7) -- compress task(s) for bake(1)
=============================================

## SYNOPSIS

Compression task(s) for bake(1).

## DESCRIPTION

Compresses file(s) using gzip(1) and gunzip(1). This task is used to compress regular files, if you wish to compress directories use task-archive(7).

## REQUIRE

In your tasks(7) file `require` the `compress` task(s) using:

	require 'tasks/compress';

## USAGE

	bake -c [options...] [files...]
	bake -x [options...] [files...]
	bake -l [options...] [files...]
	
## COMMANDS

* `-c | create`:

	Deflate file(s). This command creates a file with the same name as the source file appended with a `gz` file extension. By default the original file is maintained, if you wish to overwrite the file(s) use the `--overwrite` option.
	
* `-x | extract`:

	Inflate compressed file(s).
	
* `-l | ls`:

	List file(s) that would be matched with the current command options.
	
## OPTIONS

* `-o | --overwrite`:

	The default behaviour is to keep the source files, specify this flag if you wish to overwrite the source files.
	
* `-r | --recursive`:

	Recurse into sub-directories.
	
* `--debug`:

	Print the commands being executed.

## BUGS

**task-compress** is written in bash and depends upon `bash` >= 4.

## COPYRIGHT

**task-compress** is copyright (c) 2012 muji <http://xpm.io>

## SEE ALSO

bake(1)
ronn:markdown

# map help for this task
require.once help;
help.man.page "compress" "task-compress.7";

#redirect the gzip outout to the file so we keep the original
#and redirect standard error output to an array
# local results=( $( { gzip -c --best --force -v "$f" 1> "$out"; } 2>&1 ) );
# info "gzip %s -> %s (%s)" "$nm" "`basename $out`" "'${results[1]}'";
# touch "$out";

function tasks.compress.initialize {
	executable.validate gzip;
}

function tasks.compress {
	
	# the extension for compressed files
	local compress_extension="gz";
	
	# whether we recurse into sub-directories
	local compress_recursive=false;	

	# whether we overwrite files,
	# the default is to keep files
	local compress_overwrite=false;
	
	# debug commands as they are executed
	local compress_debug=false;
	
	# verbose output
	local compress_verbose=false;
	
	# map of options to command names
	declare -A commands;
	commands=(
		[-c]="deflate"
		[-x]="inflate"
		[-l]="list"
		[create]="deflate"
		[extract]="inflate"
		[ls]="list"
	);
	
	# do command procesing via delegation
	if [ $# -gt 0 ]; then
		local cmd="${1:-}";
		local cmdmethod="${commands[$cmd]:-}";
		if [ -z "$cmdmethod" ]; then
			console.quit 1 "invalid compress command %s" "$1";
		fi

		# remove the command option
		shift;
		
		# parse remaining options
		__compress.parse "$@";
		local opts=( $_result );
		delegate "cmp.${FUNCNAME}" "$cmdmethod" "${opts[@]:-}";
	else
		console.quit 1 "no compress command specified";
	fi
}

function cmp.tasks.compress.inflate {
	if [ $# -eq 0 ]; then
		__compress.missing.files;
	fi
	echo "$FUNCNAME";
	__compress.get.files "$@";
}

function cmp.tasks.compress.deflate {
	if [ $# -eq 0 ]; then
		__compress.missing.files;
	fi
	__compress.get.files "__compress.deflate" "$@";
}

function cmp.tasks.compress.list {
	if [ $# -eq 0 ]; then
		__compress.missing.files;
	fi
	__compress.get.files "__compress.print" "$@";
}

######################################################################
#
#	PRIVATE METHODS
#
######################################################################

# iterates the list of files being processed
# and invokes a callback function for each
# file being processed
function __compress.get.files {
	local callback="${1:-}";
	shift;
	if [ -n "$callback" ]; then
		local file;
		for file in "$@"
			do
				# never compress .gz files
				if [[ "$file" =~ \.gz$ ]]; then
					continue;
				fi
				"$callback";
		done
	fi
}

function __compress.deflate {
	local out="${file}.${compress_extension}";
	local nm name;
	fs.basename "$file" "nm";	
	fs.basename "$out" "name";
	local compress_options=( -c --best --force -v "$file" );
	if $compress_debug; then
		console.info "${executables[gzip]} %s 1> %s" "${compress_options[*]}" "$out";
	fi
	local results=( $( { "${executables[gzip]}" "${compress_options[@]}" 1>| "$out"; } 2>&1 ) );
	if [ $? -gt 0 ]; then
		console.quit 1 "failed to compress %s" "";
	fi
	if $compress_verbose; then
		console.info "gzip %s -> %s (%s)" "$nm" "$name" "${results[${#results[@]}-1]}";
	fi
	# also touch the file to set modification time
	# in case it already exists
	touch "$out";
}

# print file information
function __compress.print {
	local size="";
	if $compress_verbose && [ -f "$file" ]; then
		size=( $( du -h "$file" ) );
		size=" ${size[0]}";
	fi
	console.log "${file}%s" "$size";
}

# parse command line options
function __compress.parse {
	# unprocessed options
	local options=();
	
	local value;
	# handle other options
	while [ "${1:-}" != "" ]; do
		case $1 in
			-o | --overwrite )
				compress_overwrite=true;
				;;
			-r | --recursive )
				compress_recursive=true;
				;;
			--debug )
				compress_debug=true;
				;;				
			-v | --verbose )
				compress_verbose=true;
				;;				
			* )
				options+=( "$1" );
				;;
		esac
		if [ $# -ne 0 ]; then
			shift;
		else
			break;
		fi
	done

	# return remaining options back
	_result="${options[@]:-}";
}

function __compress.missing.files {
	console.quit 1 "no files specified";
}