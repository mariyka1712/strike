: <<'ronn:markdown'
task-archive(7) -- archive task(s) for bake(1)
=============================================

## SYNOPSIS

Archive task(s) for bake(1).

## DESCRIPTION

Creates and extracts archives using tar(1) for *tar.gz* and *bz2* files and zip(1) and unzip(1) for *zip* files.

## REQUIRE

In your tasks(7) file `require` the `archive` task(s) using:

	require 'tasks/archive';

## USAGE

	bake archive -c tar [files...]
	bake archive -c bz2	[files...]
	bake archive -c zip [files...]
	bake archive -x tar [archive]
	bake archive -x bz2 [archive]
	bake archive -x zip [archive]

## BUGS

**task-archive** is written in bash and depends upon `bash` >= 4.

## COPYRIGHT

**task-archive** is copyright (c) 2012 muji <http://xpm.io>

## SEE ALSO

bake(1)
ronn:markdown

function tasks.archive {
	
	# the type of archive we are processing
	local archive_type;
	
	# valid archive type identifiers
	local types=( tar bz2 zip );
	
	declare -A extensions
	extensions=(
		[tar]="tar.gz"
		[bz2]="bz2"
		[zip]="zip"
	);
	
	# map of options to command names
	declare -A commands;
	commands=(
		[-c]="create"
		[-x]="extract"
		[create]="create"
		[extract]="extract"
	);
	
	# mapping between archive types
	# and the required executables
	# for simplicity we validate both
	# zip and unzip even though it's
	# *possible* an installation would
	# have one and not the other
	declare -A binaries;
	binaries=(
		[tar]="tar"
		[bz2]="bz2"
		[zip]="zip unzip"
	);
	
	# should always have at least 3 arguments
	if [ $# -lt 3 ]; then
		console.quit 1 "too few options";
	fi
	
	# do command procesing via delegation
	if [ $# -gt 0 ]; then
		local cmd="${1:-}";
		local cmdmethod="${commands[$cmd]:-}";
		if [ -z "$cmdmethod" ]; then
			console.quit 1 "invalid archive command %s" "$1";
		fi
		# remove the command option
		shift;
		
		# validate the archive type
		archive_type="${1:-}";
		__arvhive.type.validate;
		shift;
		
		# validate the required executables are present
		__arvhive.binary.validate;
		
		delegate "arc.${FUNCNAME}" "$cmdmethod" $@;
	fi	
}

function arc.tasks.archive.create {
	local files=( $@ );
	
	echo "$FUNCNAME: $*";
}

function arc.tasks.archive.extract {
	local archive="${1:-}";
	
	if [ ! -f "$archive" ]; then
		console.quit 1 "invalid archive %s" "$archive";
	fi
	
	echo "$FUNCNAME: $* : $archive";
}

######################################################################
#
#	PRIVATE METHODS
#
######################################################################

function __archive.tar.extract {
	local archive="${1:-}";
	local target="${2:-}";
	
	#change into the target directory for extraction
	if [ `pwd` != "$target" ]; then
		cdir "$target" > /dev/null;
	fi
	
	local name=$( basename $archive );
	local extension="${name##*.}";
	local opts;
	
	if [ "$extension" == "gz" ]; then
		opts="xzf";
	elif [ "$extension" == "bz2" ]; then
		opts="xjf";
	else
		console.quit 1 "invalid archive type found %s" "$extension";
	fi
	
	#extract the archive
	console.info "tar %s %s > %s" "$opts" "$name" "$target";
	tar "$opts" "$archive" --directory="$target";
}

function __archive.tar.create {
	local archive="${1:-}";
	local target="${2:-}";
	
	echo "creating archive: $archive : $target";
	
	local dir=$( dirname "$target" );
	local name=$( basename "$target" );
	
	#change into the target directory for extraction
	if [ `pwd` != "$dir" ]; then
		cdir "$dir" > /dev/null;
	fi
	
	console.info "tar czf %s < %s" "$archive" "$target";
	
	#create the archive
	tar czf "$archive" "$name";
}

function __arvhive.binary.validate {
	local exes=( ${binaries[$archive_type]} );
	executable.validate "${exes[@]}";
}

function __arvhive.type.validate {
	if ! array.contains? "${archive_type:-}" "${types[@]}"; then
		console.quit 1 "invalid archive type %s" "${archive_type}";
	fi
}