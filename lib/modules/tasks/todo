: <<'ronn:markdown'
task-todo(7) -- todo task(s) for bake(1)
=============================================

## SYNOPSIS

Task(s) for bake(1) to find *TODO* tags in a project.

## DESCRIPTION

Adds task methods for scanning a project looking for *TODO* tags, use these commands to give your code a sanity check.

## REQUIRE

In your tasks(7) file `require` the `todo` task(s) using:

	require 'tasks/todo';

## USAGE

	bake todo [commands...] [flags...]
	
## COMMANDS

This section describes the command options for task-todo(7). When no command is specified the default behaviour is to call the `scan` command.

* `scan`:

Scan the project `${root}` for files and print *TODO* tags information.
	
The format of the output for each tag found is a comment line (preceeded by a '#' character and a single space) with the tag converted to uppercase followed by a space and then the file path concatenated with the line number using a ':' delimiter, for example:

	# TODO /path/to/project/bin/bake:358
	this is a todo message
	
Output for *BUG* and *FIXME* tags found is redirected to stderr, all other tags found are sent to stdout. This enables easy redirection of these tags to a file using a command such as:

	bake todo scan 2> target/todo.err.log

* `tags`:

The `tags` command prints a list of tag identifiers and the corresponding pattern used to match a tag.
	
The output format for this command is an uppercase tag identifier delimited by the equals sign '=' followed by the pattern used to match the tag.

* `list`:

Use the `list` command to print a list of the files that a scan would match.

* `count`:

Count occurences of tags, this implies the `--silent` option.
	
* `excludes`:

Prints the exclude patterns.

## FLAGS

Flag options for task-todo(7).

* `--silent`:

Makes task-todo(7) mute, this is useful if you are only interested in the exit code.

## FILTER FLAGS

You may specify any tag as an option to switch on tag filtering, when any filter tag option is specified, then only the tags specified are matched. For example, to match only *BUG* tags, use:

	bake todo scan --bug
	
But to include any other tags they must now be specified, so to find *TODO* and *NOTE* tags, use:

	bake todo scan --todo --note

* `--bug`:

Filter for *BUG* tag matches.

* `--fixme`:

Filter for *FIXME* tag matches.

* `--todo`:

Filter for *TODO* tag matches.

* `--note`:

Filter for *NOTE* tag matches.

* `--xxx`:

Filter for *XXX* tag matches.

* `--changed`:

Filter for *CHANGED* tag matches.

* `--deprecated`:

Filter for *DEPRECATED* tag matches.

## TAGS

The following tags are supported by default:

* `BUG`:
	
To mark a known bug.

* `FIXME`:
	
To mark potential problematic code that requires special attention and/or review.

* `TODO`:
	
To indicate planned enhancements.

* `NOTE`:

To document inner workings of code and indicate potential pitfalls.

* `XXX`:

To warn other programmers of problematic or misguiding code.

* `CHANGED`:

To indicate that behaviour or implementation has changed.

* `DEPRECATED`:

To mark code as deprecated.

## EXIT CODES

If any *BUG* or *FIXME* tags are encountered then the program exits with a >0 exit code which is the total number of *BUG* and *FIXME* tags found, otherwise 0.

## BUGS

**task-todo** is written in bash and depends upon `bash` >= 4.

## COPYRIGHT

**task-todo** is copyright (c) 2012 muji <http://xpm.io>

## SEE ALSO

bake(1)
ronn:markdown

# TODO: make scan inclusive with a directory search path by default
# TODO: add --exclusive option to scan exclusively
# TODO: add --todo, --bug etc flags to search only for those tags

# BUG : this is a test bug, no problem really
# TODO : this is a test todo, no problem really
# FIX ME : this is a test fix me, no problem really
# FIXME : this is a test fixme, no problem really
# NOTE : this is a test note, no problem really

declare -ag todo_ignore_patterns;
todo_ignore_patterns=(
	"\.log$"
	"\.tmp$"
	"\.bak$"
	"/\.git/?.*$"
	"\.gitignore$"
	"/target/?.*$"
	"/test/?.*$"
	"/man/?.*$"
	"/doc/?.*$"
	"/tmp/?.*$"
	"\.DS_Store$"
	"/package.json$"	
	"/semver.json$"
	"/version$"
	"/tasks$"
	"/AUTHORS$"
	"/CHANGES$"
	"/LICENSE$"
	"/INSTALL$"
	"/README\.?.*$"
	"/Rakefile$"
);

declare -ag todo_dirs;
todo_dirs=(
	"bin"
	"lib"
	"src"
);

declare -Ag todo_tags;
todo_tags[fixme]="FIX ?ME[ 	,:]+[ 	]*(.*)";
todo_tags[bug]="BUG[ 	,:]+[ 	]*(.*)";
todo_tags[todo]="TODO[ 	,:]+[ 	]*(.*)";
todo_tags[note]="NOTE[ 	,:]+[ 	]*(.*)";
todo_tags[xxx]="XXX[ 	,:]+[ 	]*(.*)";
todo_tags[deprecated]="DEPRECATED[ 	,:]+[ 	]*(.*)";
todo_tags[changed]="CHANGED[ 	,:]+[ 	]*(.*)";

# tasks for working with todo tags
function tasks.todo {
	executable.validate find;	
	
	declare -a files;
	files=();
	
	# custom tags to search for
	declare -a tags;
	tags=();
	
	declare -a all_tags;
	all_tags=( ${!todo_tags[@]} );	
	
	local include_symlinks=false;
	local exclusive=false;
	local silent=false;
	local counting=false;
	
	__todo.options.parse "$@";
	
	# custom tag filters
	if [ ${#tags[@]} -gt 0 ]; then
		local k;
		for k in ${!todo_tags[@]}
			do
				if ! array.contains? "$k" "${tags[@]}"; then
					unset todo_tags[$k];
				fi
		done
	fi
	
	# set up counters
	declare -A count;
	for k in ${all_tags[@]}
		do
			count[$k]=0;
	done
	
	#exit 0;
	
	# do command procesing via delegation
	if [ $# -gt 0 ]; then
		local method="td.${FUNCNAME}.${1}";
		if ! method.exists? "$method"; then
			console.quit 1 "invalid todo command %s" "$1";
		else
			delegate "td.${FUNCNAME}" "$1" ${@:2};
		fi
	else
		# no options specified scan files
		td.tasks.todo.scan;
	fi
}

# print tags
function td.tasks.todo.tags {
	local k p;
	for k in ${!todo_tags[@]}
		do
			p="${todo_tags[$k]}";
			k="${k^^}";
			__todo.log "$k=$p";
	done
	__todo.exit;
}

# print ignore patterns
function td.tasks.todo.excludes {
	local p
	for p in ${todo_ignore_patterns[@]}
		do
			__todo.log "$p";
	done
	__todo.exit;
}

# list matched files
function td.tasks.todo.list {
	__todo.log "# todo list ${root}";
	__todo.list;
	for f in ${files[@]}	
		do
			__todo.log "$f";
	done
	__todo.log "# ${#files[@]} files";
	__todo.exit;
}

# scan and gather tag information
function td.tasks.todo.scan {
	__todo.log "# todo scan %s" "${root}";
	__todo.list;
	for f in ${files[@]}
		do
			__todo.scan.file "$f";
	done
	__todo.summary;
	__todo.exit;
}

# count tags
function td.tasks.todo.count {
	silent=true;
	__todo.list;
	for f in ${files[@]}
		do
			__todo.scan.file "$f";
	done
	__todo.count;
	__todo.exit;
}

######################################################################
#
#	PRIVATE METHODS
#
######################################################################

# parse options
function __todo.options.parse {
	
	# remove command option
	shift;
	
	# build up tag option comparison
	local tag_opts=();
	for k in ${all_tags[@]}
		do
			tags_opts+=( "--${k}" );
	done
	
	# handle custom tag filter flags
	local k;
	for k in ${!todo_tags[@]}
		do
			if array.contains? "--${k}" "$@"; then
				tags+=( "$k" );
			fi
	done
	
	# handle other options
	while [ "${1:-}" != "" ]; do
		if array.contains? "$1" "${tags_opts[@]}"; then
			shift;
			continue;
		fi
		case $1 in
			--silent )
				silent=true;
				;;
			* )
				console.warn "usage: todo [command] [options...]";
				quit 1 "unkown option %s" "$1";
				;;
		esac
		if [ $# -ne 0 ]; then
			shift;
		else
			break;
		fi
	done
}

function __todo.excludes? {
	local replace="${2:-}";
	local file="$1";
	
	if [ -n "$replace" ]; then
		# remove any trailing slash from the replacement
		replace="${replace/\$/}";
		file="${file#$replace}";
	fi
	
	# echo "testing exclude on $1 with ${#todo_ignore_patterns[@]}";
	local p;
	for p in ${todo_ignore_patterns[@]}
		do	
			# skip symbolic links
			if ! $include_symlinks && [ -L "$1" ]; then
				# echo "omitting symlink $1";
				return 0;				
			fi
			# skip on pattern match
			if [[ "$file" =~ $p ]]; then
				# echo "excluded : $file on $p";
				return 0;
			fi
	done
	return 1;
}

function __todo.find {
	files+=( $( "${executables[find]}" "$1" -type f ) );
}

# get all files
function __todo.list {
	if $exclusive; then
		local IFS="
	";
		#files=( $( find "${root}" -type f ) );
		__todo.find "${root}";
		unset IFS;
		local k f;
		for k in ${!files[@]}
			do
				f="${files[$k]}";
				if __todo.excludes? "$f" "${root}" || [ ! -r "$f" ]; then
					unset files[$k];
				fi
		done
	else
		local dir;
		for dir in ${todo_dirs[@]}
			do
				dir="${dir#/}";
				dir="${root}/${dir}";
				if [ -d "$dir" ]; then
					__todo.find "$dir";
				fi
		done
	fi
}

# test if a line matches a tag pattern
function __todo.line.matches? {
	local tag p todo;
	for tag in ${!todo_tags[@]}
		do	
			p="${todo_tags[$tag]}";
			if [ -n "$p" ]; then
				# echo "matching line with  $p : $line";
				if [[ "$line" =~ $p ]]; then
					todo="${BASH_REMATCH[1]:-}";
					__todo.output;
					return 0;
				fi
			fi
	done
	return 1;
}

# scan a file
function __todo.scan.file {
	# console.info "scanning %s" "$1";
	local lineno=0;
	local file="$1";
	while read line
		do
			((lineno++));			
			# echo "got line ... $line";
			if __todo.line.matches? "$line"; then
				continue;
			fi
	done < "$file";
}

# log output
function __todo.log {
	if ! $silent; then
		console.log "$@";	
	fi
}

# output todo tag information
function __todo.output {
	((count[$tag]++));
	if ! $silent; then
		local frame="${file}:${lineno}";
		tag="${tag^^}";
		string.ltrim "$todo";
		todo="${_result}";
		if [ "$tag" == "BUG" ] || [ "$tag" == "FIXME" ]; then
			echo "# $tag $frame" >&2;
			echo "$todo" >&2;
		else
			console.log "# %s %s" "$tag" "$frame";
			console.log "$todo";
		fi
	fi
}

# print the count summary
function __todo.summary {
	if ! $silent; then
		string.repeat "+" 80;
		local header="$_result";	
		echo "$header";
		__todo.count;
		echo "$header";
	fi
}

function __todo.count {
	local k v;
	for k in ${!count[@]}
		do
			# tag filtering
			if [ ${#tags[@]} -gt 0 ] && ! array.contains? "$k" "${tags[@]}"; then
				continue;
			fi
			v="${count[$k]}";
			k="${k^^}";
			echo "$k: $v";
	done
}

#exit program
function __todo.exit {
	if [ ${#count[bug]} -gt 0 ] || [ ${#count[fixme]} -gt 0 ]; then
		local total=$(( ${count[bug]} + ${count[fixme]} ));
		console.quit $total;
	else
		console.quit 0;
	fi
}