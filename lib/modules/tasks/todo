: <<'ronn:markdown'
task-todo(7) -- todo task(s) for bake(1)
=============================================

## SYNOPSIS

Task(s) for bake(1) to find *TODO* tags in a project.

## DESCRIPTION

Adds task methods for scanning a project looking for *TODO* tags, use these commands to give your code a sanity check.

## REQUIRE

In your tasks(7) file `require` the `todo` task(s) using:

	require 'tasks/todo';

## USAGE

	bake todo [commands...] [flags...]
	
## COMMANDS

Command options for task-todo(7).

* `scan`:

Scan the project `${root}` for files and print *TODO* tags information.
	
The format of the output for each tag found is a comment line (preceeded by a '#' character and a single space) with the tag converted to uppercase followed by a space and then the file path concatenated with the line number using a ':' delimiter, for example:

	# TODO /path/to/project/bin/bake:358
	this is a todo message string
	
Output for *BUG* and *FIXME* tags found is redirected to stderr, all other tags found are sent to stdout. This enables easy redirection of these tags to a file using a command such as:

	bake todo scan 2> target/todo.err.log

* `tags`:

The `tags` command prints a list of tag identifiers and the corresponding pattern used to match a tag.
	
The output format for this command is an uppercase tag identifier delimited by the equals sign '=' followed by the pattern used to match the tag.

* `list`:

Use the `list` command to print a list of the files that a scan would match.
	
* `excludes`:

Prints the exclude patterns.

## FLAGS

Flag options for task-todo(7).

* `--silent`:

Makes task-todo(7) mute, this is useful if you are only interested in the exit code.

## TAGS

The following tags are supported by default:

* `BUG`:
	
To mark a known bug.

* `FIXME`:
	
To mark potential problematic code that requires special attention and/or review.

* `TODO`:
	
To indicate planned enhancements.

* `NOTE`:

To document inner workings of code and indicate potential pitfalls.

* `XXX`:

To warn other programmers of problematic or misguiding code.

* `CHANGED`:

To indicate that behaviour or implementation has changed.

* `DEPRECATED`:

To mark code as deprecated.

## EXIT CODES

If any *BUG* or *FIXME* tags are encountered then the program exits with a >0 exit code which is the total number of *BUG* and *FIXME* tags found, otherwise 0.

## BUGS

**task-todo** is written in bash and depends upon `bash` >= 4.

## COPYRIGHT

**task-todo** is copyright (c) 2012 muji <http://xpm.io>

## SEE ALSO

bake(1)
ronn:markdown

# TODO: make scan inclusive with a directory search path by default
# TODO: add --exclusive option to scan exclusively

# BUG : this is a bug

declare -ag todo_ignore_patterns;
todo_ignore_patterns=(
	"\.log$"
	"\.tmp$"
	"\.bak$"
	"/\.git/?.*$"
	"\.gitignore$"
	"/target/?.*$"
	"/test/?.*$"
	"/man/?.*$"
	"/doc/?.*$"
	"/tmp/?.*$"
	"\.DS_Store$"
	"/package.json$"	
	"/semver.json$"
	"/version$"
	"/tasks$"
	"/AUTHORS$"
	"/CHANGES$"
	"/LICENSE$"
	"/INSTALL$"
	"/README\.?.*$"
	"/Rakefile$"
);

declare -Ag todo_tags;
todo_tags[fixme]="FIX ?ME[ 	,:]+[ 	]*(.*)";
todo_tags[bug]="BUG[ 	,:]+[ 	]*(.*)";
todo_tags[todo]="TODO[ 	,:]+[ 	]*(.*)";
todo_tags[note]="NOTE[ 	,:]+[ 	]*(.*)";
todo_tags[xxx]="XXX[ 	,:]+[ 	]*(.*)";
todo_tags[deprecated]="DEPRECATED[ 	,:]+[ 	]*(.*)";
todo_tags[changed]="CHANGED[ 	,:]+[ 	]*(.*)";

# tasks for working with todo tags
function tasks.todo {
	declare -a files;
	
	local include_symlinks=false;
	local exclusive=true;
	local silent=false;
	local counting=false;
	
	# parse flags
	if array.contains? "--silent" "$@"; then
		silent=true;
	fi
	
	# set up counters
	declare -A count;
	for k in ${!todo_tags[@]}
		do
			count[$k]=0;
	done
		
	
	# do command procesing via delegation
	if [ $# -gt 0 ]; then
		local method="td.${FUNCNAME}.${1}";
		if ! method.exists? "$method"; then
			console.quit 1 "invalid todo command %s" "$1";
		else
			delegate "td.${FUNCNAME}" "$1" ${@:2};
		fi
	else
		# no options specified scan files
		td.tasks.todo.scan;
	fi
}

# print tags
function td.tasks.todo.tags {
	local k p;
	for k in ${!todo_tags[@]}
		do
			p="${todo_tags[$k]}";
			k="${k^^}";
			__todo.log "$k=$p";
	done
	__todo.exit;
}

# print ignore patterns
function td.tasks.todo.excludes {
	local p
	for p in ${todo_ignore_patterns[@]}
		do
			__todo.log "$p";
	done
	__todo.exit;
}

# list matched files
function td.tasks.todo.list {
	__todo.log "# todo list ${root}";
	__todo.list;
	for f in ${files[@]}	
		do
			__todo.log "$f";
	done
	__todo.log "# ${#files[@]} files";
	# echo "exiting from list";	
	__todo.exit;
}

# scan and gather tag information
function td.tasks.todo.scan {
	__todo.log "# todo scan %s" "${root}";
	__todo.list;
	for f in ${files[@]}
		do
			__todo.scan.file "$f";
	done
	__todo.summary;
	__todo.exit;
}

######################################################################
#
#	PRIVATE METHODS
#
######################################################################

function __todo.excludes? {
	local replace="${2:-}";
	local file="$1";
	
	if [ -n "$replace" ]; then
		# remove any trailing slash from the replacement
		replace="${replace/\$/}";
		file="${file#$replace}";
	fi
	
	# echo "testing exclude on $1 with ${#todo_ignore_patterns[@]}";
	local p;
	for p in ${todo_ignore_patterns[@]}
		do	
			# skip symbolic links
			if ! $include_symlinks && [ -L "$1" ]; then
				# echo "omitting symlink $1";
				return 0;				
			fi
			# skip on pattern match
			if [[ "$file" =~ $p ]]; then
				# echo "excluded : $file on $p";
				return 0;
			fi
	done
	return 1;
}

# get all files
function __todo.list {
	if $exclusive; then
		local IFS="
	";
		files=( $( find "${root}" -type f ) );
		unset IFS;
		local k f;
		for k in ${!files[@]}
			do
				f="${files[$k]}";
				if __todo.excludes? "$f" "${root}" || [ ! -r "$f" ]; then
					unset files[$k];
				fi
		done
	# TODO: implement inclusive scanning
	fi
}

# test if a line matches a tag pattern
function __todo.line.matches? {
	local tag p todo;
	for tag in ${!todo_tags[@]}
		do	
			p="${todo_tags[$tag]}";
			if [ -n "$p" ]; then
				# echo "matching line with  $p : $line";
				if [[ "$line" =~ $p ]]; then
					todo="${BASH_REMATCH[1]:-}";
					__todo.output;
					return 0;
				fi
			fi
	done
	return 1;
}

# scan a file
function __todo.scan.file {
	# console.info "scanning %s" "$1";
	local lineno=0;
	local file="$1";
	while read line
		do
			((lineno++));			
			# echo "got line ... $line";
			if __todo.line.matches? "$line"; then
				continue;
			fi
	done < "$file";
}

# log output
function __todo.log {
	if ! $silent; then
		console.log "$@";	
	fi
}

# output todo tag information
function __todo.output {
	((count[$tag]++));
	if ! $silent; then
		local frame="${file}:${lineno}";
		tag="${tag^^}";
		string.ltrim "$todo";
		todo="${_result}";
		if [ "$tag" == "BUG" ] || [ "$tag" == "FIXME" ]; then
			echo "# $tag $frame" >&2;
			echo "$todo" >&2;
		else
			console.log "# %s %s" "$tag" "$frame";
			console.log "$todo";
		fi
	fi
}

# print the count summary
function __todo.summary {
	string.repeat "+" 80;
	local header="$_result";
	echo "$header";
	local k v;
	for k in ${!count[@]}
		do
			v="${count[$k]}";
			k="${k^^}";
			echo "$k: $v";
	done
	echo "$header";
}

#exit program
function __todo.exit {
	if [ ${count[todo]} -gt 0 ] || [ ${count[fixme]} -gt 0 ]; then
		local total=$(( ${count[bug]} + ${count[fixme]} ));
		console.quit $total;
	else
		console.quit 0;
	fi
}