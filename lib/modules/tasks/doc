: <<'ronn:markdown'
task-doc(7) -- documentation task(s) for bake(1)
=============================================

## SYNOPSIS

Collection of documentation tasks for bake(1).

## DESCRIPTION

Adds task methods for generating and compiling inline heredoc documentation.

## REQUIRE

You do not need to require(3) this task as it is a builtin task.

## USAGE

	bake doc.build

## METHODS

The following commands are then available to bake(1):

* `doc.all`:
	Invokes `doc.build` and `doc.pages.push`.

* `doc.build`:
	Invokes `doc.generate`, `doc.compile` and `doc.man.import`.

* `doc.generate`:
	Searches the doc search paths and attempts to find inline heredoc declarations in any files within the search paths. When an inline heredoc is encountered a corresponding `.ronn` file is generated in `${target}/doc`.
	
	If a file is encountered that has a `.ronn` extension then that file is not parsed for heredoc declarations but is copied to the output directory for inclusion in the generated documentation.
	
* `doc.compile`:
	Compiles any `.ronn` documents previously generated using the `doc.generate` task.
	
* `doc.pages.push`:
	Switches to a `gh-pages` branch, copies over generated documentation before pushing the `gh-pages` branch to github(7). The `gh-pages` branch must already exist for this command to succeed.
	
* `doc.man.import`:
	Copies compiled man pages into `${root}/man`.
	
* `doc.man.clean`:
	Removes man pages from `${root}/man`.

## BUGS

**task-doc** is written in bash and depends upon `bash` >= 4.

## COPYRIGHT

**task-doc** is copyright (c) 2012 muji <http://xpm.io>

## SEE ALSO

bake(1)
ronn:markdown

function tasks.initialize {
	executable.validate 'ronn' 'git';
}

# generates, compiles and imports man pages
function tasks.doc.all {
	tasks.doc.build && tasks.doc.pages.push;
}

# generates, compiles and imports man pages
function tasks.doc.build {
	tasks.doc.generate && tasks.doc.compile && tasks.doc.man.import;
}

# generates ronn markdown documentation
# from inline ronn:markdown heredoc
function tasks.doc.generate {
	__tasks.doc.output;
	local output="$_result";
	
	if [ ! -d "$output" ]; then
		mkdir -p "$output";
	fi
	
	__tasks.doc.path;
	local paths=( "$_result" );
	local path;
	for path in ${paths[@]}
		do
			__tasks.doc.walk "$path";
	done
}

# removes man pages exported to ${root}/man
function tasks.doc.man.clean {
	local man="${root}/man";
	# clean any existing man pages
	local cmd="rm -fv "${man}/*"";
	eval $cmd;
}

# imports the compiled man page(s) into ${root}/man
function tasks.doc.man.import {
	local man="${root}/man";
	local mantmp="${target}/doc";
	if [ ! -d "$man" ]; then
		mkdirp "$man";
	fi

	tasks.doc.man.clean;

	# copy over man pages
	local i cmd;
	for i in {1..8}
		do
			cmd="cp -v "${mantmp}/*.${i}" "${man}"";
			eval $cmd > /dev/null 2>&1;
	done
	return 0;
}

# generates the man page documentation
# and attempts to push the gh-pages branch
# before switching back to develop
function tasks.doc.pages.push {
	local ronn="${executables[ronn]}";
	local git="${executables[git]}";
	local man="${target}/doc";
	
	# __man_copy;
	
	# $git stash;
	
	#$git status; echo $?;
	
	# check out the gh-pages branch
	$git checkout gh-pages > /dev/null 2>&1 || quit 1 "could not checkout gh-pages branch, may be dirty";
	
	# $ronn -w -s toc -r5 --markdown ${man}/*.ronn;
	
	# copy over the temporary man pages
	cmd="cp -rfv "${man}/*" "${root}"";
	cd "${root}" \
		&& rm -fv ./*.html \
		&& eval "$cmd" \
		&& $git add . \
		&& $git commit -a -m "doc rebuild" \
		&& $git ls-files \
		&& $git push origin gh-pages \
		|| { $git checkout develop && quit 1 "could not rebuild docs"; };
	
	# switch back to the develop branch
	$git checkout develop;
	
	# $git stash apply;
}

# compiles generated .ronn files to markdown and html
function tasks.doc.compile {
	
	# copy over assets
	__tasks.doc.assets.copy;
	
	__tasks.doc.output;
	local output="$_result";
	local ronn="${executables[ronn]}";
	$ronn -w -s toc -r5 --markdown ${output}/*.ronn;
}

function __tasks.doc.assets.copy {
	__tasks.doc.assets;
	local assets=( "$_result" );
	__tasks.doc.output;
	local output="$_result";
	local a;
	for a in ${assets[@]}
		do
			cp -rfv "$a" "$output" 2> /dev/null;
	done
}

# walk a directory containing heredoc candidates
function __tasks.doc.walk {
	local path="$1";
	if [ -d "$path" ]; then
		local file;
		for file in ${path}/*
			do
				# parse any files found
				if [ -f "$file" ]; then
					if [[ "$file" =~ .ronn$ ]]; then
						cp "$file" "$output" || quit 1 "could not copy %s" "$file";
					else
						__tasks.doc.parse "$output" "$file";
					fi
				# recurse into nested sub-directories
				elif [ -d "$file" ]; then
					__tasks.doc.walk "$file";
				fi
		done
	fi
}

# parse heredoc in a file
function __tasks.doc.parse {
	local output="$1";
	local file="$2";
	local name="`basename $file`";
	local ext="ronn";
	local outputfile="${output}/${name}.${ext}";
	
	local docstart="${3:-": <<'ronn:markdown'"}";
	local docend="${4:-"ronn:markdown"}";
	
	local apidoc=": <<'api:ronn:markdown'";	
	local api=0;
	
	local inside=0;
	local heredoc="";
	local filename="";
	local IFS="
";
	while read line
		do
			#echo "got line $line";
			if [ "$line" == "$docstart" ]; then
				# echo "got docstart on file : $file";
				inside=1;
				continue;
			fi
			
			if [ "$line" == "$docend" ]; then
				# echo "got docend on file : $file : $heredoc";
				inside=0;
				continue;
			fi
			
			#echo "got line: $line";
			
			if [ "$line" == "$apidoc" ] && [ "$docstart" != "$apidoc" ]; then
				api=1;
			fi

			if [ $inside -eq 1 ]; then

				# parse .ronn file name
				if [ -z "$heredoc" ] && [ -z "$filename" ] && [ ! -z "$line" ]; then
					filename=${line%% *};
					filename=${filename%)};
					filename=${filename//(/.};
					outputfile="${output}/${filename}.${ext}";
				fi
				
				# ensure the newline is present after each line
				heredoc="${heredoc}${line}
";
			fi
	done < "$file";
	if [ ! -z "$heredoc" ]; then
		echo -n "$heredoc" > "$outputfile" && info "generated %s" "$outputfile";
	fi
	
	# also got some api documentation to parse
	if [ "$api" -eq 1 ]; then
		__tasks.doc.parse "$output" "$file" "$apidoc" "api:ronn:markdown";
	fi
	unset IFS;
}

# retrieves the doc search paths
function __tasks.doc.path {
	local paths=(
		"${root}/bin"
		"${root}/lib/modules"
	);
	_result="${paths[@]}";
}

# retrieves the doc generate output directory
function __tasks.doc.output {
	_result="${target}/doc";
}

# retrieves a list of assets to be copied prior to compilation
function __tasks.doc.assets {
	local assets=(
		"${root}/doc/index.txt"
		"${root}/doc/index.html"
		"${root}/doc/assets"
	);
	_result="${assets[@]}";
}