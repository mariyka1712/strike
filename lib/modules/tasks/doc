: <<'ronn:markdown'
tasks-doc(7) -- documentation tasks for bake
=============================================

## SYNOPSIS

Collection of documentation tasks for bake(1).

## DESCRIPTION

Adds task methods for generating and compiling inline heredoc documentation.

## USAGE

	bake doc.build

## REQUIRE

In your tasks(7) file `require` the `doc` tasks using:

	require 'tasks/doc';

## METHODS

The following commands are then available to bake(1):

* `doc.all`:
	Invokes `doc.build` and `doc.pages.publish`.

* `doc.build`:
	Invokes `doc.generate`, `doc.compile` and `doc.man.import`.

* `doc.generate`:
	Searches the doc search paths and attempts to find inline heredoc declarations in any files within the search paths. When an inline heredoc is encountered a corresponding `.ronn` file is generated in `${target}/doc`.
	
* `doc.compile`:
	Compiles any `.ronn` documents previously generated using the `doc.generate` task.
	
* `doc.pages.publish`:
	Switches to a `gh-pages` branch, copies over generated documentation before pushing the `gh-pages` branch to github(7). The `gh-pages` branch must already exist for this command to succeed.
	
* `doc.man.import`:
	Copies compiled man pages into `${root}/man`.
	
* `doc.man.clean`:
	Removes man pages from `${root}/man`.

## BUGS

**tasks-doc** is written in bash and depends upon `bash` >= 4.

## COPYRIGHT

**tasks-doc** is copyright (c) 2012 muji <http://xpm.io>

## SEE ALSO

bake(1), strike(1), require(7)
ronn:markdown

function tasks.initialize {
	executable validate 'ronn' 'git';
}

# generates, compiles and imports man pages
function tasks.doc.all {
	tasks.doc.build && tasks.doc.pages.publish;
}

# generates, compiles and imports man pages
function tasks.doc.build {
	tasks.doc.generate && tasks.doc.compile && tasks.doc.man.import;
}

# generates ronn markdown documentation
# from inline ronn:markdown heredoc
function tasks.doc.generate {
	__tasks.doc.output;
	local output="$_result";
	
	if [ ! -d "$output" ]; then
		mkdir -p "$output";
	fi
	
	__tasks.doc.path;
	local paths=( "$_result" );
	local path;
	for path in ${paths[@]}
		do
			__tasks.doc.walk "$path";
	done
}

# removes man pages exported to ${root}/man
function tasks.doc.man.clean {
	local man="${root}/man";
	# clean any existing man pages
	local cmd="rm -fv "${man}/*"";
	eval $cmd;
}

# imports the compiled man page(s) into ${root}/man
function tasks.doc.man.import {
	local man="${root}/man";
	local mantmp="${target}/doc";
	if [ ! -d "$man" ]; then
		mkdirp "$man";
	fi

	tasks.doc.man.clean;

	# copy over man pages
	local i cmd;
	for i in {1..8}
		do
			cmd="cp -v "${mantmp}/*.${i}" "${man}"";
			eval $cmd > /dev/null 2>&1;
	done
	return 0;
}

# generates the man page documentation
# and attempts to push the gh-pages branch
# before switching back to develop
function tasks.doc.pages.publish {
	local ronn="${executables[ronn]}";
	local git="${executables[git]}";
	local man="${target}/doc";
	
	# __man_copy;
	
	# check out the gh-pages branch
	$git checkout gh-pages > /dev/null 2>&1 || quit 1 "could not checkout gh-pages branch, may be dirty";
	
	# $ronn -w -s toc -r5 --markdown ${man}/*.ronn;
	
	# copy over the temporary man pages
	cmd="cp -fv "${man}/*" "${root}"";
	cd "${root}" \
		&& rm -fv ./*.html \
		&& eval "$cmd" \
		&& $git add . \
		&& $git commit -a -m "doc rebuild" \
		&& $git ls-files \
		&& $git push origin gh-pages \
		|| { $git checkout develop && quit 1 "could not rebuild docs"; };
	
	# switch back to the develop branch
	$git checkout develop;
}

# compiles generated .ronn files to markdown and html
function tasks.doc.compile {
	
	# copy over assets
	__tasks.doc.assets.copy;
	
	__tasks.doc.output;
	local output="$_result";
	local ronn="${executables[ronn]}";
	$ronn -w -s toc -r5 --markdown ${output}/*.ronn;
}

function __tasks.doc.assets.copy {
	__tasks.doc.assets;
	local assets=( "$_result" );
	__tasks.doc.output;
	local output="$_result";
	local a;
	for a in ${assets[@]}
		do
			cp -rfv "$a" "$output" 2> /dev/null;
	done
}

# walk a directory containing heredoc candidates
function __tasks.doc.walk {
	local path="$1";
	if [ -d "$path" ]; then
		local file;
		for file in ${path}/*
			do
				# parse any files found
				if [ -f "$file" ]; then
					__tasks.doc.parse "$output" "$file";
				# recurse into nested sub-directories
				elif [ -d "$file" ]; then
					__tasks.doc.walk "$file";
				fi
		done
	fi
}

# parse heredoc in a file
function __tasks.doc.parse {
	local output="$1";
	local file="$2";
	local name="`basename $file`";
	local ext="ronn";
	local outputfile="${output}/${name}.${ext}";
	
	local docstart=": <<'ronn:markdown'";
	local docend="ronn:markdown";
	
	local inside=0;
	local heredoc="";
	local IFS="
";
	while read line
		do
			#echo "got line $line";
			if [ "$line" == "$docstart" ]; then
				# echo "got docstart on file : $file";
				inside=1;
				continue;
			fi
			
			if [ "$line" == "$docend" ]; then
				# echo "got docend on file : $file : $heredoc";
				inside=0;
				continue;
			fi
			
			if [ $inside -eq 1 ]; then
				# ensure the newline is present after each line
				heredoc="${heredoc}${line}
";
			fi
	done < "$file";
	if [ ! -z "$heredoc" ]; then
		echo -n "$heredoc" > "$outputfile" && info "generated %s" "$outputfile";
	fi
}

# retrieves the doc search paths
function __tasks.doc.path {
	local paths=(
		"${root}/bin"
		"${root}/lib/modules"
	);
	_result="${paths[@]}";
}

# retrieves the doc generate output directory
function __tasks.doc.output {
	_result="${target}/doc";
}

# retrieves a list of assets to be copied prior to compilation
function __tasks.doc.assets {
	local assets=(
		"${root}/doc/index.txt"
		"${root}/doc/index.html"
		"${root}/doc/assets"
	);
	_result="${assets[@]}";
}