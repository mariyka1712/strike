: <<'ronn:markdown'
tasks-doc(7) -- documentation tasks for bake
=============================================

## SYNOPSIS

Collection of documentation tasks for bake(1).

## DESCRIPTION

Adds task methods for generating and compiling inline heredoc documentation.

## USAGE

In your tasks(7) file `require` the `doc` tasks using:

	require 'tasks/doc';
	
You can then generate and compile the documentation with:

	`bake doc.generate`<br />
	`bake doc.compile`<br />

## METHODS

The following commands are then available to bake(1):

* `doc.generate`:
	Searches the doc search paths and attempts to find inline heredoc declarations in any files within the search paths. When an inline heredoc is encountered a corresponding `.ronn` file is generated in `${target}/doc`.
	
* `doc.compile`:
	Compiles any `.ronn` documents previously generated using the `doc.generate` task.

## BUGS

**tasks-doc** is written in bash and depends upon `bash` >= 4.

## COPYRIGHT

**tasks-doc** is copyright (c) 2012 muji <http://xpm.io>

## SEE ALSO

bake(1), strike(1)
ronn:markdown

function tasks.initialize {
	executable validate 'ronn';
}

# generates ronn markdown documentation
# from inline ronn:markdown heredoc
function tasks.doc.generate {
	__tasks.doc.output;
	local output="$_result";
	
	if [ ! -d "$output" ]; then
		mkdir -p "$output";
	fi
	
	__tasks.doc.path;
	local paths=( "$_result" );
	local path;
	for path in ${paths[@]}
		do
			__tasks.doc.walk "$path";
	done
}

# compiles generated .ronn files to markdown and html
function tasks.doc.compile {
	
	# copy over assets
	__tasks.doc.assets.copy;
	
	__tasks.doc.output;
	local output="$_result";
	local ronn="${executables[ronn]}";
	$ronn -w -s toc -r5 --markdown ${output}/*.ronn;
}

function __tasks.doc.assets.copy {
	__tasks.doc.assets;
	local assets=( "$_result" );
	__tasks.doc.output;
	local output="$_result";
	local a;
	for a in ${assets[@]}
		do
			cp -rfv "$a" "$output" 2> /dev/null;
	done
}

# walk a directory containing heredoc candidates
function __tasks.doc.walk {
	local path="$1";
	if [ -d "$path" ]; then
		local file;
		for file in ${path}/*
			do
				# parse any files found
				if [ -f "$file" ]; then
					__tasks.doc.parse "$output" "$file";
				# recurse into nested sub-directories
				elif [ -d "$file" ]; then
					__tasks.doc.walk "$file";
				fi
		done
	fi
}

# parse heredoc in a file
function __tasks.doc.parse {
	local output="$1";
	local file="$2";
	local name="`basename $file`";
	local ext="ronn";
	local outputfile="${output}/${name}.${ext}";
	
	local docstart=": <<'ronn:markdown'";
	local docend="ronn:markdown";
	
	local inside=0;
	local heredoc="";
	while read line
		do
			#echo "got line $line";
			if [ "$line" == "$docstart" ]; then
				# echo "got docstart on file : $file";
				inside=1;
				continue;
			fi
			
			if [ "$line" == "$docend" ]; then
				# echo "got docend on file : $file : $heredoc";
				inside=0;
				continue;
			fi
			
			if [ $inside -eq 1 ]; then
				# ensure the newline is present after each line
				heredoc="${heredoc}${line}
";
			fi
	done < "$file";
	if [ ! -z "$heredoc" ]; then
		echo -n "$heredoc" > "$outputfile" && info "generated %s" "$outputfile";
	fi
}

# retrieves the doc search paths
function __tasks.doc.path {
	local paths=(
		"${root}/bin"
		"${root}/lib/modules"
	);
	_result="${paths[@]}";
}

# retrieves the doc generate output directory
function __tasks.doc.output {
	_result="${target}/doc";
}

function __tasks.doc.assets {
	local assets=(
		"${root}/doc/index.txt"
		"${root}/doc/index.html"
		"${root}/doc/assets"
	);
	_result="${assets[@]}";
}