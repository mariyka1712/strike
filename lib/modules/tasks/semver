: <<'ronn:markdown'
task-semver(7) -- semver task(s) for bake(1)
=============================================

## SYNOPSIS

Task(s) for bake(1) that handle working with the semantic versioning specification.

## DESCRIPTION

Command methods for semantic versioning, including semver(7) validation and creation of a project version descriptor.

## REQUIRE

In your tasks(7) file `require` the `semver` task(s) using:

	require 'tasks/semver';

## COMMANDS

* `semver`:
	
Use the `semver` command to generate task-semver(7) files.

	bake semver
	
If no files are available you will be prompted to enter a semver(7) compatible version to initialize the files with.
	
If a *package.json* file is available then the semver(7) string is read from the `version` field and the `version` and `semver.json` files are generated.
	
* `semver read`:
	
To view version information use the `semver.read` command.

	bake semver read
	
If no task-semver(7) files are present this command will exit with a non-zero exit code, otherwise it will print warnings for any missing files.

* `semver test`:

To validate a semver(7) use the `semver.test` command.

	bake semver test 1.2.0-alpha.1+build.12f4e9
	
## FILES

All files are stored in the `${root}` of the project. The rules for file precedence are the order described below, so a npm(1) *package.json* takes precedence, followed by a `version` file and finally a `semver.json` file is used if available.

### PACKAGE

An npm(1) package descriptor (*package.json*) that stores semver(7) information in the `version` field.

### VERSION

A text file (*version*) containing the current semver(7) version.

### SEMVER

A JSON document (*semver.json*) generated by task-semver(7) containing version information for the project.

## BUGS

**task-semver** is written in bash and depends upon `bash` >= 4.

## COPYRIGHT

**task-semver** is copyright (c) 2012 muji <http://xpm.io>

## SEE ALSO

bake(1), semver(3), semver(7)
ronn:markdown

require.once 'semver';
require.once 'json';

# tasks for working with semver data
function tasks.semver {
	
	# gather file information
	declare -A files;
	__semver.package.file;
	files[package]="$_result";
	__semver.version.file;
	files[version]="$_result";	
	__semver.file;
	files[semver]="$_result";
	
	# store of semver strings
	declare -A versions;
	versions[package]="";
	versions[version]="";
	versions[semver]="";

	# parse semver strings where possible	
	if __semver.package.file.exists?; then
		__semver.package.parse;
		versions[package]="$_result";
	fi
	if __semver.version.file.exists?; then
		__semver.version.parse;
		versions[version]="$_result";
	fi
	
	# do command procesing via delegation
	if [ $# -gt 0 ]; then
		local method="sv.${FUNCNAME}.${1}";
		if ! method.exists? "$method"; then
			console.quit 1 "invalid semver command $1";
		else
			delegate "sv.${FUNCNAME}" "$1" "${@:2}";
		fi
	else
		# no options specified generate files
		echo "generate files !";
	fi
	
	# local packagestr="";
	# declare -A semverdoc;
	# 
	# # TODO: request a semver from stdin if nothing is available !
	# 
	# # create initial semver files from package.json
	# if ! __semver.file.exists? && __semver.package.file.exists?; then
	# 	console.info "%s < %s" "${files[semver]}" "$_result";
	# 	
	# 	# parse the package descriptor semver
	# 	__semver.package.parse;
	# 	packagestr="$_result";
	# 	
	# 	if ! semver.valid? "$packagestr"; then
	# 		__semver.invalid.quit "$packagestr";
	# 	else			
	# 		
	# 		# got a valid semver string from the package descriptor
	# 		semverdoc[generator]="task-semver(7), do not edit this file manually use bake(1) with task-semver(7)";
	# 		semverdoc[semver.version]="$packagestr";
	# 		semver.callback() {
	# 			local keys=( ${!semver[@]} );
	# 			local key val;
	# 			for key in ${keys[@]}
	# 				do
	# 					val="${semver[$key]}";
	# 					semverdoc["semver.${key}"]="$val";
	# 			done
	# 			
	# 			
	# 			# encoded the semver data to a JSON document
	# 			json.stringify <<< "semverdoc";
	# 			# create the semver.json file
	# 			json.string > "${files[semver]}" || __semver.file.write.quit "${files[semver]}";				
	# 			
	# 			# create the version file
	# 			__semver.version.file.write! "$packagestr";
	# 			
	# 			# print semver status information
	# 			__semver.print;
	# 		}
	# 		
	# 		# parse the retrieved semver
	# 		semver.parse "$packagestr" "semver.callback";
	# 		
	# 		method.remove "semver.callback";
	# 	fi
	# # files exist - manage version information
	# elif __semver.file.exists?; then
	# 	console.info "semver file %s exists" "${files[semver]}";
	# fi
	# return 0;
}

# tests if a semver is valid
function sv.tasks.semver.test {
	local semver;
	if [ $# -eq 0 ]; then
		console.quit 1 "no semver specified to test";
	else
		if semver.valid? "$1"; then
			console.info "semver %s is ok" "$1";
		else
			__semver.invalid.warn "$1";
			__semver.invalid.quit "$1";
		fi
	fi
}

# read semver information
function sv.tasks.semver.read {
	__semver.print;
}

######################################################################
#
#	PRIVATE METHODS
#
######################################################################

# prints all available version information
function __semver.print {
	if [ ! -f "${files[semver]}" ] && [ ! -f "${files[package]}" ] && [ ! -f "${files[version]}" ]; then
		__semver.files.missing.quit;
	else
		# package.json
		if [ -f "${files[package]}" ] && [ -r "${files[package]}" ]; then
			if semver.valid? "${versions[package]}"; then
				__semver.file.semver.info "${versions[package]}" "${files[package]}";
			else
				__semver.invalid.warn "${versions[package]}";
			fi
		else
			__semver.file.missing.warn "${files[package]}";
		fi
		
		# version
		if [ -f "${files[version]}" ] && [ -r "${files[version]}" ]; then
			__semver.file.semver.info "${versions[version]}" "${files[version]}";
		else
			__semver.file.missing.warn "${files[version]}";
		fi
		
		# semver.json
		if [ -f "${files[semver]}" ] && [ -r "${files[semver]}" ]; then
			__semver.file.semver.info "${versions[semver]}" "${files[semver]}";
		else
			__semver.file.missing.warn "${files[semver]}";
		fi
		
		# print useful information if some files are missing
		__semver.missing.files.info;
	fi
}

function __semver.version.file.write! {
	local version="${1:-}";
	echo "$version" > "${files[version]}" || __semver.file.write.quit "${files[version]}";
	return 0;
}

# parse a version string from the `package.json` file
function __semver.package.parse {
	json.parse < "${files[package]}";
	_result="${json_doc[version]:-}";
	# clean the parsed json data, we're done
	json.clean;
}

# parse a version string from the `version` file
function __semver.version.parse {
	_result=`cat "${files[version]}"`;
}

# path to the package descriptor
function __semver.package.file {
	_result="${root}/package.json";
}

# path to version file
function __semver.version.file {
	_result="${root}/version";
}

# path to the semver file
function __semver.file {
	_result="${root}/semver.json";
}

# determine if a package descriptor exists
function __semver.package.file.exists? {
	test -f "${files[package]}";
}

# determine if a version file exists
function __semver.version.file.exists? {
	test -f "${files[version]}";
}

# determine if a semver json file exists
function __semver.file.exists? {
	test -f "${files[semver]}";
}

######################################################################
#
#	PRIVATE OUTPUT UTILITY METHODS
#
######################################################################

function __semver.missing.files.info {
 	if [ -f "${files[package]}" ] && [ ! -f "${files[semver]}" ] && [ ! -f "${files[version]}" ]; then
		console.info "run %s to create files" "bake semver";
	fi
}

function __semver.file.semver.info {
	console.info "%s < %s" "$1" "$2";
}

function __semver.file.write.quit {
	console.quit 1 "could not write %s" "$1";
}

function __semver.invalid.warn {
	console.warn "semver %s is not ok" "$1";
}

function __semver.invalid.quit {
	console.quit 1 "invalid semver %s" "$1";
}

function __semver.file.exists.info {
	console.info "%s %s" "$1" "✓";
}

function __semver.files.missing.quit {
	console.quit 1 "no semver files available";	
}

function __semver.file.missing.warn {
	console.warn "%s %s" "$1" "✘";
}