require.once 'http';

rest() {
  local commands_namespace="rest.commands";
  local cmd="${1:-}";
  shift;
  if ! method.exists? "${commands_namespace}.$cmd"; then
    console quit 1 -- "unknown command %s" "$cmd";
  fi
  local url="";
  declare -A flags;
  flags[print.headers]=false;
  flags[print.body]=false;
  flags[print.env]=false;
  rest.options.parse $@;
  delegate "${commands_namespace}" "$cmd" "$@";
}

## COMMANDS

rest.commands.get() {
	http get "$url";
	rest.print;
}

rest.commands.head() {
	http get "$url" "--head";
	rest.print;
}

rest.commands.post() {
	http post "$url";
	rest.print;	
}

rest.commands.put() {
	http put "$url";
	rest.print;	
}

rest.commands.delete() {
	http delete "$url";
	rest.print;	
}

rest.commands.options() {
	http options "$url";
	rest.print;
}

rest.commands.dl() {
	# show download progress to the screen
	http_print_stderr="on";
	http.curl.execute "--location" "-#" \
    "--write-out" "$http_curl_writeout" "--remote-name" "$url";
}

rest.commands.clean() {
	console info -- "cleaning files in %s" "$http_home";
	http.clean > /dev/null || quit 1 "error cleaning files in %s" "$http_home";
	console success "clean complete";
}

rest.commands.redo() {
	console info "using %s" "$http_config_file";
	if [ -f "$http_config_file" ]; then
		http.curl.execute "--config" "$http_config_file";
	else
		console quit 1 -- "no config file %s" "$http_config_file";
	fi
	rest.print;
}

rest.commands.load() {
	local id="${1:-}";
	local path="${http_config_dir}/${id}";
	if [ ! -f "$path" ]; then
		console quit 1 -- "no configuration file %s" "$path";
	fi
	console info "using %s" "$path";
	http.curl.execute "--config" "$path";
}

rest.commands.config() {
	if [ -f "$http_config_file" ]; then
		cat "$http_config_file";
	else
		console quit 1 -- "no config file %s" "$http_config_file";
	fi
}

## PRIVATE

rest.print() {
  ${flags[print.headers]} && rest.print.headers;
  ${flags[print.body]} && rest.print.body;
  ${flags[print.env]} && rest.print.env;
}

rest.print.headers() {
	if [ -f "$http_head_dump_file" ]; then
		cat "$http_head_dump_file";
	fi
}

rest.print.body() {
	if [ -f "$http_body_file" ]; then
		cat "$http_body_file";
	fi
}

rest.print.env() {
	local name value;
	for name in ${!http_*}
		do
			variable.get "$name";
			value=$( printf %q "$value" );
			echo "${name}=${value}";
	done
}

rest.options.parse() {
	local name;
	local value;
	while [ "${1:-}" != "" ]; do
		case $1 in
		-H | --header )
			shift;
			http request.add.header "$1";
			;;
		# shortcut for the content type header
		--type )
			shift;
			http request.add.header "content-type: $1";
			;;
		# query string parameter(s), repeatable
		--param )
			shift;
			name="${1:-}";
			shift;
			value="${1:-}";
			url.params.add "$name" "$value";
			;;
		--save )
			shift;
			name="${1:-}";
			echo "setting http_config_name to : $name";
			http_config_name="$name";
			;;
		-d | --data )
			shift;
			value="$1";
			http.option.add "--data" "$value";
			;;
		--json )
			shift;
			# value="$1";
			value=$( printf %q "$1" );
			# echo "got json data parameter... :: $value";
			http.request.add.header "content-type: application/json";
			http.option.add "--data-binary" "$value";
			;;
		--xml )
			shift;
			# value="$1";
			value=$( printf %q "$1" );
			# echo "got xml data parameter... :: $value";
			http.request.add.header "content-type: text/xml";
			http.option.add "--data-binary" "$value";
			;;
		--print-body )
      flags[print.body]=true;
			;;
		--print-headers )
      flags[print.headers]=true;
			;;
		--print-env )
      flags[print.env]=true;
			;;
		* )
			url+="${1:-}";
      ;;
			
		
		# TODO: allow unrecognised options to be passed to curl ..
		
		# --* )
		# 	name=${1:-};
		# 	shift;
		# 	value=${1:-};
		# 	# TODO: validate that the option is a recognised curl option...
		# 	echo "got unrecognised hyphen option... $name :: $value";
		# 	http.option.add "$name" "$value";
		# 	#http add_request_header "$1";
		# 	;;
    
		esac
		if [ $# -ne 0 ]; then
			shift;
		else
			break;
		fi
	done
}
