require 'url';
require 'string';
require 'executable';

# validate the curl executable is available
# after validation the executable path
# is available at: ${executables[curl]}
executable validate curl;

export http_curl_writeout="%{http_code}\n%{url_effective}\n%{time_total}\n%{num_redirects}\n";	# 
export http_output_file="$HOME/.http.out";
export http_head_file="$HOME/.http.head";
export http_body_file="$HOME/.http.body";
export http_base_url="";

# array of raw response headers
declare -agx http_response_headers;

function http_curl {
	local cmd="${executables[curl]}";
	if [ ! -x "$cmd" ]; then
		quit 1 "could not locate curl executable %s" "$cmd";
	fi
	
	#clean any previous rest output
	if [ -f "$http_output_file" ]; then
		rm "$http_output_file" > /dev/null;
	fi
	
	echo -n "" > "$http_head_file";
	echo -n "" > "$http_body_file";	
	
	#ensure we unset all variables before the next request
	
	#TODO: move to a method for unsetting by group
	for opt in ${!http_response_*}
		do
			unset "$opt";
	done
	
	#http_response_headers=();
	
	local method="${1:-GET}";
	shift;
	local path="${1:-}";
	shift;
	
	#remaining custom options
	local opts=( "$@" );
	
	local url="$path";
	if [ ! -z "$http_base_url" ]; then
		#strip any leading slash on path
		path=${path#/};
		url="${http_base_url}/${path}";
	fi
	
	#TODO: only perform this test if a protocol has been specified
	#otherwise we can let curl use it's default: http
	
	if [[ "$url" =~ ^[a-zA-Z]+: ]]; then
		if [[ ! "$url" =~ ^https?: ]]; then
			warn "invalid url protocol must be %s or %s" "http" "https";
			return 1;
		fi
	fi
	
	local runopts=(
		"-X${method}"
		"--silent"
		"-L"
		"-i"
		"--write-out"
		"${curl_writeout:-"$http_curl_writeout"}"
		"-o"
		"$http_output_file"
	);

	#pass in custom opts
	if [ ${#opts[@]} -gt 0 ]; then
		runopts=( "${runopts[@]}" "${opts[@]}" );
	fi
	
	runopts=( "${runopts[@]}" "$url" );
	
	echo "run: $cmd ${runopts[@]}";	
	
	http_request_method="${method}";
	
	local results=();
	local curl_exit_code;
	
	set +o errexit;	
	results=( $( $cmd "${runopts[@]}" || echo "$?" ) );
	
	curl_exit_code=${results[4]:-0};
	
	if [ ${#results[@]} -gt 2 ]; then
		http_response_status="${results[0]}";
		http_response_url="${results[1]}";
		http_response_time_total="${results[2]}";
		http_response_num_redirects="${results[3]:-0}";
		http_response_exit_code=${curl_exit_code:-${results[4]:-}};
	fi
	
	if [ "$http_response_exit_code" != "0" ]; then
		warn "curl exited with non-zero status code (%s)" "$http_response_exit_code";
	fi
	
	if [ -f "$http_output_file" ] && [ "$http_response_exit_code" == "0" ]; then
		
		#ensure that there is always a trailing newline
		#otherwise the body will not be parsed correctly
		#for servers that do not terminate the body with a newline
		#eg, json REST services
		echo "" >> "$http_output_file";
		
		__http_response_parse "${http_output_file}";
	else
		warn "no rest output file %s after request" "$http_output_file";
	fi
	
	set -o errexit;	
}

######################################################################
#
#	PRIVATE METHODS
#
######################################################################

function __http_response_parse_status {
	export http_response_header_raw="${@:1}";
	
	local index="$1";
	shift;
	
	echo "got response raw : $http_response_header_raw";
	echo "got response index : $index";
	
	local opts=();
	for opt in ${@}
		do
			# echo "got opt : $opt";
			opts=( "${opts[@]:-}" "$opt" );
	done
	
	#omit the first empty element in the array
	export http_response_header_http="${opts[1]:-}";
	export http_response_header_status="${opts[2]:-}";
	export http_response_header_message="${opts[3]:-}";
	
	# echo "opts length: ${#opts[@]}";
	# echo "[__http_response_parse_status] : ${http_response_header_raw}";	
	# echo "[http_response_header_http] : ${http_response_header_http}";
	# echo "[http_response_header_status] : ${http_response_header_status}";
	# echo "[http_response_header_message] : ${http_response_header_message}";
}

function __http_parse_header {
	#echo "__http_parse_header: $1 : $2";
	
	
	local name="${2%: ?*}";
	local value="${2#*:}";
	
	#convert hyphens to underscores
	name="${name//-/_}";
	
	#lowercase name
	name=${name,,};
	
	#strip leading whitespace
	string_ltrim "$value";
	value="$_result";
	
	#echo "got name: $name";
	#echo "got value: $value";
	
	#TODO: only export on the last header set received
	export "http_header_${name}=${value}";
}

function __http_response_parse {
	#echo "pasin http response..$@";
	
	# number of redirects corresponds to the number of headers to parse
	let redirects="${http_response_num_redirects:-0}";
	let index=0;
	
	echo "parsing response with number of redirects: $redirects";
	
	local output="$1";
	#cat "$output";
	local head=0;
	while read line
		do
			#echo "parsing http line $line";
			#parse the HTTP declaration
			if [[ "$line" =~ ^HTTP/1.[01]  ]]; then
				echo "parsing http response line...";
				__http_response_parse_status "$index" "${line}";
			#parsing header lines
			elif [ $head -eq 0 ]; then
				#strip the carriage return and line feeds
				line=`echo "$line" | tr -d "\r"`;
				line=`echo "$line" | tr -d "\n"`;
				if [ -z "$line" ] && [ $redirects -eq 0 ]; then
					echo "got end of head...";
					
					head=1;
				elif [ -z "$line" ] && [ $redirects -gt 0 ]; then
					echo "parsing next header...";
					let index++;					
					let redirects--;
				else
					#append to the header file
					echo "$line" >> "$http_head_file";
					__http_parse_header "$index" "$line";
				fi
			#parsing the body content
			elif [ $head -eq 1 ]; then
				#echo "parsing body line $line";
				#append to the body file
				echo "$line" >> "$http_body_file";
			fi
	done < "$output";
}