declare -g rlx_prompt_prefix="\033[1m[rlx]\033[0m";
declare -g rlx_prompt="${rlx_prompt_prefix} %s";
declare -g rlx_prompt_suffix=" âš¡ ";
declare -g rlx_home="$HOME/.rlx";

# information on the last command executed
declare -g rlx_command="";
declare -g rlx_command_options=();

function rlx.init {
	local db="db";
	local log="log";
	local dir subdirs=( "$db" "$log" );
	# create main storage directory
	mkdir -p "$rlx_home" \
		|| console.quit 1 "could not create %s" "$rlx_home";
	if [ -d "$rlx_home" ]; then
		console.info "created %s" "$rlx_home";
	fi
	# create required sub-directories
	for dir in "${subdirs[@]}"
		do
			dir="${rlx_home}/${dir}";
			mkdir -p "$dir" \
				|| console.quit 1 "could not create %s" "$dir";
			if [ -d "$dir" ]; then
				console.info "created %s" "$dir";
			fi
	done
	
	local auth="${rlx_home}/auth.json";
	# create an empty json document
	echo "{}" >| "${auth}";
	# echo "contents are: `cat $auth`";
	rlx.password.read;
	master="$password";
	crypto.enc.aes256cbc - "${auth}" "$password" <<< "{}";
	if [ ! -f "${auth}" ]; then
		console.quit 1 "could not generate encrypted authentication file";
	fi
	# switch the encrypted to the plain json extension
	chmod -R 700 "$auth" || console.quit 1 "could not change permissions on %s" "$auth";
	
	if [ -f "$auth" ]; then
		console.info "generated encrypted auth file %s" "$auth";
	fi
	
	# test decryption
	# crypto.dec.aes256cbc "${auth}" "-" "$master";
	
	return 0;
}

function rlx.firstrun? {
	test -d "$rlx_home";
}

function rlx.prompt {
	local replace="${1:-}";
	local ps1=$( printf "$rlx_prompt" "$replace" );
	#echo -n "${ps1}${rlx_prompt_suffix}";
	prompt="${ps1}${rlx_prompt_suffix}";
}

# read in password information
function rlx.password.read {
	local validate="${1:-true}";
	local minimum="${2:-8}";
	rlx.prompt "password";
	read -s -p "${prompt}" password;
	# create a newline
	echo "";
	if [ -z "$password" ]; then
		console.warn "enter a password";
		rlx.password.read;
	elif $validate; then
		if [ ${#password} -lt $minimum ]; then
			console.warn "minimum 8 characters";
			rlx.password.read;
		elif [[ "$password" =~ ^[a-zA-Z]+$ ]] || [[ "$password" =~ ^[0-9]+$ ]]; then
			console.warn "must contain letters %s numbers" "and";
			rlx.password.read;
		fi
	fi
}

# capture authentication information from stdin
function rlx.authenticate {
	rlx.prompt "username";
	read -p "${prompt}" username;
	if [ -z "$username" ]; then
		rlx.authenticate;
	fi
	rlx.password.read false;
}

# handle a server response
function rlx.response {
	if [ $http_response_status -eq 401 ]; then
		console.info "authorization required for %s" "$host";
		if [ -v PS1 ]; then
			console.quit 1 "not a tty, cannot prompt for authentication credentials";
		else
			rlx.authenticate;
			# TODO: update couchdb(3) auth settings
			echo "username: $username, password: $password";
			# run the last command again
			rlx.repeat;
		fi
	fi
}

# runs a command using the couchdb(3) module
# this is used so that when authentication is
# required we can re-run the last command after
# capturing the username/password pair
function rlx.run {
	local cmd="${1:-}";
	shift;
	rlx_command="${cmd}";
	rlx_command_options=( "$@" );
	"$cmd" "$@";
}

# attempt to run the last command again
# potentially after suppliying authentication
# information
function rlx.repeat {
	if [ -n "$rlx_command" ]; then
		rlx.run "${rlx_command}" "${rlx_command_options[@]}";
	fi
}