declare -g rlx_prompt_prefix="\033[1m[rlx]\033[0m";
declare -g rlx_prompt="${rlx_prompt_prefix} %s";
declare -g rlx_prompt_suffix=" ⚡ ";
declare -g rlx_home="$HOME/.rlx";

# information on the last command executed
declare -g rlx_command="";
declare -g rlx_command_options=();

function rlx.init {
	local db="db";
	local log="log";
	local dir subdirs=( "$db" "$log" );
	# create main storage directory
	mkdir -p "$rlx_home" \
		|| console.quit 1 "could not create %s" "$rlx_home";
	if [ -d "$rlx_home" ]; then
		console.info "created %s" "$rlx_home";
	fi
	# create required sub-directories
	for dir in "${subdirs[@]}"
		do
			dir="${rlx_home}/${dir}";
			mkdir -p "$dir" \
				|| console.quit 1 "could not create %s" "$dir";
			if [ -d "$dir" ]; then
				console.info "created %s" "$dir";
			fi
	done
	
	local auth="${rlx_home}/auth.json";
	rlx.password.read;
	master="$password";
	crypto.enc.aes256cbc - "${auth}" "$password" <<< "{}";
	if [ ! -f "${auth}" ]; then
		console.quit 1 "could not generate encrypted authentication file";
	fi
	# switch the encrypted to the plain json extension
	chmod -R 700 "$auth" || console.quit 1 "could not change permissions on %s" "$auth";
	
	if [ -f "$auth" ]; then
		console.info "generated encrypted auth file %s" "$auth";
	fi
	
	# test decryption
	# crypto.dec.aes256cbc "${auth}" "-" "$master";
	
	return 0;
}

function rlx.firstrun? {
	test -d "$rlx_home";
}

function rlx.prompt {
	local replace="${1:-}";
	local ps1=$( printf "$rlx_prompt" "$replace" );
	#echo -n "${ps1}${rlx_prompt_suffix}";
	prompt="${ps1}${rlx_prompt_suffix}";
}

# save authentication credentials
function rlx.auth.save {
	if [ -z "${master:-}" ]; then
		console.info "enter the master password: ";
		rlx.password.read false;
		master="$password";
	fi
	if [ -n "${username:-}" ] && [ -n "${password:-}" ] && [ -n "${host:-}" ]; then
		declare -A auth_doc;
		local auth="${rlx_home}/auth.json";
		local plain="${rlx_home}/auth.plain.json";
		local contents="";
		crypto.dec.aes256cbc "${auth}" "${plain}" "$master" 2>| "${rlx_home}/log/openssl.log";
		local code=$?;
		if [ $code -gt 0 ]; then
			console.error "openssl(%s) could not decrypt %s, bad password" "$code" "${auth}";
			master="";
			rlx.auth.save.clean;
			rlx.auth.save;
		else
			json.parse < "${plain}";
			
			# empty document, first entry
			if [ -z "${!json_doc[*]}" ]; then
				auth_doc[auth.0.user]="$couchdb_user";
				auth_doc[auth.0.pass]="$couchdb_pass";
				auth_doc[auth.0.host]="$host";
			# TODO: append entries to the document
			else
				echo "append to auth file with existing entries...";
			fi
			
			# convert to json and encrypt
			json.stringify <<< "auth_doc";
			json.string >| "${plain}";
			crypto.enc.aes256cbc "${plain}" "${auth}" "$master";
			code=$?;
			if [ $code -gt 0 ]; then
				console.error "openssl(%s) could not encrypt to %s" "${auth}";
			else
				console.info "saved %s @ %s" "$couchdb_user" "$host";
			fi
			rlx.auth.save.clean;
			
			# test decryption
			#crypto.dec.aes256cbc "${auth}" - "$master";
		fi
	fi
}

# clean up plain text version
# TODO: add an exit handler to remove this file if it exists!
function rlx.auth.save.clean {
	rm "${plain}" || console.error "could not delete %s" "${plain}";
}

# -o comp-option
# The comp-option controls several aspects of the compspec’s behavior beyond the simple generation of completions. comp-option may be one of:
# 
# bashdefault
# Perform the rest of the default Bash completions if the compspec generates no matches.
# 
# default
# Use Readline’s default filename completion if the compspec generates no matches.
# 
# dirnames
# Perform directory name completion if the compspec generates no matches.
# 
# filenames
# Tell Readline that the compspec generates filenames, so it can perform any filename-specific processing (like adding a slash to directory names quoting special characters, or suppressing trailing spaces). This option is intended to be used with shell functions specified with -F.
# 
# nospace
# Tell Readline not to append a space (the default) to words completed at the end of the line.
# 
# plusdirs
# After any matches defined by the compspec are generated, directory name completion is attempted and any matches are added to the results of the other actions.

# function rlx.prompt.complete {
# 	# COMPREPLY=()
# 	# local cur="${COMP_WORDS[COMP_CWORD]}"
# 	# local opts="Whatever sort of tabbing options you want to have!"
# 	# COMPREPLY=($(compgen -W "${opts}" -- ${cur}));
# 	echo "$FUNCNAME : $cmd";	
# 	compgen -W "db directory" -- "d";
# 	#complete -o dirnames "/";
# 
# }

#declare -gx rlx_cmdline;

function sd
{
# 'local' can only be used within a function, exclude it if not using a function
  COMPREPLY=()
  local cur="${COMP_WORDS[COMP_CWORD]}"
	echo "cur: $cur"
  local opts="Whatever sort of tabbing options you want to have!"
  COMPREPLY=($(compgen -W "${opts}" -- ${cur}))
}

function rlx.prompt.cmd {
	rlx.prompt "@ ${host}";
	
	export HISTFILE="$rlx_history";
	
	# set up tab completion for shell commands
	# set -o emacs;
	# bind 'set show-all-if-ambiguous on';
	# bind 'set completion-ignore-case on';
	
	#COMP_WORDBREAKS=${COMP_WORDBREAKS//:}
	#bind 'TAB: menu-complete';
	# bind 'TAB:dynamic-complete-history';
	#bind 'TAB:dynamic-complete-history';
	#bind -u 'dynamic-complete-history';
	#bind 'TAB: complete-filename';
	#bind 'TAB: dynamic-complete-history';
	
	#bind -x '"\t":"rlx.prompt.complete"';
	
	#complete -F "rlx.prompt.complete" "db";
	#complete -p;
	
	# complete -r;
	# complete -E -F "sd" "db";
	
	#complete -D -F rlx.prompt.complete;
	
	# _completion_loader()
	# {
	# 	echo "$FUNCNAME";
	# }
	#complete -D -F _completion_loader;
	
	# shopt -s histappend;
	# PROMPT_COMMAND="history -a"
	
	while
		HISTSIZE=500;
		HISTFILESIZE=500;
		HISTCONTROL=erasedups:ignoredups;
		HISTFILE="$rlx_history";
		history -r "$rlx_history";
		read -ep "${prompt}" cmd;
		do
			#kill $complete_pid 2> /dev/null;
			if [ -z "$cmd" ]; then
				rlx.prompt.cmd;
				return 0;
			fi
			local cmdline=( $cmd );
			cmd="${cmdline[0]}";
			# complete -F "rlx.prompt.complete" -o "default" "${cmd}";
						
			history -s "$cmd";
			history -w "$rlx_history";	
			
			if ! method.exists? "rlx.shell.$cmd"; then
				console.info "unknown command %s, type %s" "$cmd" "help";
				rlx.prompt.cmd;
				return 0;
			fi
			
			"rlx.shell.$cmd" "${cmdline[@]:1}";
			rlx.prompt.cmd;
			return 0;
	done
	#PS1="${prompt}";
	
	# echo "showing command prompt ... ";
	# 
	# (
	# 	export HISTFILE="$rlx_history";
	# 	export PS1="${prompt} (bash)";
	# 	# function command_not_found_handle {
	# 	# 	echo "$FUNCNAME: $*";
	# 	# }
	# 	# function command_not_found_handle {
	# 	# 	echo "$FUNCNAME: $*";
	# 	# }
	# 	# echo -ne "$prompt";
	# 	(
	# 		bash --noprofile --dump-strings -i && tail -n 1 "$rlx_history";
	# 	)
	# 	local cmd=$( tail -n 1 "$rlx_history" );
	# 	echo "got command : $cmd";
	# );
	
	# if [ -z "$cmd" ]; then
	# 	rlx.prompt.cmd;
	# 	return 0;
	# fi
	# local cmdline=( $cmd );
	# cmd="${cmdline[0]}";
	# if ! method.exists? "rlx.shell.$cmd"; then
	# 	console.info "unknown command %s, type %s" "$cmd" "help";
	# 	rlx.prompt.cmd;
	# 	return 0;
	# fi
	# # echo "execute command: $cmd";
	# # echo "execute command options: ${cmdline[@]:1}";
	# 
	# #echo "exec: history -s "${cmdline[@]}" "$rlx_history"";	
	# 
	# #history -s "${cmdline[@]}" "$rlx_history";
	# 
	# # execute the shell command method
	# "rlx.shell.$cmd" "${cmdline[@]:1}";
	# rlx.prompt.cmd;
}

# read in password information
function rlx.password.read {
	local validate="${1:-true}";
	local minimum="${2:-8}";
	rlx.prompt "password";
	read -s -p "${prompt}" password;
	# create a newline
	echo "";
	if [ -z "$password" ]; then
		console.warn "enter a password";
		rlx.password.read;
	elif $validate; then
		if [ ${#password} -lt $minimum ]; then
			console.warn "minimum 8 characters";
			rlx.password.read;
		elif [[ "$password" =~ ^[a-zA-Z]+$ ]] || [[ "$password" =~ ^[0-9]+$ ]]; then
			console.warn "must contain letters %s numbers" "and";
			rlx.password.read;
		fi
	fi
}

# capture authentication information from stdin
function rlx.authenticate {
	rlx.prompt "username";
	read -p "${prompt}" username;
	if [ -z "$username" ]; then
		rlx.authenticate;
		return 0;
	fi
	rlx.password.read false;
}

# handle a server response
function rlx.response {
	
	if [ $http_response_status -eq 401 ]; then
		console.info "authorization required for %s" "$host";
		if [ -v PS1 ]; then
			console.quit 1 "not a tty, cannot prompt for authentication credentials";
		else
			authenticating=true;
			rlx.authenticate;
			# TODO: update couchdb(3) auth settings
			# echo "username: $username, password: $password";
			couchdb_user="$username";
			couchdb_pass="$password";
			# run the last command again
			rlx.repeat;
		fi
	else
		# echo "got rlx response code: $http_response_status";
		# cat "$response_json";
		
		# successful authentication
		if $authenticating; then
			authenticating=false;
			rlx.auth.save;
		fi

		json.parse < "$response_json";
		
		# update the list of databases
		if [ "$rlx_command" == "couchdb.db.list" ]; then
			databases=( "${json_doc[@]}" );
			# echo "set databases to ${databases[@]}";
		fi
		
		rlx.prompt.cmd;
	fi
}

# runs a command using the couchdb(3) module
# this is used so that when authentication is
# required we can re-run the last command after
# capturing the username/password pair
function rlx.run {
	local cmd="${1:-}";
	shift;
	rlx_command="${cmd}";
	rlx_command_options=( "$@" );
	"$cmd" "$@";
	rlx.response;
}

# attempt to run the last command again
# potentially after suppliying authentication
# information
function rlx.repeat {
	if [ -n "$rlx_command" ]; then
		rlx.run "${rlx_command}" "${rlx_command_options[@]}";
	fi
}