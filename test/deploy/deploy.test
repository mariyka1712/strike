# test running with the --json option, implies --noop

# runs all local deployment tests
test.deploy.local() {
	local self;
	require.resolve "self";
	local dir="${self[1]}";
	
	# stash bake(1) variables
	declare -A info;
	info[root]="${root}";
	info[project]="${project}";	
	info[target]="${target}";
	info[project_name]="${project_name}";
	info[project_version]="${project_version}";
	
	# set up a mock directory structure
	local deploy_test="${target}/deploy-test";
	local staging="${deploy_test}/staging";
	local directory="${deploy_test}/www";
	local bundles="${deploy_test}/bundles";
	local descriptors="${dir}/descriptors";
	local descriptor="";
	
	# override name / semver
	# for these tests to match the
	# values for the mock project
	# bake(1) will have set them
	# to strike@0.0.1 etc.
	project_name="project";
	project_version="0.0.1";	
	local project="${dir}/${project_name}";
	
	declare -A expects;
	expects[name]="$project_name";
	expects[version]="$project_version";
	expects[project]="$project_name-$project_version";
	
	# setup the mock target staging directory
	local target="${project}/target";
	mkdir -p "${project}/target";
	
	# options common to all tests
	local options=(
		--ok	
		--local
		--no-growl		
		--staging "${staging}"
		--directory "${directory}"
		--output "${bundles}"
	);
	
	# run tests that should pass
	:test.deploy.run ':test.deploy.env.minimal';
	
	# :test.deploy.run ':test.deploy.minimal.bundle';
	# :test.deploy.run ':test.deploy.minimal.deploy';
		
	# :test.deploy.run ':test.deploy.project.bundle';
	# :test.deploy.run ':test.deploy.project.deploy';
}

# run a test, we want to ensure
# that we have a fresh mock structure
# for each test
:test.deploy.run() {
	local cmd="$1";
	
	# clean up before we start
	:test.deploy.clean;	
	
	# create fresh mock directories
	:test.deploy.init;
	# run the test
	$cmd;
	# clean up at the end
	:test.deploy.clean;
}

# test environment is sane
:test.deploy.env.minimal() {
	descriptor="${project}/env.json";
	local opts=( ${options[@]} );
	opts+=( --global-env --print-env --descriptor "${descriptor}" );
	
	# we need export variables to be available for assertions
	# but do not want the the test runner to quit
	set +o errexit;
	tasks.deploy "${opts[@]}";
	set -o errexit;

	assert.equal "" "${env_non_existent:-}";
	assert.equal "" "${env_unset}";
	assert.equal "${HOME:-}" "${env_home}";
	assert.equal "${USER:-}" "${env_user}";
	assert.equal "${PATH:-}" "${env_path}";
	assert.equal "${SHELL:-}" "${env_shell}";
	assert.equal "bar" "${env_foo}";
	assert.equal "bar" "${env_bad_name_format}";
	assert.equal '`bar`' "${env_backtick}";
	assert.equal "rmdir target" "${env_rmdir}";
	assert.equal '`rmdir target`' "${env_rmdir_backtick}";
	assert.equal 'a && b' "${env_and}";
	assert.equal 'c || d' "${env_or}";
	
	assert.equal "${expects[name]}" "${env_project_name}";
	assert.equal "${expects[version]}" "${env_project_version}";
	assert.equal "${target}" "${env_archive_dir}";
	assert.equal "${expects[name]}-${expects[version]}.tgz"	"${env_archive_name}";
	assert.equal "${target}/${expects[name]}-${expects[version]}.tgz" "${env_archive_path}"
}

# MINIMAL

# test bundling the default profile
# using the absolute minimal descriptor
:test.deploy.minimal.bundle() {
	descriptor="${project}/minimal.json";
	local opts=( ${options[@]} );
	opts+=( --bundle --descriptor "${descriptor}" );
	( tasks.deploy "${opts[@]}" );
	assert.file.exists? "${bundles}/${expects[project]}-default.tgz";
}

# test deploying the default profile
# using the absolute minimal descriptor
:test.deploy.minimal.deploy() {
	descriptor="${project}/minimal.json";
	local opts=( ${options[@]} );
	opts+=( --descriptor "${descriptor}" );
	( tasks.deploy "${opts[@]}" );
	assert.dir.exists? "${directory}/${expects[name]}/default";
}

# PROJECT

# test bundling the default profile
# for the mock project
:test.deploy.project.bundle() {
	descriptor="${project}/deploy.json";
	local opts=( ${options[@]} );
	opts+=( --bundle --descriptor "${descriptor}" );
	( tasks.deploy "${opts[@]}" );
	assert.file.exists? "${bundles}/${expects[project]}-default.tgz";
}

# test deploying the default profile
# for the mock project
:test.deploy.project.deploy() {
	descriptor="${project}/deploy.json";
	local opts=( ${options[@]} );
	opts+=( --descriptor "${descriptor}" );
	( tasks.deploy "${opts[@]}" );
	assert.dir.exists? "${directory}/${expects[name]}/default";
	assert.file.exists? "${directory}/${expects[name]}/default/README.md";
	assert.file.exists? "${directory}/${expects[name]}/default/LICENSE";
}

# :test.deploy.json.dump() {
# 	
# 	# get the configuration setting as a json document
# 	local json=$( tasks.deploy --local --json --staging "${staging}" );
# 	
# 	printf "${json}\n";
# 
# 	# parse the output
# 	json.parse <<< "${json}";
# 	
# 	# should not have the staging directory
# 	assert.dir.exists! "${staging}";
# 	
# 	# check json dump properties
# 	assert.equal "${staging}" "${json_doc[profiles.default.staging]}";
# 	# noop should be true
# 	assert.equal "true" "${json_doc[noop]}";
# }

# UTIL

# create the test staging structure
:test.deploy.init() {
	mkdir -p "$staging";
	mkdir -p "$directory";
	mkdir -p "$bundles";
}

# clean the test staging directory
:test.deploy.clean() {
	if [ -d "${deploy_test}" ]; then
		console.info "deploy.test clean %s" "$deploy_test";
		# NOTE: we use ${root}/target rather than ${target}
		# NOTE: as ${target} points to the mock project staging directory
		rm -rfv "$deploy_test" >> "${root}/target/deploy.test.clean.log";
	fi
}