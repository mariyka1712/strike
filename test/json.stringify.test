require.once json;

declare -ag json_valid_numbers;
json_valid_numbers=( "-127" "127" "3.14" "-3.14" "2e10" "2e-10" "2e+10" "3.14e10" "3.14e-10" "3.14e+10" );	

declare -ag json_invalid_numbers;
json_invalid_numbers=( "3." "-3." "-3.e" "3a" "b3" ".14" ".14e+10" ".14-10" );

declare -ag json_valid_strings;
json_valid_strings=( "value" 'a "quoted" value' );

# test(s) for encoding set and unset variables
function test.json.stringify.basic {
	local result;
	
	# test that an unset variable is detected
	json.stringify <<< "missing_doc";
	assert.eq "1" "$?";
	
	# test that a set variable is detected
	local doc="mydocument";
	json.stringify <<< "doc";
	assert.eq "0" "$?";
	
	# test that a variable set to the empty string converts to ""
	doc="";
	json.stringify <<< "doc";
	assert.eq "0" "$?";
	result=$( json.string );
	assert.equal '""' "$result";
	
	# test that a set array is detected
	declare -a myarray;
	myarray=( 1 2 3 );
	json.stringify <<< "myarray";
	assert.eq "0" "$?";	
	result=$( json.string );
	assert.equal "[1,2,3]" "$result";
	
	# test that a declared but unset array converts to []
	declare -a mynewarray;
	json.stringify <<< "mynewarray";
	assert.eq "0" "$?";
	result=$( json.string );
	assert.equal "[]" "$result";
	
	# test that a set local array is valid
	local localarr=( 1 2 3 );
	json.stringify <<< "localarr";
	assert.eq "0" "$?";
	result=$( json.string );
	assert.equal "[1,2,3]" "$result";	
	
	# test that a set local but empty local array converts to []
	local emptyarr=();
	json.stringify <<< "emptyarr";
	assert.eq "0" "$?";
	result=$( json.string );
	assert.equal "[]" "$result";	
	
	# test that a declared but unset associative array converts to {}
	declare -A myassoc;
	json.stringify <<< "myassoc";
	assert.eq "0" "$?";
	result=$( json.string );
	assert.equal "{}" "$result";
	
	# test that a declared and set associative array is valid
	declare -A mynewassoc;
	mynewassoc[key]="value";
	json.stringify <<< "mynewassoc";
	assert.eq "0" "$?";
	result=$( json.string );
	assert.equal '{"key":"value"}' "$result";
	
	# TODO: null / numbers
}

# test(s) for encoding boolean values
function test.json.stringify.boolean {
	local result doc="true";
	json.stringify <<< "doc";
	result=$( json.string );	
	assert.equal "true" "$result";
	
	doc="false";
	json.stringify <<< "doc";
	result=$( json.string );	
	assert.equal "false" "$result";
	
	doc=true;
	json.stringify <<< "doc";
	result=$( json.string );	
	assert.equal "true" "$result";
	
	doc=false;
	json.stringify <<< "doc";
	result=$( json.string );	
	assert.equal "false" "$result";	
}

# test(s) for encoding null values
function test.json.stringify.null {
	local result doc="null";
	json.stringify <<< "doc";
	result=$( json.string );
	assert.equal "null" "$result";
	
	doc=null;
	json.stringify <<< "doc";
	result=$( json.string );	
	assert.equal "null" "$result";
}

# test(s) for encoding an integers
function test.json.stringify.integer {
	local result doc="127";
	json.stringify <<< "doc";
	result=$( json.string );
	assert.equal "127" "$result";
	
	doc=127;
	json.stringify <<< "doc";
	result=$( json.string );
	assert.equal "127" "$result";
	
	doc="-127";
	json.stringify <<< "doc";
	result=$( json.string );
	assert.equal "-127" "$result";
	
	doc=-127;
	json.stringify <<< "doc";
	result=$( json.string );
	assert.equal "-127" "$result";		
}

# test(s) for encoding numbers
function test.json.stringify.number {
	local result num;
	for num in ${json_valid_numbers[@]}
		do
			json.stringify <<< "num";
			result=$( json.string );
			# numbers should not be quoted
			assert.equal "$num" "$result";
	done
}

#test(s) for the number regexp matching
function test.json.stringify.number.match {
	# ref to the regexp
	local match="$json_number_regexp";
	local num;
	local valid=( ${json_valid_numbers[@]} );
	local invalid=( ${json_invalid_numbers[@]} );
		
	# add uppercase versions for valid tests
	for num in ${valid[@]}
		do
			if [[ "$num" =~ [a-z]+ ]]; then
				string.upper "$num";
				valid+=( "$_result" );
			fi
	done
	
	# valid
	# console.info "$FUNCNAME (valid) ${valid[*]}";	
	for num in ${valid[@]}
		do
			# console.info "$FUNCNAME (valid) %s =~ %s" "$num" "$match";
			assert.match "$match" "$num";
	done
	
	# invalid
	# console.info "$FUNCNAME (invalid) ${invalid[*]}";	
	for num in ${invalid[@]}
		do
			# console.info "$FUNCNAME (invalid) %s =~ %s" "$num" "$match";
			assert.match! "$match" "$num";
	done
}

# test(s) for encoding strings
function test.json.stringify.string {
	local result expected str;
	for str in "${json_valid_strings[@]}"
		do
			# echo "testing str: $str";
			
			expected="$str";
			json.stringify <<< "str";
			result=$( json.string );
			# expect string values with quotes
			# to be escaped
			if [[ "$expected" =~ \" ]]; then
				expected="${expected//\"/\\\"}";
			fi
			
			# we always expect overall quotes surrounding the value
			expected="\"$expected\"";
			
			echo "source: $str , result: $result , expected: $expected";
			
			# strings should be quoted
			assert.equal "$expected" "$result";
	done
}