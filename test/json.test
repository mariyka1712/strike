require 'json';

# TODO: ensure all valid parse tests are correct
# TODO: add invalid parse tests
function test.json.parse {
	local valid="${testdir}/json/valid";
	local file parsed name dir;
	for file in ${valid}/*.json
		do
			dir=`dirname "$file"`;
			name=`basename "$file"`;
			name=${name%%.json};
			parsed="${dir}/${name}.parsed";
			json.parse < "$file";
			
			# look for a parsed file to assert on
			if [ -f "$parsed" ]; then
				#echo "got parsed `cat $parsed`";
				assert.equal "`cat "$parsed"`" "`json.print`";
			else
				echo "json.parse, missing parsed : $parsed";
			fi
			
			json.print;
	done
}

# test for encoding an empty array
function test.json.stringify.empty {
	local doc;
	json.stringify <<< "doc";
	local received="$json_str";
	assert.equal "{}" "$received";
}

# test for encoding a string value
function test.json.stringify.string {
	local doc="this is a string value";
	json.stringify <<< "doc";
	local received="$json_str";
	assert.equal "\"this is a string value\"" "$received";
}

# test for encoding a boolean true
function test.json.stringify.boolean.true {
	local doc="true";
	json.stringify <<< "doc";
	local received="$json_str";
	assert.equal "true" "$received";
}

# test for encoding a boolean false
function test.json.stringify.boolean.false {
	local doc="false";
	json.stringify <<< "doc";
	local received="$json_str";
	assert.equal "false" "$received";
}

# test for encoding a null
function test.json.stringify.null {
	local doc="null";
	json.stringify <<< "doc";
	local received="$json_str";
	assert.equal "null" "$received";
}

# test for encoding an integer
function test.json.stringify.integer {
	local doc="127";
	json.stringify <<< "doc";
	local received="$json_str";
	assert.equal "127" "$received";
}

# test for encoding an object with a single key
function test.json.stringify.object {
	declare -A doc;
	doc[key]="a key value";
	json.stringify <<< "doc";
	local received="$json_str";
	assert.equal '{"key":"a key value"}' "$received";
}

# test for encoding an object with multiple keys
function test.json.stringify.object.keys {
	declare -A doc;
	doc[key1]="the first value";
	doc[key2]="the second value";
	json.stringify <<< "doc";
	#json.string;
	local received="$json_str";
	# key iterartion order appears to always be in reverse order
	# this test will fail if that behaviour changes
	assert.equal '{"key2":"the second value","key1":"the first value"}' "$received";
}

# test for encoding an array
function test.json.stringify.array {
	declare -a doc;
	doc=( 127 null true false "a string value" );
	json.stringify <<< "doc";
	local received="$json_str";
	assert.equal '[127,null,true,false,"a string value"]' "$received";
}

# test for pretty printing an array using two spaces
function test.json.stringify.array.pretty.space {
	declare -a doc;
	doc=( 127 null true false "a string value" );
	
	# pretty print with 2 spaces for the indent	
	json.stringify --pretty 2 <<< "doc";

	local file="${testdir}/json/pretty/array.json";
	local expected=$( < "$file" );
	assert.equal "$expected" "$json_str";
}

# test for pretty printing an array using a single tab
function test.json.stringify.array.pretty.tab {
	declare -a doc;
	doc=( 127 null true false "a string value" );
	
	# pretty print with 2 spaces for the indent	
	json.stringify --pretty 1 '	' <<< "doc";			#third parameter is actually: \t

	local file="${testdir}/json/pretty/array.tab.json";
	local expected=$( < "$file" );
	assert.equal "$expected" "$json_str";
}

# test for encoding an object and pretty printing using two spaces
function test.json.stringify.object.pretty.space {
	declare -A doc;
	doc[key1]="the first value";
	doc[key2]="the second value";
	
	# pretty print with 2 spaces for the indent
	json.stringify --pretty 2 <<< "doc";
	
	local file="${testdir}/json/pretty/object.json";
	local expected=$( < "$file" );
	assert.equal "$expected" "$json_str";
}

# test for encoding an object and pretty printing using a single tab
function test.json.stringify.object.pretty.tab {
	declare -A doc;
	doc[key1]="the first value";
	doc[key2]="the second value";
	
	# pretty print with a single tab for the indent
	json.stringify --pretty 1 '	' <<< "doc";			#third parameter is actually: \t
	
	local file="${testdir}/json/pretty/object.tab.json";
	local expected=$( < "$file" );
	assert.equal "$expected" "$json_str";
}

# test for serializing nested, complex objects
function test.json.stringify.complex {
	declare -A doc;
	doc[type]="info";
	
	# TODO: ensure escape characters are correct
	# doc[escaped]='\" \\ \/ \b \f \n \r \t \u four-hex-digits';
	
	# TODO: escape \u sequences so they are not interpreted by printf ?
	# doc[escaped]="\u0040 ";
	
	doc[data.name]="muji";
	doc[data.email]="<noop@xpm.io>";
	doc[data.names.0]="muji";
	doc[data.names.1]="null";
	doc[data.names.2]="true";
	doc[data.names.3]="false";
	doc[data.names.4]="3.14e+10";
	json.stringify <<< "doc";
	
	json.string;
	
	# round trip test with assertions
	json.parse <<< `json.string`;
	local key expected;
	for key in "${!doc[@]}"
		do
			expected="${doc["$key"]}";
			echo "expected: '$expected', received: '${json_doc["$key"]}'";
			assert.equal "$expected" "${json_doc["$key"]}";
	done
}

# test for the json number regexp matching
function test.json.number {
	# ref to the regexp
	local match="$json_number_regexp";
	local num;	
	
	local valid=(
		"-127"
		"127"
		"3.14"
		"-3.14"
		"2e10"
		"2e-10"
		"2e+10"
		"3.14e10"
		"3.14e-10"
		"3.14e+10"
	);
	
	# add uppercase versions for valid tests
	for num in ${valid[@]}
		do
			if [[ "$num" =~ [a-z]+ ]]; then
				string.upper "$num";
				valid+=( "$_result" );
			fi
	done
	
	local invalid=(
		"3."
		"-3."
		"-3.e"
		"3a"
		"b3"
		".14"
		".14e+10"
		".14-10"
	);
	
	regexp()
	{
		if [[ "$1" =~ $match ]]; then
			return 0;
		fi
		return 1;
	}
	
	# valid
	console.info "$FUNCNAME (valid) ${valid[*]}";	
	for num in ${valid[@]}
		do
			console.info "$FUNCNAME (valid) %s =~ %s" "$num" "$match";
			`regexp "$num"`;
			assert.eq "0" "$?";
	done
	
	# invalid
	console.info "$FUNCNAME (invalid) ${invalid[*]}";	
	for num in ${invalid[@]}
		do
			console.info "$FUNCNAME (invalid) %s =~ %s" "$num" "$match";
			`regexp "$num"`;
			assert.eq "1" "$?";
	done
	
	# clean inner method definitions
	method.remove "regexp";
}