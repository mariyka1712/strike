require 'json';

# TODO: ensure all valid parse tests are correct
# TODO: add invalid parse tests
function test.json.parse {
	local valid="${testdir}/json/valid";
	local file parsed name dir;
	for file in ${valid}/*.json
		do
			dir=`dirname "$file"`;
			name=`basename "$file"`;
			name=${name%%.json};
			parsed="${dir}/${name}.parsed";
			json.parse < "$file";
			
			# look for a parsed file to assert on
			if [ -f "$parsed" ]; then
				#echo "got parsed `cat $parsed`";
				assert.equal "`cat "$parsed"`" "`json.print`";
			else
				echo "json.parse, missing parsed : $parsed";
			fi
			
			json.print;
	done
}

# test for encoding an empty array
function test.json.stringify.empty {
	local doc;
	json.stringify <<< "doc";
	local received="$json_str";
	assert.equal "{}" "$received";
}

# test for encoding a string value
function test.json.stringify.string {
	local doc="this is a string value";
	json.stringify <<< "doc";
	local received="$json_str";
	assert.equal "\"this is a string value\"" "$received";
}

# test for encoding a boolean true
function test.json.stringify.boolean.true {
	local doc="true";
	json.stringify <<< "doc";
	local received="$json_str";
	assert.equal "true" "$received";
}

# test for encoding a boolean false
function test.json.stringify.boolean.false {
	local doc="false";
	json.stringify <<< "doc";
	local received="$json_str";
	assert.equal "false" "$received";
}

# test for encoding a null
function test.json.stringify.null {
	local doc="null";
	json.stringify <<< "doc";
	local received="$json_str";
	assert.equal "null" "$received";
}

# test for encoding an integer
function test.json.stringify.integer {
	local doc="127";
	json.stringify <<< "doc";
	local received="$json_str";
	assert.equal "127" "$received";
}

# test for encoding an object with a single key
function test.json.stringify.object {
	declare -A doc;
	doc[key]="a key value";
	json.stringify <<< "doc";
	local received="$json_str";
	assert.equal '{"key":"a key value"}' "$received";
}

# test for encoding an object with multiple keys
function test.json.stringify.object.keys {
	declare -A doc;
	doc[key1]="the first value";
	doc[key2]="the second value";
	json.stringify <<< "doc";
	#json.string;
	local received="$json_str";
	# key iterartion order appears to always be in reverse order
	# this test will fail if that behaviour changes
	assert.equal '{"key2":"the second value","key1":"the first value"}' "$received";
}

# test for encoding an array
function test.json.stringify.array {
	declare -a doc;
	doc=( 127 null true false "a string value" );
	json.stringify <<< "doc";
	local received="$json_str";
	assert.equal '[127,null,true,false,"a string value"]' "$received";
}

# test for pretty printing an array using two spaces
function test.json.stringify.array.pretty.space {
	declare -a doc;
	doc=( 127 null true false "a string value" );
	
	# pretty print with 2 spaces for the indent	
	json.stringify --pretty 2 <<< "doc";

	local file="${testdir}/json/pretty/array.json";
	local expected=$( < "$file" );
	assert.equal "$expected" "$json_str";
}

# test for pretty printing an array using a single tab
function test.json.stringify.array.pretty.tab {
	declare -a doc;
	doc=( 127 null true false "a string value" );
	
	# pretty print with 2 spaces for the indent	
	json.stringify --pretty 1 '	' <<< "doc";			#third parameter is actually: \t

	local file="${testdir}/json/pretty/array.tab.json";
	local expected=$( < "$file" );
	assert.equal "$expected" "$json_str";
}

# test for encoding an object and pretty printing using two spaces
function test.json.stringify.object.pretty.space {
	declare -A doc;
	doc[key1]="the first value";
	doc[key2]="the second value";
	
	# pretty print with 2 spaces for the indent
	json.stringify --pretty 2 <<< "doc";
	
	local file="${testdir}/json/pretty/object.json";
	local expected=$( < "$file" );
	assert.equal "$expected" "$json_str";
}

# test for encoding an object and pretty printing using a single tab
function test.json.stringify.object.pretty.tab {
	declare -A doc;
	doc[key1]="the first value";
	doc[key2]="the second value";
	
	# pretty print with a single tab for the indent
	json.stringify --pretty 1 '	' <<< "doc";			#third parameter is actually: \t
	
	local file="${testdir}/json/pretty/object.tab.json";
	local expected=$( < "$file" );
	assert.equal "$expected" "$json_str";
}