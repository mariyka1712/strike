#!/usr/bin/env bash

set -o errtrace;
set -o errexit;
set -o nounset;

######################################################################
#
#	BOILERPLATE
#
######################################################################
console_print_program_prefix="off";
declare -gx exedir;
function boilerplate {
	local abspath=$(cd ${BASH_SOURCE[0]%/*} && echo $PWD/${0##*/});
	if [ -L "$abspath" ]; then
		abspath=`readlink $abspath`;
	fi
	if [[ "$abspath" =~ ^\./ ]]; then
		abspath="${PWD}/${abspath}";
	fi
	exedir=`dirname "$abspath"`;
	local libdir="$exedir/../../lib";
	source "$libdir/shared" "$@";
}
boilerplate "$@";
######################################################################

# the exit code to use
code="${1:-0}";

function signals {
	# switch on debug/strict/test mode(s)
	process.use debug strict test;
	
	local __signals="${process_signals[@]}";
	local signal;
	for signal in ${__signals[@]}
		do
			# listen for everything, execept err and debug as they are too noisy
			if [ "$signal" != "err" ] && [ "$signal" != "debug" ]; then
				# echo "adding signal $signal";
				process.on "$signal";
			fi
	done
	
	loop()
	{
		process.uptime;
		echo "$FUNCNAME : process.uptime: $_result";
		exit 0;
	}
	
	# start the process as a daemon
	process.daemon.start! "loop";
}

signals "$@";

# quit 1 "%s" "$process_name"