require.once 'tasks/compress';

# test(s) for task-compress(7) create/extract
function test.compress.cx {
	# compress files relative to this test
	local self result;
	require.resolve "self";
	local dir="${self[1]}";
	
	# map between file name and file contents
	# so we can also assert on file contents
	# after decompression
	declare -A entries;
	
	# create the test files from the archive lipsum/etiam test
	# files, repeating the contents n times
	!test.compress.files.create 15;
	
	# TODO: compress files to -o | --output
	# TODO: extract files to -o | --output
	
	local program="tasks.compress";
	local cmd="-c --verbose --debug";
	
	local files=(
		"${dir}/lipsum.txt"
		"${dir}/etiam.txt"
	);
	
	# execute the command
	$program $cmd "${files[@]}";
	
	# check the test and compressed files exist
	local f ext="gz";
	for f in "${files[@]}"
		do
			assert.file.exists? "$f";
			assert.file.exists? "${f}.${ext}";
	done
	
	# test the --noop option not that 
	# we add a couple of .gz files that should not
	# be located using the -c | create command
	cmd="-c --noop";
	result=( $( "$program" $cmd "${files[@]}" "lipsum.txt.gz" "etiam.txt.gz" ) );
	assert.equal "${files[*]}" "${result[*]}";
	
	# test the -x | extract command
	cmd="-x --verbose --debug";
	local compressed=(
		"${files[0]}.${ext}"
		"${files[1]}.${ext}"
	);
	
	# remove source files before decompression
	rm "${files[@]}";
	
	# verify that the source files have gone
	for f in "${files[@]}"
		do
			assert.file.exists! "$f";
	done
	
	# extract compressed versions
	$program $cmd "${compressed[@]}";
	# assert that all files exist again after deflation
	for f in "${files[@]}"
		do
			assert.file.exists? "$f";
			assert.file.exists? "${f}.${ext}";
			# assert on extracted file contents
			assert.equal "${entries["$f"]}" "`cat "$f"`";
	done
	
	# test the --noop option with the -x | extract command
	# we add a couple of source files that should not
	# be located using the -x | extract command
	cmd="-x --noop";
	result=( $( "$program" $cmd "${compressed[@]}" "${files[@]}" ) );
	assert.equal "${compressed[*]}" "${result[*]}";
	
	# clean up after test run
	!test.compress.files.clean;
	
	# recreate test files
	!test.compress.files.create 15;
	
	# now run with the delete option so that
	# we don't keep the source files
	cmd="-c --delete --verbose --debug";
	$program $cmd "${files[@]}";
	
	# should only have the compressed versions now
	for f in "${compressed[@]}"
		do
			assert.file.exists? "$f";			
	done
	# not the original source files
	for f in "${files[@]}";
		do
			assert.file.exists! "$f";
	done
	
	# inverted --delete test on extraction
	cmd="-x --delete --verbose --debug";
	$program $cmd "${compressed[@]}";
	# should only have the source versions now
	for f in "${files[@]}"
		do
			assert.file.exists? "$f";			
	done
	# not the compressed files
	for f in "${compressed[@]}";
		do
			assert.file.exists! "$f";
	done
	
	# clean up again
	!test.compress.files.clean;		
}

# test pattern matching
function test.compress.cx.pattern {
	
	# compress files relative to this test
	local self result;
	require.resolve "self";
	local dir="${self[1]}";	
	
	# map between file name and file contents
	# so we can also assert on file contents
	# after decompression
	declare -A entries;
	
	local program="tasks.compress";
	local cmd="";
	
	local files=(
		"${dir}/lipsum.txt"
		"${dir}/etiam.txt"
	);	
	
	# recreate test files
	!test.compress.files.create 10;	
	
	local ptnfiles=(
		"${dir}/test.js"
		"${dir}/test.css"
	);
	
	# create file(s) that should never be matched
	touch "${ptnfiles[@]}";
	
	# test pattern matching
	
	# match the .txt files only
	cmd="-c --noop --include (\.txt)$";
	result=( $( "$program" $cmd "${files[@]}" "${ptnfiles[@]}" ) );
	assert.eq "2" "${#result[@]}";
	assert.equal "${files[*]}" "${result[*]}";
	
	# match both .txt files (not the .js file)
	# and then skip etiam.txt with the --exclude pattern
	cmd="-c --noop --include (\.txt)$ --exclude ^e";
	result=( $( "$program" $cmd "${files[@]}" "${ptnfiles[@]}" ) );	
	assert.eq "1" "${#result[@]}";
	
	# include just .txt and .js file(s)
	cmd="-c --noop --include \.(txt|js)$";
	result=( $( "$program" $cmd "${files[@]}" "${ptnfiles[@]}" ) );
	assert.eq "3" "${#result[@]}";
	
	# include just .txt and .js file(s)
	# with multiple patterns
	cmd="-c --noop --include \.js$ --include \.txt$";
	result=( $( "$program" $cmd "${files[@]}" "${ptnfiles[@]}" ) );
	assert.eq "3" "${#result[@]}";
	
	# just exclude the .css file
	cmd="-c --noop --exclude \.css$";
	result=( $( "$program" $cmd "${files[@]}" "${ptnfiles[@]}" ) );
	assert.eq "3" "${#result[@]}";	
	
	# echo "got result: ${!result[@]} : ${result[@]}";
	
	# clean pattern matching test file(s)
	rm "${dir}/test.js" "${dir}/test.css";
	
	# clean up again
	!test.compress.files.clean;	
}

# test recursive functionality
function test.compress.cx.recursive {
	
	# compress files relative to this test
	local self result;
	require.resolve "self";
	local dir="${self[1]}";	
	
	# map between file name and file contents
	# so we can also assert on file contents
	# after decompression
	declare -A entries;
	
	local nested="${dir}/nested";
	local deep="${nested}/deep";
	local deeper="${deep}/deeper";
	
	local program="tasks.compress";
	local cmd="-c --noop";
	
	local files=(
		"${dir}/lipsum.txt"
		"${dir}/etiam.txt"
	);
	
	# recreate test files
	!test.compress.files.create 10;	
	
	# create the nested directory
	# and move test files into it
	mkdir -p "${deeper}";
	# move files into nested
	mv "${files[@]}" "$nested";
	# copy files into deep and deeper
	cp $( find "$nested" -depth 1 -type f ) "${deep}";
	cp $( find "$nested" -depth 1 -type f ) "${deeper}";
	
	# first command should only list files in ${dir}/nested
	result=( $( "$program" $cmd "$nested" ) );
	assert.eq "2" "${#result[@]}";
	
	# add recursive option to find all files from ${nested}
	cmd="-c --noop -r";
	result=( $( "$program" $cmd "$nested" ) );
	assert.eq "6" "${#result[@]}";
	
	# use recursive option with an --include pattern 
	cmd="-c --noop -r -i ^e";
	result=( $( "$program" $cmd "$nested" ) );
	assert.eq "3" "${#result[@]}";
	
	# use recursive option with an --exclude pattern 
	cmd="-c --noop -r -e ^lipsum";
	result=( $( "$program" $cmd "$nested" ) );
	assert.eq "3" "${#result[@]}";
	
	# clean up
	rm -rf "${nested}";
}

######################################################################
#
#	PRIVATE METHODS
#
######################################################################

# gather test files from ../archive, repeat the contents
# n times and write to this test directory
function !test.compress.files.create {
	local f contents o output i num="${1:-10}";
	
	# clean any existing entries if re-creating
	# the test files
	if [ ${#entries[@]} -gt 0 ]; then
		local k;
		for k in "${!entries[@]}"
			do
				unset entries["$k"];
		done
	fi
	
	# map between file sources and output
	declare -A sources;
	sources["${dir}/../archive/lipsum.txt"]="${dir}/lipsum.txt";
	sources["${dir}/../archive/etiam.txt"]="${dir}/etiam.txt";
	for f in "${!sources[@]}"
		do
			o="${sources["$f"]}";
			contents=$( cat "$f" );
			if [ ! -f "$o" ]; then
				echo -ne "" >| "$o";
			fi
			for((i=0;i < $num;i++))
				do
					echo "$contents" >> "$o";
					# spearate content entries with a newline
					echo "" >> "$o";
			done
			entries["$o"]=$( cat "$o" );
	done
}

# clean the test files
function !test.compress.files.clean {
	local f;
	shopt -s globstar;	
	for f in ${dir}/**
		do
			if [[ "$f" =~ (\.txt|\.gz)$ ]]; then
				rm "$f";
			fi
	done
	shopt -u globstar;
}