require.once 'tasks/compress';

# test(s) for task-compress(7) compress/decompress
function test.compress.cx.simple {
	# compress files relative to this test
	local self result;
	require.resolve "self";
	local dir="${self[1]}";
	
	# map between file name and file contents
	# so we can also assert on file contents
	# after decompression
	declare -A entries;
	
	# create the test files from the archive lipsum/etiam test
	# files, repeating the contents n times
	!test.compress.files.create 20;
	
	# TODO: compress files to -o | --output
	# TODO: extract files to -o | --output	
	
	#-o "${target}"
	
	local program="tasks.compress";
	local cmd="-c --verbose --debug";
	
	local files=(
		"${dir}/lipsum.txt"
		"${dir}/etiam.txt"
	);
	
	# execute the command
	$program $cmd "${files[@]}";
	
	# check the test and compressed files exist
	local f ext="gz";
	for f in "${files[@]}"
		do
			assert.file.exists? "$f";
			assert.file.exists? "${f}.${ext}";
	done
	
	# test the --noop option not that 
	# we add a couple of .gz files that should not
	# be located using the -c | create command
	cmd="-c --noop";
	result=( $( "$program" $cmd "${files[@]}" "lipsum.txt.gz" "etiam.txt.gz" ) );
	assert.equal "${files[*]}" "${result[*]}";
	
	# test the -x | extract command
	cmd="-x --verbose --debug";
	local compressed=(
		"${files[0]}.${ext}"
		"${files[1]}.${ext}"
	);
	
	# remove source files before decompression
	rm "${files[@]}";
	
	# verify that the source files have gone
	for f in "${files[@]}"
		do
			assert.file.exists! "$f";
	done	
	
	# extract compressed versions
	$program $cmd "${compressed[@]}";
	# assert that all files exist again after deflation
	for f in "${files[@]}"
		do
			assert.file.exists? "$f";
			assert.file.exists? "${f}.${ext}";
			# assert on extracted file contents
			assert.equal "${entries["$f"]}" "`cat "$f"`";
	done
	
	# test the --noop option with the -x | extract command
	# we add a couple of source files that should not
	# be located using the -x | extract command
	cmd="-x --noop";
	result=( $( "$program" $cmd "${compressed[@]}" "${files[@]}" ) );
	assert.equal "${compressed[*]}" "${result[*]}";
	
	# 
	# # clean up after test run
	# !test.compress.files.clean;
}

######################################################################
#
#	PRIVATE METHODS
#
######################################################################

# gather test files from ../archive, repeat the contents
# n times and write to this test directory
function !test.compress.files.create {
	local f contents o output i num="${1:-10}";
	
	# map between file sources and output
	declare -A sources;
	sources["${dir}/../archive/lipsum.txt"]="${dir}/lipsum.txt";
	sources["${dir}/../archive/etiam.txt"]="${dir}/etiam.txt";
	for f in "${!sources[@]}"
		do
			o="${sources["$f"]}";
			contents=$( cat "$f" );
			if [ ! -f "$o" ]; then
				echo -ne "" >| "$o";
			fi
			for((i=0;i < $num;i++))
				do
					echo "$contents" >> "$o";
					# spearate content entries with a newline
					echo "" >> "$o";
			done
			entries["$o"]=$( cat "$o" );
	done
}

# clean the test files
function !test.compress.files.clean {
	local f;
	shopt -s globstar;	
	for f in ${dir}/**
		do
			if [[ "$f" =~ (\.txt|\.gz)$ ]]; then
				rm "$f";
			fi
	done
	shopt -u globstar;
}