#!/usr/bin/env bash

: <<'ronn:markdown'
prompt(1) -- test program for prompt(3)
=============================================

## SYNOPSIS

	prompt [options] message [replacements...]

## DESCRIPTION

Test program for prompt(3) and console(3).

## OPTIONS

* `--color=[auto|never|always]`:

Sets the environment variable for sprintf(3) that overrides any `--color` options passed to sprintf(3).

## USAGE

When invoked with no options this program prints a series of test prompts. When options are specified they are passed on to prompt(3).

## EXAMPLES

Print test prompts:

	prompt

## BUGS

**prompt** is written in bash and depends upon `bash` >= 4.2.

## COPYRIGHT

**prompt** is copyright (c) 2012 muji <http://xpm.io>

## SEE ALSO

console(3), sprintf(3)
ronn:markdown

######################################################################
#
#	BOILERPLATE
#
######################################################################
export exedir;
function boilerplate {
	local src="${BASH_SOURCE[0]}"
	exedir="$( dirname "$src" )"
	while [ -h "$src" ]
		do 
			src="$(readlink "$src")";
			[[ $src != /* ]] && src="$exedir/$src";
			exedir="$( cd -P "$( dirname "$src"  )" && pwd )";
	done
	exedir="$( cd -P "$( dirname "$src" )" && pwd )";
	unset src;
	source "$exedir/../lib/shared" "$@";
}
boilerplate "$@";
######################################################################

# switch on strict mode
process.use strict;

# configure help
require 'help';
help.man.page "default" "prompt.1";
help.man.page "prompt" "prompt.3";
help.parse "$@";

require 'opts/version';
version.parse "$@";

declare -A messages;
messages[confirm]="are you sure? (y/n)";
messages[name]="enter a name";

declare -A responses;

# a before command callback
prompt.test.before() {
	local key="${1:-}";
	if [ -n "${key}" ]; then
		local msg="${messages[$key]:-}";
		console prompt "${msg}";
	fi
}

# a response command callback
prompt.test.response() {
	local value="${1:-}";
	local key="${2:-}";
	# echo "$FUNCNAME : $# : $*";
	if [ -n "${value}" ] && [ -n "${key}" ]; then
		responses[$key]="$value";
	fi
}

# print a summary of input
prompt.test.summary() {
	console header;
	console title "SUMMARY";
	console header;
	local k v;
	for k in "${!responses[@]}"
		do
			v="${responses[$k]}";
			console print "${k}=%s" "${v}";
	done
	console header;
}

# print test prompts
prompt.test() {	
	local opts="--before=prompt.test.before --response=prompt.test.response";
	prompt boolean $opts --id=confirm;
	prompt value $opts --id=name;
	
	prompt.test.summary;
}

if [ $# -eq 0 ]; then
	prompt.test;
else
	while [ "${1:-}" != "" ]; do
		case $1 in
			--color=auto | --color=never | --color=always )
				shift;
				;;
			* )
				break;
				;;
		esac
	done
	
	if [ $# -eq 0 ]; then
		prompt.test;
		exit 0;
	fi

	prompt "$@";
fi