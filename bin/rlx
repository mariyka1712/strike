#!/usr/bin/env bash

: <<'ronn:markdown'
rlx(1) -- couchdb command line interface
=============================================

## SYNOPSIS

A command line interface for couchdb(7).

## DESCRIPTION

Allows manipulation and querying of couchdb(7) databases from the command line.

## USAGE

	rlx shell [options...] [host]
	
## COMMANDS

* `shell`:

	Runs an interactive shell.
	
## SHELL COMMANDS

These commands apply when running as an interactive shell.

* `db`:

	When called with no options, this shell command will list available databases for the current database server.
	
* `db add [database]`:

	Create a database with the specified database name. The database name must match the pattern ^[-a-zA-Z0-9]+$.
	
* `db rm [database]`:

	Delete a database with the specified database name.

* `help`:

	Display this man page.
	
* `quit | exit`:

	Quit the interactive shell.
	
## FILES

The rlx(1) program stores various configuration files in `$HOME/.rlx`.

### AUTHENTICATION

Cached authentication information is stored in `$HOME/.rlx/auth.json` this file is encrypted using AES-256-CBC when the program is first run and a valid master password is supplied.

### RESPONSE

The JSON document containing the last database response is stored in `$HOME/.rlx/log/response.json`.
	
## DEPENDENCIES

openssl(1), curl(1), tee(1)

## BUGS

**rlx** is written in bash and depends upon `bash` >= 4.2.

## COPYRIGHT

**rlx** is copyright (c) 2012 muji <http://xpm.io>

## SEE ALSO

couchdb(3), http(3), json(3), curl(1)
ronn:markdown

set -o errtrace;
set -o nounset;

######################################################################
#
#	BOILERPLATE
#
######################################################################
console_print_program_prefix="off";
export exedir;
function boilerplate {
	local src="${BASH_SOURCE[0]}"
	exedir="$( dirname "$src" )"
	while [ -h "$src" ]
		do 
			src="$(readlink "$src")";
			[[ $src != /* ]] && src="$exedir/$src";
			exedir="$( cd -P "$( dirname "$src"  )" && pwd )";
	done
	exedir="$( cd -P "$( dirname "$src" )" && pwd )";
	unset src;
	source "$exedir/../lib/shared" "$@";
}
boilerplate "$@";
######################################################################

process.use strict;

# configure help
require 'help';
help.man.page "default" "rlx.1";
help.parse "$@";


# the current host being used
declare -g host="";
	
# credentials used for authentication
declare -g username;
declare -g password;

# the master password for auth.json
declare -g master;

function rlx {
	# we need these executables so test early
	executable.validate openssl curl tee;
	
	local cmd="${1:-}";
	shift;
	local rlxlib="${exedir}/../lib/rlx";
	local commands="${rlxlib}/commands";
	if [ ! -f "${commands}/${cmd}" ]; then
		console quit 1 "invalid %s command %s" "$process_name" "$cmd";
	fi
	
	# common code
	source "${rlxlib}/common";
	# command specific code
	source "${commands}/${cmd}";
	
	# dependencies
	require 'couchdb';
	require 'crypto';
	
	# the current prompt
	local prompt="${rlx_prompt_prefix}${rlx_prompt_suffix}";
	
	# a flag indicating whether we are in the process
	# of authenticating
	local authenticating=false;
	
	# list of databases for the current server
	local databases=();
	
	# change console output to always be the process name
	local k;
	for k in ${!console_prefixes[@]}
		do
			console_prefixes["$k"]="[$process_name]";
	done
	
	# NOTE: initialize $HOME/.rlx and sub-directories
	if ! rlx.firstrun?; then
		rlx.init;
	fi
	
	# set up the history file
	rlx_history="$HOME/.rlx/.history";
	if [ ! -f "$rlx_history" ]; then
		touch "$rlx_history";
	fi
	
	# the document containing the last JSON response
	local response_json="$HOME/.rlx/log/response.json";
	
	# update the location where http(3) stores response documents
	http_body_file="$response_json";
	
	delegate "rlx" "$cmd" "$@" || quit $? "command %s failed" "$cmd";
}

rlx "$@";