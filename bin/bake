#!/usr/bin/env bash

: <<'ronn:markdown'
bake(1) -- make for bash
=============================================

## SYNOPSIS

`bake` command [<options>...]<br>

## DESCRIPTION

**bake** is `make` for bash programs. The `bake` program does not define any tasks by default but some common tasks are available in the `modules/tasks` directory and can be included in a tasks file using `require`, for example:

	require 'tasks/clean';

## FILES

The bake(1) program looks for a `tasks` file in the current working directory and maps commands to the task methods found in the tasks file. A command is considered to be the first option passed to the `bake` executable, any other options specified on the command line are passed to the corresponding task method.

## ENVIRONMENT

The following variables are available to each command method:

* `root`:
	The directory where the `tasks` file is located.

* `target`:
	A temporary `target` directory corresponding to `${root}/target`.
	
* `tasks`:
	The file system path to the tasks file, eg: `${root}/tasks`.
	
## EXIT CODES

* `1`:
	No tasks file available in the current working directory.
* `2`:
	No tasks command method available.
* `3`:
	The task method invocation exited with a non-zero exit code.

## BUGS

**bake** is written in bash and depends upon `bash` >= 4.

## COPYRIGHT

**bake** is copyright (c) 2012 muji <http://xpm.io>

## SEE ALSO

task-test(7), task-doc(7), task-clean(7), task-list(7)
ronn:markdown

set -o errtrace;
set -o errexit;
set -o nounset;

# empty?() {
# 	echo "empty? called...";
# }
# 
# empty?;
# 
# function empty!()
# {
# 	echo "empty! called...";
# }
# 
# empty!;
# 
# exit 0;

######################################################################
#
#	BOILERPLATE
#
######################################################################
console_print_program_prefix="off";
declare -gx exedir;
function boilerplate {
	local abspath=$(cd ${BASH_SOURCE[0]%/*} && echo $PWD/${0##*/});
	if [ -L "$abspath" ]; then abspath=`readlink $abspath`; fi
	if [[ "$abspath" =~ ^\./ ]]; then abspath="${PWD}/${abspath}"; fi
	exedir=`dirname "$abspath"`;
	local libdir="$exedir/../lib";
	source "$libdir/shared" "$@";
}
boilerplate "$@";
######################################################################

# switch on strict mode
process.use strict;

# process.on exit trap;
# 
# #process.off trap;
# 
# #console.quit;
# 
# kill -s trap $$;
# 
# exit 1;

#json_number_regexp="^-?[0-9]+((\.[0-9]+)?([eE][-+]?[0-9]+)?)?$";

# # valid
# if [[ "-1" =~ $json_number_regexp ]]; then
# 	echo "got simple negative integer match ... ";
# fi
# 
# if [[ "127" =~ $json_number_regexp ]]; then
# 	echo "got simple positive integer match ... ";
# fi
# 
# if [[ "3.14" =~ $json_number_regexp ]]; then
# 	echo "got fraction match ... ";
# fi
# 
# if [[ "-3.14" =~ $json_number_regexp ]]; then
# 	echo "got negative fraction match ... ";
# fi
# 
# if [[ "2e10" =~ $json_number_regexp ]]; then
# 	echo "got integer exponent ... ";
# fi
# 
# if [[ "2e-10" =~ $json_number_regexp ]]; then
# 	echo "got integer negative exponent ... ";
# fi
# 
# if [[ "2e+10" =~ $json_number_regexp ]]; then
# 	echo "got integer positive exponent ... ";
# fi
# 
# if [[ "3.14e10" =~ $json_number_regexp ]]; then
# 	echo "got fraction exponent ... ";
# fi
# 
# if [[ "3.14e-10" =~ $json_number_regexp ]]; then
# 	echo "got fraction negative exponent ... ";
# fi
# 
# if [[ "3.14e+10" =~ $json_number_regexp ]]; then
# 	echo "got fraction positive exponent ... ";
# fi
# 
# if [[ "3.14E+10" =~ $json_number_regexp ]]; then
# 	echo "got fraction uppercase positive exponent ... ";
# fi
# 
# # invalid
# if [[ "-3." =~ $json_number_regexp ]]; then
# 	echo "got trailing period matach (error) ... ";
# fi
# 
# exit 0;

# process.pid;

# notok() {
# 	return 1;
# }
# 
# ok() {
# 	return 0;
# }
# 
# if ok; then
# 	echo "everything ok...";
# fi
# 
# if notok; then
# 	echo "everything is not ok...";
# fi
# 
# echo "got to end of test..."
# exit 0;

# arr=(a b c);

# if array.contains? "a" "${arr[@]}" && array.contains? "b" "${arr[@]}"; then
# 	echo "array contains a and b";
# fi
# 
# if array.contains? "a" "${arr[@]}" || array.contains? "b" "${arr[@]}"; then
# 	echo "array contains a or b";
# fi
# 
# if ! array.contains? "d" "${arr[@]}"; then
# 	echo "array does not contain d";
# fi
# 
# echo "got to end of test..."
# exit 0;

# console.info "this is an info message";
# console.log.stdout "./target/test.log";
# console.info "this is a log file message";
# console.log.stdout.close;
# console.info "this is a message after log file close";
# 
# exit 0;

# console.log.stderr.close;

# console.error "this is an error message";
# console.log.stderr "./target/test.log";
# console.error "this is an error log file message";
# console.log.stderr.close;
# console.error "this is an error message after log file close";
# 
# exit 0;

# function :accessor {
# 	echo ":accessor called ... ";
# }
# 
# :accessor;

# configure help
require 'help';
help.man.page "default" "bake.1";
help.parse "$@";

# TODO: add --version handling

if [ $# -eq 0 ]; then
	help.man.show.default;
	exit 1;
fi

function bake {
	local nm="tasks";
	local f="${PWD}/${nm}";
	if [ ! -f "$f" ]; then
		quit 1 "no %s file in %s" "$nm" "${PWD}";
	else
		# variables to expose to the task(s)
		local root=`dirname $f`;
		local target="${root}/target";
		local tasks="$f";
		
		if [ ! -d "${target}" ]; then
			mkdir -p "${target}";
		fi
		
		require "$f";
		local cmd="$1";
		shift;
		local func="${nm}.${cmd}";
		if ! method.exists? "$func"; then
			quit 2 "task %s not found" "$cmd";
		fi
		
		# invoke  the task function		
		delegate "tasks" "$cmd" "$@" || quit 3 "task %s failed" "$func";
	fi
}

bake "$@";