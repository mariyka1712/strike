#!/usr/bin/env bash

: <<'ronn:markdown'
bake(1) -- make for bash
=============================================

## SYNOPSIS

`bake` command [<options>...]<br>

## DESCRIPTION

**bake** is `make` for bash programs. It provides an extensible system for managing project tasks using modular code.
	
## BUILTIN TASKS

All bake(1) projects have the following tasks built in task-test(7), task-clean(7), task-ls(7), task-doc(7) and task-semver(7).

## REQUIRE TASKS

The convention is that task methods are not declared in tasks(7) but are placed in modules and then included using require(3). So to include the task-todo(7) functionality into your project all you need to do is require(3) it:

	require 'tasks/todo';

## FILES

The bake(1) program looks for a tasks(7) file in the current working directory. If no tasks(7) file is found in the current working directory then bake(1) will walk all parent directories looking for a tasks(7) file.

It maps commands (the first option passed to bake(1)) to task method(s) declared by the tasks file. A command is considered to be the first option passed to the `bake` executable, any other options specified on the command line are passed to the corresponding task method.

## VARIABLES

The following variables are available to each task command:

* `root`:

The directory where the `tasks` file is located.

* `project_name`:

The name of the project as determined by the name of the `${root}` directory.

* `project`:

This is the root of the project. For most projects this will be equivalent to `${root}` but is useful for multi-module projects where `${root}` points to the directory for the module and `${project}` is the root of the project.

* `project_version`:

The project version number, if no version information is available the value *0.0.0* is used.

* `target`:

A temporary `target` directory corresponding to `${root}/target`.

* `tasks`:

The file system path to the tasks file, eg: `${root}/tasks`.

* `tasks_file_name`:

The name of the `tasks` file, if `bake_file_name` has been set this will equal that value, otherwise the default *tasks* is used.

## ENVIRONMENT

* `bake_file_name`:

Determines the name of the file that bake(1) looks for to load task command methods from, default is *tasks*. 

## EXIT CODES

A >0 exit code is used when no task(7) file could be located or no command is available, otherwise the exit code is deferred to the task being executed.

* `1`:

No task(7) file available in the current working directory (or any parent directories).

* `2`:

No task command available.

* `>0`:

The task command invocation returned a non-zero exit code but did not explicitly call `exit`.

It is recommended that task command implementations explicitly exit the program using the `quit` and `success` commands declared by console(3).

## BUGS

**bake** is written in bash and depends upon `bash` >= 4.2.

## COPYRIGHT

**bake** is copyright (c) 2012 muji <http://xpm.io>

## SEE ALSO

task-test(7), task-doc(7), task-clean(7), task-ls(7), task-semver(7)
ronn:markdown

set -o errtrace;
set -o errexit;
set -o nounset;

# empty?() {
# 	echo "empty? called...";
# }
# 
# empty?;
# 
# function empty!()
# {
# 	echo "empty! called...";
# }
# 
# empty!;
# 
# exit 0;

######################################################################
#
#	BOILERPLATE
#
######################################################################
console_print_program_prefix="off";
export exedir;
function boilerplate {
	local src="${BASH_SOURCE[0]}"
	exedir="$( dirname "$src" )"
	while [ -h "$src" ]
		do 
			src="$(readlink "$src")";
			[[ $src != /* ]] && src="$exedir/$src";
			exedir="$( cd -P "$( dirname "$src"  )" && pwd )";
	done
	exedir="$( cd -P "$( dirname "$src" )" && pwd )";
	unset src;
	source "$exedir/../lib/shared" "$@";
}
boilerplate "$@";
######################################################################

# switch on strict mode
process.use strict;

# ( cd -P ~/"git" && pwd );
# exit 0;

# 
# require.once 'command/find';
# 
# if find.gnu?; then
# 	echo "got gnu find";
# else
# 	echo "got bsd find";
# fi
# 
# echo "after find test ... ";
# exit 0;

# value="\"a quoted value\"";
# 
# echo "$value";
# 
# value="${value#\"}";
# value="${value%\"}";
# 
# echo "$value";
# 
# exit 0;

# declare -gx cmdline="";
# 
# #complete -F "sd" -o "default" "sd"
# 
# #complete -F "tab" -o "dirname" "db";
# 
# function tab
# {
# 	echo "$FUNCNAME";
# }
# 
# set -o emacs;
# #bind -x '"\t":"tab"';
# 
# complete -F tab -o filenames "$0";
# 
# #newlinr
# 
# while read -r -e line;
# 	do
# 		cmdline="$line";
# 		#echo "got line: $line"
# 		#line="${line}${char}";
# 		#echo "got line: $line";
# 		#echo -ne "";
# done

#exit 0;

# require inet;
# 
# set +o errexit;
# inet.up?;
# echo "exit code in bake: $?";
# #set -e;
# 
# exit 0;

# ptn="[^]\+?\s??.?";
# 
# [[ "abc" =~ $ptn ]] && {
# 	echo "pattern ok!";
# 	exit 0;
# }
# echo "ptn exit: $?";
# exit 0;

# function list {
# 	echo "$FUNCNAME: $*";
# }
# 
# list a b c $( ls . );
# 
# exit 0;

# function command_not_found_handle {
# 	echo "$FUNCNAME: $*";
# }

#missing a b c d e f;

#exit 0;

# keys="c
# b
# a";
# 
# sort <<< "$keys";
# 
# exit 0;


# arr=( 1 2 3 );
# 
# index=0;
# while [ ${#arr[@]} -gt 0 ];
# 	do
# 		echo "removed : ${!arr[@]} : ${#arr[@]}";
# 		unset arr[$index];
# 		: $((index++));
# done
# 
# exit 0;

# len()
# {
# 	echo "$# : $@";
# }
# 
# len a;
# 
# len a\ b;
# 
# exit 0;

#require.once 'attr';

# attr.reader;
# attr.reader a b c;

# attr.reader :abc.reader "abc";
# 
# #attr.writer;
# #attr.writer a b c;
# # attr.writer :abc.writer;
# # 
# # #attr.accessor :abc.readwrite;
# # 
# # method.list | grep abc;
# 
# abc.reader;
# echo "after reader: '$_result'";
# # env | grep abc;
# 
# #attr.accessor;
# 
# exit 0;

# "version": "0.1.1"

# require.once 'json';
# 
# pkgwrite() {
# 	
# 	# json.parse
# 	
# 	local str=`cat package.json`;
# 	# :\s?\"([^\"]+)\"
# 	local regexp="\"version\"[ 	]{0,}:[ 	]*\"";
# 	echo "regexp: '$regexp'";
# 	echo "got source: $str";
# 	str=${str/$regexp/abc};
# 	echo "matches: ${!BASH_REMATCH[@]}"
# 	echo "got replaced: $str";
# 	
# 	#sed 'PATTERNs/REGEXP/REPLACEMENT/FLAGS' filename	
# 	
# 	# local regexp="(\"version\"[ 	]*:[ 	]*\")[^\"]+(\")";
# 	# local replace="\1abc\2";
# 	# sed -E "s/$regexp/$replace/g" "package.json";
# }
# 
# pkgwrite;
# 
# exit 0;

# version() {
# 	local file="${process_dirs[root]}/version";
# 	local semver=$( cat "$file" );
# 	console.info "version %s" "$semver";
# }
# version;
# 
# exit 0;

# if method.exists? "return"; then
# 	echo "return command exists";
# fi

# function del {
# 	echo "del called"
# }
# 
# declare del="abc";
# 
# del;
# echo "$del";
# exit 0;

# require 'git';
# git.branch.message;
# echo "$_result";
# git.branch.message master;
# echo "$_result";
# exit 0;

#declare -f -F;

#exit 0;

#alias "_return=return";

# function return {
# 	local exitcode="${2:-0}";
# 	if [[ "$1" =~ ^[0-9]+$ ]]; then
# 		echo "return called with number $1";
# 		builtin return $exitcode;
# 	else
# 		_result="$1";
# 		echo "return called with alpha $1";
# 		builtin return $exitcode;
# 	fi
# }
# 
# function method.alpha {
# 	return "$1";
# }
# 
# function method.number {
# 	return "$1";
# }
# 
# function method.alpha.branch {
# 	return "$1" && builtin return;
# 	echo "$FUNCNAME";
# }
# 
# #alias "return=method.return";
# 
# method.alpha "abc";
# method.number "0";
# method.alpha.branch "abcdef";
# 
# exit 0;

# process.on exit trap;
# 
# #process.off trap;
# 
# #console.quit;
# 
# kill -s trap $$;
# 
# exit 1;

#json_number_regexp="^-?[0-9]+((\.[0-9]+)?([eE][-+]?[0-9]+)?)?$";

# # valid
# if [[ "-1" =~ $json_number_regexp ]]; then
# 	echo "got simple negative integer match ... ";
# fi
# 
# if [[ "127" =~ $json_number_regexp ]]; then
# 	echo "got simple positive integer match ... ";
# fi
# 
# if [[ "3.14" =~ $json_number_regexp ]]; then
# 	echo "got fraction match ... ";
# fi
# 
# if [[ "-3.14" =~ $json_number_regexp ]]; then
# 	echo "got negative fraction match ... ";
# fi
# 
# if [[ "2e10" =~ $json_number_regexp ]]; then
# 	echo "got integer exponent ... ";
# fi
# 
# if [[ "2e-10" =~ $json_number_regexp ]]; then
# 	echo "got integer negative exponent ... ";
# fi
# 
# if [[ "2e+10" =~ $json_number_regexp ]]; then
# 	echo "got integer positive exponent ... ";
# fi
# 
# if [[ "3.14e10" =~ $json_number_regexp ]]; then
# 	echo "got fraction exponent ... ";
# fi
# 
# if [[ "3.14e-10" =~ $json_number_regexp ]]; then
# 	echo "got fraction negative exponent ... ";
# fi
# 
# if [[ "3.14e+10" =~ $json_number_regexp ]]; then
# 	echo "got fraction positive exponent ... ";
# fi
# 
# if [[ "3.14E+10" =~ $json_number_regexp ]]; then
# 	echo "got fraction uppercase positive exponent ... ";
# fi
# 
# # invalid
# if [[ "-3." =~ $json_number_regexp ]]; then
# 	echo "got trailing period matach (error) ... ";
# fi
# 
# exit 0;

# process.pid;

# notok() {
# 	return 1;
# }
# 
# ok() {
# 	return 0;
# }
# 
# if ok; then
# 	echo "everything ok...";
# fi
# 
# if notok; then
# 	echo "everything is not ok...";
# fi
# 
# echo "got to end of test..."
# exit 0;

# arr=(a b c);

# if array.contains? "a" "${arr[@]}" && array.contains? "b" "${arr[@]}"; then
# 	echo "array contains a and b";
# fi
# 
# if array.contains? "a" "${arr[@]}" || array.contains? "b" "${arr[@]}"; then
# 	echo "array contains a or b";
# fi
# 
# if ! array.contains? "d" "${arr[@]}"; then
# 	echo "array does not contain d";
# fi
# 
# echo "got to end of test..."
# exit 0;

# console.info "this is an info message";
# console.log.stdout "./target/test.log";
# console.info "this is a log file message";
# console.log.stdout.close;
# console.info "this is a message after log file close";
# 
# exit 0;

# console.log.stderr.close;

# console.error "this is an error message";
# console.log.stderr "./target/test.log";
# console.error "this is an error log file message";
# console.log.stderr.close;
# console.error "this is an error message after log file close";
# 
# exit 0;

# function :accessor {
# 	echo ":accessor called ... ";
# }
# 
# :accessor;

# configure help
require 'help';
help.man.page "default" "bake.1";
help.man.page "ls" "task-ls.7";
help.man.page "test" "task-test.7";
help.man.page "doc" "task-doc.7";
help.man.page "clean" "task-clean.7";
help.man.page "semver" "task-semver.7";
help.man.page "project" "task-project.7";
help.man.page "deploy" "task-deploy.7";
help.man.page "deploy-json" "task-deploy-json.7";
help.man.page "module" "task-module.7";
help.parse "$@";

if [ $# -eq 0 ]; then
	help.man.show.default;
	exit 0;
fi

require 'opts/version';
version.parse "$@";

# default builtin tasks
require 'tasks/test';
require 'tasks/clean';
require 'tasks/ls';
require 'tasks/doc';
require 'tasks/semver';
require 'tasks/deploy';
require 'tasks/module';

bake() {
	# method namespace
	local namespace="tasks";
	local tasks_file_name="${bake_file_name:-tasks}";
	fs.walk "$tasks_file_name";
	local f="$_result";
	if [ ! -f "$f" ]; then
		quit 1 "no %s file in %s (or any of the parent directories)" \
            "$tasks_file_name" "${PWD}";
	else
		# variables to expose to the task(s)
		local root=$( dirname $f );
		local target="${root}/target";
		local tasks="$f";
		
		# expose project variable pointing to the 
		# root so that submodules may access the root
		# of the project using this variable
		# this is because ${root} is changed when submodules
		# are used
		local project="${root}";
		
		if [ ! -d "${target}" ]; then
			mkdir -p "${target}";
        fi

        local project_name;
        fs.basename "${root}" "project_name";

        local project_version="0.0.0";
        # TODO: use task/semver to retrieve version information
        if [ -f "${root}/version" ]; then
            project_version=$( cat "${root}/version" );
        fi
		
		# set the temporary directory to `target`
		# for bake(1) processes
		process.tmp.dir "${target}";
		
		require "$f";
		local cmd="$1";
		shift;
		local func="${namespace}.${cmd}";
		if ! method.exists? "$func"; then
			quit 2 "task %s not found" "$cmd";
		fi
		
		# invoke the task function
		delegate "${namespace}" "$cmd" "$@" || quit $? "task %s failed" "$func";
	fi
}

bake "$@";
