#!/usr/bin/env bash

######################################################################
#
#	BOILERPLATE
#
######################################################################
export exedir;
boilerplate() {
	local src="${BASH_SOURCE[0]}"
	exedir="$( dirname "$src" )"
	while [ -h "$src" ]
		do 
			src="$(readlink "$src")";
			[[ $src != /* ]] && src="$exedir/$src";
			exedir="$( cd -P "$( dirname "$src"  )" && pwd )";
	done
	exedir="$( cd -P "$( dirname "$src" )" && pwd )";
	unset src;
	. "$exedir/../lib/shared" "$@";
}
boilerplate "$@";
######################################################################

process.use strict;


# configure help
require 'help';
help.man.page "default" "manual.1";
help.parse "$@";

require 'opts/version';
version.parse "$@";

executable.validate man fmt;

console header;
console title "%s %s" "${process_name}" "${version}";
console title "";
console title "Type %s or %s for command information" "?" "help";
console title "Type %s, %s or %s to exit the program" "q" "quit" "exit";
console title "Use the %s key for completion on available man pages" "tab";
console header;

# COMMANDS

# list commands for tab completion
declare -ag commands=(
  ls
  build
);

declare -Ag command_help;
command_help["name.[1-8]"]="Show a manual page using man(1), ";
command_help["name.[1-8]"]+="use the ls command or tab completion ";
command_help["name.[1-8]"]+="to list available manual pages";
command_help[?]="Print command help";
command_help[help]="Show manual(1) man page";
command_help[ls]="List available man pages";
command_help[build]="Command for developers to ";
command_help[build]+="generate latest versions of the man pages ";
command_help[build]+="from the markdown source, requires ronn(1)";

# print command information
manual.commands.help() {
  printf "\n";
  console print "%s %s" "${process_name}" "${version}";
  printf "\n";
  local k v;
  for k in "${!command_help[@]}"
    do
      v="${command_help[$k]}";
      console print --color=always "\t%s" "${k}" | expand -t 2;
      printf "\t\t${v}" | expand -t 2 |  fmt;
      printf "\n";
  done
}

# show manual(1) man page
manual.commands.man() {
  help.man.show.default false;
}

# build latest man pages
manual.commands.build() {
  require.once 'tasks/doc';
  tasks.doc man build;
}

# list man pages using the same
# logic as the tab completion so
# that the columns match the default
# tab completion output
manual.commands.ls() {
  local pages="${process_dirs[man]}";
  manual.completion false;
  prompt.completion.print;
}

# INTERNAL

# handle completion
manual.completion() {
  local cmds="${1:-true}";
	local cur="${COMP_WORDS[${COMP_CWORD:-}]:-}";
  local pages="${process_dirs[man]}";
  local files=( $(ls "${pages}") );
  local words="${files[*]}";
  if $cmds; then
    words="${commands[*]} ${files[*]}";
  fi
	COMPREPLY=( $( compgen -W "${words}" -- "$cur" ) );
}

# handle input
manual.response() {
  #echo "got response $*"
  local namespace="manual.commands";
  local input="${1:-}";
  local words=( $input );
  if [ -z "${input}" ]; then
    return 1;
  fi
  local pages="${process_dirs[man]}";
  local page="${pages}/${input}";
  # prefer showing man pages first
  if [ -f "${page}" ]; then
    man "${page}";
  fi
  # handle help
  if [ "${input}" == "?" ]; then
    manual.commands.help;
  elif [ "${input}" == "help" ]; then
    manual.commands.man;
  else
    if [ ${#words[@]} -gt 0 ]; then
      local cmd="${namespace}.${words[0]}";
      if method.exists? "${cmd}";then
        "$cmd";
      fi
    fi
  fi
}

# show the prompt
manual() {
	local hist_file=~/.manual.history.log;
  if [ ! -f "${hist_file}" ]; then
    touch "${hist_file}";
  fi
	local opts=(
		--response=manual.response
		--hist-file="$hist_file"
	);
  prompt line \
    --response=manual.response \
    --complete=manual.completion \
    --multiline \
    --quit="q quit exit" \
    --infinite;
}

manual;
