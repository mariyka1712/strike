#!/usr/bin/env bash

######################################################################
#
#	BOILERPLATE
#
######################################################################
export exedir;
boilerplate() {
  local src="${BASH_SOURCE[0]}"
  exedir="$( dirname "$src" )"
  while [ -h "$src" ]
  do
    src="$(readlink "$src")";
    [[ $src != /* ]] && src="$exedir/$src";
    exedir="$( cd -P "$( dirname "$src"  )" && pwd )";
  done
  exedir="$( cd -P "$( dirname "$src" )" && pwd )";
  unset src;
  . "$exedir/../lib/shared" "$@";
}
boilerplate "$@";
######################################################################

process.use strict;

require 'help';
help.man.page "default" "manual.1";
help.parse "$@";

require 'opts/version';
version.parse "$@";

executable.validate man fmt;

console header;
console title "%s %s" "${process_name}" "${version}";
console title "";
console title "Type %s or %s for command information" "?" "help";
console title "Type %s, %s or %s to exit the program" "q" "quit" "exit";
console title "Use the %s key for completion on available man pages" "tab";
console header;

# list commands for tab completion
declare -ag commands=(
  build
  clean
  compile
  generate
  import
  ls
  paths
);

declare -ag exits=( q quit exit );

declare -Ag command_help;
command_help["name.[1-8]"]="Show a manual page using man(1), ";
command_help["name.[1-8]"]+="use the ls command or tab completion ";
command_help["name.[1-8]"]+="to list available manual pages";
command_help[?]="Print command help";
command_help["q | quit | exit"]="Exit the program";
command_help[help]="Show manual(1) man page";
command_help[paths]="Print paths in MANPATH";
command_help[ls]="List available man pages";
command_help[build]="Build latest versions of the man pages ";
command_help[build]+="from the markdown source, requires ronn(1)";
command_help[generate]="Generate ronn documents from inline heredocs";
command_help[compile]="Compile all ronn documents, requires ronn(1)";
command_help[import]="Import compiled manual pages into the man directory";
command_help[clean]="Remove all compiled manual pages from the man directory";

# COMMANDS

# list man page paths
manual.commands.paths() {
  local paths="${MANPATH:-}";
  if test -z "${paths}"; then
    console bell; return 1;
  fi
  local IFS=":";
  local folders=( $paths );
  unset IFS;
  if [ -z "${folders[*]}" ] || [ ${#folders[@]} -eq 0 ]; then
    console bell; return 1;
  fi
  local d;
  for d in "${folders[@]}"
    do
      printf -- "${d}\n";
  done
}

# build latest man pages
manual.commands.build() {
  require.once 'tasks/doc';
  tasks.doc man build;
}

# generate ronn documents from inline heredocs
manual.commands.generate() {
  require.once 'tasks/doc';
  tasks.doc man generate;
}

# compile all ronn documents
manual.commands.compile() {
  require.once 'tasks/doc';
  tasks.doc man compile;
}

# import compiled man pages
manual.commands.import() {
  require.once 'tasks/doc';
  tasks.doc man import;
}

# remove manual pages
manual.commands.clean() {
  require.once 'tasks/doc';
  tasks.doc man clean;
}

# list man pages using the same
# logic as the tab completion so
# that the columns match the default
# tab completion output
manual.commands.ls() {
  local pages="${process_dirs[man]}";
  manual.completion false;
  prompt.completion.print;
}

# INTERNAL

# print command information
manual.help.show() {
  printf "\n";
  local k v;
  for k in "${!command_help[@]}"
    do
      v="${command_help[$k]}";
      console print --color=always "\t%s" "${k}" | expand -t 2;
      printf "\t\t${v}" | expand -t 2 |  fmt;
      printf "\n";
  done
}

# handle completion
manual.completion() {
  local cmds="${1:-true}";
  local cur="${COMP_WORDS[${COMP_CWORD:-}]:-}";
  local pages="${process_dirs[man]}";
  local files=( $(ls "${pages}") );
  local words="${files[*]:-}";
  if $cmds; then
    words="${commands[*]} ${files[*]:-}";
  fi
	COMPREPLY=( $( compgen -W "${words}" -- "$cur" ) );
}

# handle input
manual.response() {
  local namespace="manual.commands";
  local input="${1:-}";
  # prevent error message on exit commands
  if array.contains? "${input}" "${exits[@]}"; then
    return 0;
  fi
  local words=( $input );
  if [ -z "${input}" ]; then
    return 1;
  fi
  local pages="${process_dirs[man]}";
  local page="${pages}/${input}";
  # prefer showing man pages first
  if [ -f "${page}" ]; then
    man "${page}"; return 0;
  fi
  # handle help
  if [ "${input}" == "?" ]; then
    manual.help.show;
  elif [ "${input}" == "help" ]; then
    help.man.show.default false;
  else
    if [ ${#words[@]} -gt 0 ]; then
      local cmd="${namespace}.${words[0]}";
      if method.exists? "${cmd}";then
        "$cmd";
      else
        console error "unknown command %s" "${input:-}";
      fi
    fi
  fi
}

# show the prompt
manual() {
  local hist_file=~/.manual.history.log;
  if [ ! -f "${hist_file}" ]; then
    touch "${hist_file}";
  fi
  local opts=(
    --response=manual.response
    --hist-file="$hist_file"
  );
  prompt line \
    --hist-file="$hist_file" \
    --response=manual.response \
    --complete=manual.completion \
    --multiline \
    --quit="${exits[*]}" \
    --infinite;
}

manual;
