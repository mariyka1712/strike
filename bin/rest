#!/usr/bin/env bash

: <<'ronn:markdown'
rest(1) -- generate HTTP(S) requests
=============================================

## SYNOPSIS

`rest` command [<options>...] <url><br>

## DESCRIPTION

**rest** generates HTTP(S) requests using the http(1) module which wraps curl(1). The core commands correspond to the HTTP verbs GET, POST, PUT, HEAD, DELETE and OPTIONS.

## FILES

The http(1) module generates some temporary files and files used for logging purposes and command persistence.

## COMMANDS

The rest(1) program expects the first option to be a command, below is the list of available commands:

* `get`:
	Perform a GET request:
	
	`rest get google.com`
	
* `head`:
	Perform a HEAD request:

	`rest head google.com`
	
	Note that this command does not use the `--request HEAD` option as curl(1) tends to hang when using the HEAD verb, instead this command uses the `--head` option along with a GET request method.
	
* `post`:
	Perform a POST request:

	`rest post --json '{"name":"value"}' google.com`
	
* `put`:
	Perform a PUT request:

	`rest put --json '{"name":"value"}' google.com`
	
* `delete`:
	Perform a DELETE request:

	`rest delete google.com`
	
* `dl`:
	Download a file:

	`rest dl google.com/index.html`
	
* `redo`:
	Repeat the last request:

	`rest redo`
	
* `load` `<name>`:
	Loads and executes a previously saved configuration file:

	`rest get --save google google.com`<br>
	`rest load google`	
	
* `clean`:
	Remove files generated by the last request:

	`rest clean`
	
* `config`:
	Print the contents of the `http.config` file:

	`rest config`

## OPTIONS

Wherever possible **rest** follows the command line options available to curl(1) but also adds some convenient shortcut options.

* `--type`:
	Set the content type for the request.

* `-H`, `--header`:
	Set a request header.
	
* `-d`, `--data`:
	Data to send with the request, see curl(1) for more information.
	
* `--json`:
	Sends data using the `--data-binary` option and adds a *content-type* of **application/json**.
	
* `--xml`:
	Sends data using the `--data-binary` option and adds a *content-type* of **text/xml**.
	
* `--param` `<name>` `<value>`:
	Add a URL query string parameter, repeatable. The `<value>` should *not* be URL-encoded.
	
* `--save` `<name>`:
	Saves a configuration file into `.http/config` with the specified name. This configuration file may then later be executed using the `load` command.
	
### PRINT OPTIONS

The `--print-*` options control what is output after a request has been made.

* `--print-body`:
	Print the body of the response.
	
* `--print-headers`:
	Print all response headers.
	
* `--print-env`:
	Print all `http_*` variables. This print output option outputs the variables in a `name=value` format with the values quoted using printf(1). This allows redirection of the output to a file that could later be included using source(1). For example:

	rest get --print-env google.com > http.vars;<br>
	source http.vars;

## BUGS

**rest** is written in bash and depends upon `bash` >= 4.

* `--print-env`:
	The output of this option does not output array values correctly, only the first array entry is available.

## COPYRIGHT

**rest** is copyright (c) 2012 muji <http://xpm.io>

## SEE ALSO

curl(1)
ronn:markdown

set -o errtrace;
set -o errexit;
set -o nounset;

######################################################################
#
#	BOILERPLATE
#
######################################################################
export PROGRAM_NAME=`basename $0`;
program_config_print_welcome="off";
program_config_print_prefix="off";
declare -gx exedir;
function boilerplate {
	local abspath=$(cd ${BASH_SOURCE[0]%/*} && echo $PWD/${0##*/});
	if [ -L "$abspath" ]; then
		abspath=`readlink $abspath`;
	fi
	exedir=`dirname "$abspath"`;
	local libdir="$exedir/../lib";
	source "$libdir/shared";
}
boilerplate;
######################################################################

# test that re-requiring doesn't override previous data
# require 'executable';
# executable validate curl;
# echo "curl : ${executables[curl]}"
# require 'executable';
# echo "curl after re-require : ${executables[curl]}"
# exit 0;

# set up the main delegate module as 'rest'
module="$PROGRAM_NAME";

#method_start_diff;
require 'options';
#method_end_diff;
require 'rest';

#switch on strict mode for http requests
#forces the program to quit if curl exits with a non-zero
#exit code
http_strict="on";

#options add flag "v" "verbose" 'verbose program output';

# module.method() {
# 	echo "module.method"
# }
# 
# module.method;
# 
# #method.remove module.method;
# 
# module.method;

#exit 0;

# #variable_set "mytest" "myvalue";
# 
# #variable_get "mytest";
# #echo "mytest: $_result";
# 
# variable_declare "mytest_1" "myvalue" "agx";
# 
# variable_get "mytest_1";
# echo "mytest: $_result";
# 
# # TODO: get this to work more dynamically
# #variable_unset "mytest";
# 
# exit 0;

#arr1=( 1 2 3 );
#arr2=( arr1=${arr1[*]} );
#test1=arr2[*];

#method_list;

#require_list;

# arr=();
# #declare -p "arrb" 2> /dev/null | grep -q 'declare \-a';
# 
# variable_is_array "arr";
# echo "response: $_result";
# exit 0;

options_minimum=1;
#options_fail_help=1;
options_expects_command=( get head post put delete options clean load redo config dl );
options_map_command_method=1;

#map the last option to the rest_request_url variable
options_map_last="rest_request_url";

#configure all the option defaults
options configure;

#parse the parameters
options parse "$@";

# parse custom program options
rest options.parse "$@";

function rest.query.string() {
	url.params.stringify;
	params="$_result";
	if [ ! -z "$params" ]; then
		rest_request_url="${rest_request_url}${params}";
	fi
}

# append any query string parameters
# to the request url
rest.query.string;

#always add the url as the last option
module_options+=( "$rest_request_url" );

main "${module:-}" "${options_command_method:-}" "${module_options[@]:-}";

exit 0;